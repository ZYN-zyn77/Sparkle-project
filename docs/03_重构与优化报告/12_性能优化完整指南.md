# 性能优化完整指南 (Performance Optimization Guide)

## 1. 概述 (Overview)

为了确保 Sparkle 在多端（特别是中低端移动设备）上的流畅体验，以及后端在高并发场景下的稳定性，我们实施了全链路的性能优化策略。本指南详细说明了移动端、网关层和智能引擎层的优化机制。

---

## 2. 移动端优化 (Mobile Optimization)

移动端优化的核心在于 **自适应降级 (Adaptive Degradation)** 和 **渲染效率**。

### 2.1 PerformanceService (核心机制)

`PerformanceService` 是一个全局单例，负责实时监控设备帧率 (FPS) 并根据负载自动调整渲染质量。

#### 性能分级 (Performance Tiers)

系统定义了 4 个性能等级：

| 等级 | 描述 | 特效开启 | 适用设备 |
| :--- | :--- | :--- | :--- |
| **Ultra** | 极致视觉 | 全部开启 (高斯模糊 + 动态噪点 + 粒子特效 + 内发光) | 高端旗舰机 (iPhone 14 Pro+, Snap 8 Gen 2+) |
| **High** | 高质量 | 关闭动态噪点，保留模糊和粒子 | 主流机型 |
| **Medium** | 平衡 | 降低模糊半径，减少粒子数量 | 中端机型 |
| **Low** | 性能优先 | 关闭模糊 (回退到半透明)，关闭粒子和阴影 | 低端机/老旧设备 |

#### 动态监控逻辑

1.  **FPS 采样**: 维护一个滑动窗口，记录最近 1 秒内的帧渲染时间。
2.  **降级触发**: 如果连续 10 秒 FPS 低于阈值 (如 35fps@60Hz)，触发降级。
    -   **策略 1**: 降低 DPR (Device Pixel Ratio) 至 0.7x。
    -   **策略 2**: 如果 DPR 调整无效，降低 `PerformanceTier`。
3.  **升级触发**: 如果连续 20 秒 FPS 稳定在满帧 (如 58fps@60Hz)，尝试恢复等级。

### 2.2 渲染优化技术

#### 材质渲染 (MaterialStyler)
- **RepaintBoundary**: 在复杂的 `MaterialStyler` 外层包裹 `RepaintBoundary`，避免父组件重绘导致的光效重算。
- **条件模糊**: 当 Tier 为 Low 时，`BackdropFilter` 会被替换为普通的 `Container` (带透明度颜色)，彻底消除模糊开销。

#### 粒子系统 (Particle System)
- **对象池 (Object Pooling)**: `ParticlePool` 复用粒子对象，避免高频 GC。
- **Instanced Drawing**: 对于大量相同粒子 (如 Focus Mode 的星空)，使用自定义 Shader 批量绘制。

#### 列表渲染
- **Sliver**: 长列表强制使用 `SliverList` / `SliverGrid`。
- **const构造**: 列表项尽可能使用 `const` 构造函数。

---

## 3. 网关层优化 (Gateway Optimization - Go)

Go 网关负责处理数万级并发 WebSocket 连接，性能瓶颈主要在于内存和 Goroutine 调度。

### 3.1 连接管理

- **Goroutine 模型**: 每个 WebSocket 连接占用 2 个 Goroutine (ReadPump / WritePump)。
- **零拷贝升级**: 使用 `Gorilla WebSocket` 的优化配置，减少 HTTP 升级过程中的内存分配。

### 3.2 内存优化

- **对象池**: `sync.Pool` 复用 `chatInput` 和 `StringBuffer` 对象，大幅减少高频消息处理时的 GC 压力。
  ```go
  var chatInputPool = sync.Pool{
      New: func() interface{} { return &chatInput{} },
  }
  ```
- **缓冲区复用**: WebSocket 读写缓冲区复用。

### 3.3 数据库访问

- **SQLC**: 使用 `sqlc` 生成类型安全的 Go 代码，避免反射开销。
- **连接池**: 配置 `pgxpool`，限制最大连接数，防止数据库过载。

---

## 4. 智能引擎优化 (AI Engine Optimization - Python)

Python 层主要处理计算密集型 (Embedding) 和 I/O 密集型 (LLM API) 任务。

### 4.1 异步任务队列 (Celery)

使用 Celery + Redis 处理耗时任务，避免阻塞 HTTP/gRPC 线程。

#### 队列划分

| 队列名 | 优先级 | 任务类型 |
| :--- | :--- | :--- |
| `high_priority` | 高 (0) | 实时性要求高的任务 (如生成 Embedding 以便尽快搜索) |
| `default` | 中 (5) | 常规任务 (批量错题分析) |
| `low_priority` | 低 (10) | 数据清理、后台统计 |

#### 配置示例
```python
task_queues={
    "high_priority": {"exchange": "sparkle", "routing_key": "high", "priority": 0},
    "default": {"exchange": "sparkle", "routing_key": "default", "priority": 5},
    # ...
}
```

### 4.2 向量检索优化 (pgvector)

- **HNSW 索引**: 为 `embedding` 字段创建 HNSW 索引，大幅提升最近邻搜索 (ANN) 速度。
- **预过滤**: 在向量搜索前先通过 SQL `WHERE` 子句过滤 `user_id` 和 `subject`，减少搜索空间。

### 4.3 缓存策略

- **Redis 缓存**: 缓存用户的 Profile、今日任务统计等高频读取数据。
- **Semantic Cache (规划中)**: 缓存 LLM 的问答结果，对相似问题直接返回缓存答案，减少 Token 消耗和延迟。

---

## 5. 监控与指标 (Monitoring)

### 5.1 移动端
- **DevTools**: 使用 Flutter DevTools 的 Performance 面板查看 Raster/UI 耗时。
- **Log**: `PerformanceService` 会打印降级/升级日志。

### 5.2 后端
- **Prometheus**: 收集 Go Gateway 的 Goroutine 数量、内存占用、请求延迟。
- **Flower**: 监控 Celery 任务的执行状态、积压情况和失败率。
- **Grafana**: 可视化展示上述所有指标。

---

## 6. 开发者建议

1.  **移动端**: 开发新 UI 组件时，务必在 `PerformanceTier.low` 下测试，确保无报错且显示正常。
2.  **后端**: 涉及外部 API 调用 (LLM) 或复杂计算的逻辑，必须放入 Celery 任务。
3.  **数据库**: 严禁在循环中执行 SQL 查询，使用批量操作或 JOIN。

---

*最后更新: 2026-01-10*
