Sparkle çŸ¥è¯†æ˜Ÿå›¾ (Knowledge Galaxy) ç³»ç»Ÿè®¾è®¡æ–‡æ¡£ v3.0
ç‰ˆæœ¬ï¼šv3.0 (å®Œæ•´ç‰ˆ)
çŠ¶æ€ï¼šReady for Implementation
æ ¸å¿ƒéšå–»ï¼šèƒ½é‡æº (Flame) â†’ é£å‡ (Ascension) â†’ æ˜Ÿè¾° (Star) â†’ æ˜Ÿåº§æ¶Œç° (Constellation Emergence)
æŠ€æœ¯æ ˆï¼šFlutter (GLSL Shader/CustomPaint) + FastAPI + PostgreSQL (pgvector) + LLM (Qwen/DeepSeek)
ç›®å½•
æ ¸å¿ƒæ¦‚å¿µä¸è®¾è®¡æ„¿æ™¯
æ•°æ®åº“è®¾è®¡
åç«¯æ¶æ„è®¾è®¡
å‰ç«¯æ¶æ„ä¸è§†è§‰å®ç°
LLM æ™ºèƒ½æ‹“å±•ç³»ç»Ÿ
ç”¨æˆ·ä½“éªŒè®¾è®¡
ç³»ç»Ÿé›†æˆä¸æ•°æ®æµ
å¼€å‘è·¯çº¿å›¾
é™„å½•
1. æ ¸å¿ƒæ¦‚å¿µä¸è®¾è®¡æ„¿æ™¯1.1 è§†è§‰éšå–»ï¼šä»¥ç«ä¸ºæ ¸ (The Core)ç”¨æˆ·ä¸ä»…æ˜¯è§‚æµ‹è€…ï¼Œæ›´æ˜¯å®‡å®™ä¸­å¿ƒçš„èƒ½é‡æºã€‚æ¯ä¸€æ¬¡å­¦ä¹ éƒ½æ˜¯å‘å®‡å®™æ³¨å…¥èƒ½é‡çš„è¿‡ç¨‹ã€‚å…ƒç´ éšå–»è§†è§‰è¡¨ç°Flame Core (èƒ½é‡æº)ç”¨æˆ·å½“ä¸‹çš„ä¸“æ³¨åŠ›ä¸ç”Ÿå‘½åŠ›å±å¹•ä¸­å¿ƒçš„ GLSL Shader æµä½“ç«ç„°The Galaxy (æ˜ŸåŸŸ)ä¸åŒç»´åº¦çš„çŸ¥è¯†ä½“ç³»ç¯ç»•ç«è‹—çš„ 6+1 ä¸ªæœ‰æœºæ˜Ÿäº‘Stars (æ˜Ÿè¾°)å…·ä½“çš„çŸ¥è¯†ç‚¹ä¸åŒäº®åº¦/å¤§å°çš„å‘å…‰èŠ‚ç‚¹Ascension (é£å‡)ä»»åŠ¡å®Œæˆçš„èƒ½é‡ä¼ é€’ç«èŠ±ç²’å­ä»ä¸­å¿ƒå–·å°„ç‚¹äº®æ˜Ÿè¾°Constellation (æ˜Ÿåº§)çŸ¥è¯†ç‚¹ä¹‹é—´çš„å…³è”æ˜Ÿæ˜Ÿä¹‹é—´çš„å‘å…‰è¿çº¿Emergence (æ¶Œç°)LLM æ‹“å±•æ–°çŸ¥è¯†æ–°æ˜Ÿä»è™šç©ºä¸­é€æ¸æ˜¾ç°1.2 6+1 æ˜ŸåŸŸåˆ†ç±»ä½“ç³»                    â˜… WISDOM (æ™ºæ…§æ˜ŸåŸŸ)
                         â†‘
        COSMOS â†â”€â”€â”€â”€ ğŸ”¥ â”€â”€â”€â”€â†’ TECH
       (ç†æ€§æ˜ŸåŸŸ)    FLAME    (é€ ç‰©æ˜ŸåŸŸ)
                    CORE
        ART â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ CIVILIZATION
     (çµæ„Ÿæ˜ŸåŸŸ)       â”‚        (æ–‡æ˜æ˜ŸåŸŸ)
                     â†“
                   LIFE (ç”Ÿæ´»æ˜ŸåŸŸ)
                     
            ï½ï½ï½ VOID (æš—ç‰©è´¨åŒº) ï½ï½ï½
            æ˜ŸåŸŸä»£ç åç§°ä¸»è‰²è°ƒè¾‰å…‰è‰²æ¶µç›–é¢†åŸŸCOSMOSç†æ€§æ˜ŸåŸŸ#00BFFF#87CEEBæ•°å­¦ã€ç‰©ç†ã€åŒ–å­¦ã€å¤©æ–‡ã€é€»è¾‘å­¦TECHé€ ç‰©æ˜ŸåŸŸ#C0C0C0#E8E8E8è®¡ç®—æœºã€å·¥ç¨‹ã€AIã€å»ºç­‘ã€åˆ¶é€ ARTçµæ„Ÿæ˜ŸåŸŸ#FF00FF#FFB6C1è®¾è®¡ã€éŸ³ä¹ã€ç»˜ç”»ã€æ–‡å­¦ã€ACGCIVILIZATIONæ–‡æ˜æ˜ŸåŸŸ#FFD700#FFF8DCå†å²ã€ç»æµã€æ”¿æ²»ã€ç¤¾ä¼šå­¦ã€æ³•å¾‹LIFEç”Ÿæ´»æ˜ŸåŸŸ#32CD32#90EE90å¥èº«ã€çƒ¹é¥ªã€åŒ»å­¦ã€å¿ƒç†ã€ç†è´¢WISDOMæ™ºæ…§æ˜ŸåŸŸ#FFFFFF#F0F8FFå“²å­¦ã€å®—æ•™ã€æ–¹æ³•è®ºã€å…ƒè®¤çŸ¥VOIDæš—ç‰©è´¨åŒº#2F4F4F#696969æœªå½’ç±»ã€è·¨é¢†åŸŸã€æ–°å…´æ¦‚å¿µ1.3 æ ¸å¿ƒè®¾è®¡åŸåˆ™
æ¸è¿›å¼æ­ç¤ºï¼šçŸ¥è¯†å®‡å®™ä»ä¸€ç‰‡æ··æ²Œå¼€å§‹ï¼Œéšå­¦ä¹ é€æ¸ç‚¹äº®
æœ‰æœºç”Ÿé•¿ï¼šæ˜Ÿå›¾ä¸æ˜¯é™æ€åœ°å›¾ï¼Œè€Œæ˜¯ä¼šéšç”¨æˆ·å­¦ä¹ è‡ªåŠ¨æ‹“å±•çš„ç”Ÿå‘½ä½“
æƒ…æ„Ÿè¿æ¥ï¼šæ¯é¢—æ˜Ÿéƒ½æ‰¿è½½ç”¨æˆ·çš„å­¦ä¹ è®°å¿†ï¼Œå½¢æˆæƒ…æ„Ÿç¾ç»Š
é—å¿˜å¯è§†åŒ–ï¼šé•¿æœŸä¸å¤ä¹ çš„çŸ¥è¯†ä¼šé€æ¸æš—æ·¡ï¼Œæé†’ç”¨æˆ·å›é¡¾
2. æ•°æ®åº“è®¾è®¡2.1 ER å…³ç³»å›¾â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     users       â”‚       â”‚    subjects     â”‚       â”‚ knowledge_nodes â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤       â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤       â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ id (PK)         â”‚       â”‚ id (PK)         â”‚â—„â”€â”€â”€â”€â”€â”€â”‚ subject_id (FK) â”‚
â”‚ username        â”‚       â”‚ name            â”‚       â”‚ id (PK)         â”‚
â”‚ created_at      â”‚       â”‚ sector_code     â”‚       â”‚ parent_id (FK)  â”‚â”€â”€â”
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚ hex_color       â”‚       â”‚ name            â”‚  â”‚
         â”‚                â”‚ position_angle  â”‚       â”‚ description     â”‚  â”‚
         â”‚                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚ importance_levelâ”‚  â”‚
         â”‚                                          â”‚ embedding       â”‚  â”‚
         â”‚                                          â”‚ is_seed         â”‚  â”‚
         â”‚                                          â”‚ source_type     â”‚  â”‚
         â–¼                                          â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                          â”‚           â”‚
â”‚user_node_status â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                                                      â”‚
â”‚ user_id (FK)    â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                           â”‚
â”‚ node_id (FK)    â”‚       â”‚  node_relations â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚ mastery_score   â”‚       â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ total_minutes   â”‚       â”‚ source_node_id  â”‚
â”‚ is_unlocked     â”‚       â”‚ target_node_id  â”‚
â”‚ is_collapsed    â”‚       â”‚ relation_type   â”‚
â”‚ last_study_at   â”‚       â”‚ strength        â”‚
â”‚ decay_paused    â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  study_records  â”‚       â”‚    tasks        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤       â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ id (PK)         â”‚       â”‚ id (PK)         â”‚
â”‚ user_id (FK)    â”‚       â”‚ user_id (FK)    â”‚
â”‚ node_id (FK)    â”‚       â”‚ node_id (FK)    â”‚â—„â”€â”€ ä»»åŠ¡å…³è”çŸ¥è¯†ç‚¹
â”‚ study_minutes   â”‚       â”‚ title           â”‚
â”‚ mastery_delta   â”‚       â”‚ status          â”‚
â”‚ created_at      â”‚       â”‚ ...             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜2.2 å®Œæ•´ SQL Schemasql-- ============================================
-- 1. å¯ç”¨å¿…è¦æ‰©å±•
-- ============================================
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS vector;

-- ============================================
-- 2. æ‰©å±• subjects è¡¨ (å­¦ç§‘ â†’ æ˜ŸåŸŸæ˜ å°„)
-- ============================================
ALTER TABLE subjects ADD COLUMN IF NOT EXISTS sector_code VARCHAR(20) DEFAULT 'VOID';
ALTER TABLE subjects ADD COLUMN IF NOT EXISTS hex_color VARCHAR(10);
ALTER TABLE subjects ADD COLUMN IF NOT EXISTS glow_color VARCHAR(10);
ALTER TABLE subjects ADD COLUMN IF NOT EXISTS position_angle FLOAT; -- æ˜ŸåŸŸåŸºå‡†è§’åº¦ (0-360)
ALTER TABLE subjects ADD COLUMN IF NOT EXISTS icon_name VARCHAR(50); -- æ˜ŸåŸŸå›¾æ ‡

-- åˆ›å»ºæ˜ŸåŸŸæšä¸¾ç±»å‹
DO $$ BEGIN
    CREATE TYPE sector_type AS ENUM ('COSMOS', 'TECH', 'ART', 'CIVILIZATION', 'LIFE', 'WISDOM', 'VOID');
EXCEPTION
    WHEN duplicate_object THEN null;
END $$;

-- ============================================
-- 3. çŸ¥è¯†èŠ‚ç‚¹è¡¨ (æ ¸å¿ƒè¡¨)
-- ============================================
CREATE TABLE IF NOT EXISTS knowledge_nodes (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    subject_id INTEGER REFERENCES subjects(id) ON DELETE SET NULL,
    parent_id UUID REFERENCES knowledge_nodes(id) ON DELETE SET NULL,
    
    -- åŸºç¡€ä¿¡æ¯
    name VARCHAR(100) NOT NULL,
    name_en VARCHAR(100), -- è‹±æ–‡åï¼Œç”¨äºå›½é™…åŒ–å’Œæœç´¢
    description TEXT,
    keywords TEXT[], -- å…³é”®è¯æ•°ç»„ï¼Œç”¨äºå¿«é€ŸåŒ¹é…
    
    -- è§†è§‰å±æ€§
    importance_level INTEGER DEFAULT 1 CHECK (importance_level BETWEEN 1 AND 5),
    -- 1: è¾¹ç¼˜æ¦‚å¿µ (å°æ˜Ÿ)
    -- 2: æ™®é€šçŸ¥è¯†ç‚¹
    -- 3: é‡è¦æ¦‚å¿µ (ä¸­æ˜Ÿ)
    -- 4: æ ¸å¿ƒçŸ¥è¯† (å¤§æ˜Ÿ)
    -- 5: é¢†åŸŸæ”¯æŸ± (å·¨æ˜Ÿ)
    
    -- èŠ‚ç‚¹æ¥æº
    is_seed BOOLEAN DEFAULT FALSE, -- æ˜¯å¦ä¸ºç§å­åº“é¢„ç½®èŠ‚ç‚¹
    source_type VARCHAR(20) DEFAULT 'seed', -- seed | user_created | llm_expanded
    source_task_id UUID, -- å¦‚æœæ˜¯ä»ä»»åŠ¡æ‹“å±•è€Œæ¥ï¼Œè®°å½•æ¥æºä»»åŠ¡
    
    -- AI å±æ€§
    embedding vector(1536), -- æ–‡æœ¬å‘é‡ (ç”¨äºè¯­ä¹‰æœç´¢å’Œè‡ªåŠ¨å½’ç±»)
    
    -- å…ƒæ•°æ®
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- å‘é‡ç´¢å¼• (HNSW ç®—æ³•ï¼Œä½™å¼¦ç›¸ä¼¼åº¦)
CREATE INDEX IF NOT EXISTS idx_nodes_embedding 
ON knowledge_nodes USING hnsw (embedding vector_cosine_ops);

-- çˆ¶èŠ‚ç‚¹ç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_nodes_parent ON knowledge_nodes(parent_id);

-- å­¦ç§‘ç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_nodes_subject ON knowledge_nodes(subject_id);

-- å…³é”®è¯ GIN ç´¢å¼• (ç”¨äºå¿«é€Ÿæœç´¢)
CREATE INDEX IF NOT EXISTS idx_nodes_keywords ON knowledge_nodes USING GIN(keywords);

-- ============================================
-- 4. çŸ¥è¯†ç‚¹å…³ç³»è¡¨ (æ˜Ÿåº§è¿çº¿)
-- ============================================
CREATE TABLE IF NOT EXISTS node_relations (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    source_node_id UUID NOT NULL REFERENCES knowledge_nodes(id) ON DELETE CASCADE,
    target_node_id UUID NOT NULL REFERENCES knowledge_nodes(id) ON DELETE CASCADE,
    
    -- å…³ç³»ç±»å‹
    relation_type VARCHAR(30) NOT NULL,
    -- prerequisite: å‰ç½®çŸ¥è¯† (A â†’ B è¡¨ç¤ºå­¦ B éœ€è¦å…ˆå­¦ A)
    -- related: ç›¸å…³è” (åŒå‘)
    -- application: åº”ç”¨å…³ç³» (ç†è®º â†’ å®è·µ)
    -- composition: ç»„æˆå…³ç³» (æ•´ä½“ â†’ éƒ¨åˆ†)
    -- evolution: æ¼”åŒ–å…³ç³» (æ—§ â†’ æ–°)
    
    -- å…³ç³»å¼ºåº¦ (å½±å“è¿çº¿è§†è§‰)
    strength FLOAT DEFAULT 0.5 CHECK (strength BETWEEN 0 AND 1),
    
    -- å…ƒæ•°æ®
    created_by VARCHAR(20) DEFAULT 'seed', -- seed | user | llm
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    -- é˜²æ­¢é‡å¤å…³ç³»
    UNIQUE(source_node_id, target_node_id, relation_type)
);

CREATE INDEX IF NOT EXISTS idx_relations_source ON node_relations(source_node_id);
CREATE INDEX IF NOT EXISTS idx_relations_target ON node_relations(target_node_id);

-- ============================================
-- 5. ç”¨æˆ·èŠ‚ç‚¹çŠ¶æ€è¡¨ (ä¸ªäººæ˜Ÿå›¾çŠ¶æ€)
-- ============================================
CREATE TABLE IF NOT EXISTS user_node_status (
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    node_id UUID NOT NULL REFERENCES knowledge_nodes(id) ON DELETE CASCADE,
    
    -- æŒæ¡åº¦ (å†³å®šæ˜Ÿæ˜Ÿäº®åº¦)
    mastery_score FLOAT DEFAULT 0 CHECK (mastery_score BETWEEN 0 AND 100),
    
    -- å­¦ä¹ ç»Ÿè®¡
    total_study_minutes INTEGER DEFAULT 0,
    study_count INTEGER DEFAULT 0, -- å­¦ä¹ æ¬¡æ•°
    
    -- çŠ¶æ€æ ‡è®°
    is_unlocked BOOLEAN DEFAULT FALSE, -- æ˜¯å¦è§£é” (é¦–æ¬¡å­¦ä¹ åè§£é”)
    is_collapsed BOOLEAN DEFAULT FALSE, -- æ˜¯å¦åç¼© (é”™è¯¯è¿‡å¤š)
    is_favorite BOOLEAN DEFAULT FALSE, -- ç”¨æˆ·æ ‡è®°ä¸ºé‡ç‚¹
    
    -- é—å¿˜æ›²çº¿ç›¸å…³
    last_study_at TIMESTAMP WITH TIME ZONE, -- æœ€åå­¦ä¹ æ—¶é—´
    decay_paused BOOLEAN DEFAULT FALSE, -- æš‚åœè¡°å‡ (ç”¨æˆ·å¯æ‰‹åŠ¨æš‚åœ)
    next_review_at TIMESTAMP WITH TIME ZONE, -- å»ºè®®ä¸‹æ¬¡å¤ä¹ æ—¶é—´
    
    -- å…ƒæ•°æ®
    first_unlock_at TIMESTAMP WITH TIME ZONE, -- é¦–æ¬¡ç‚¹äº®æ—¶é—´ (é‡Œç¨‹ç¢‘)
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    PRIMARY KEY (user_id, node_id)
);

CREATE INDEX IF NOT EXISTS idx_user_status_user ON user_node_status(user_id);
CREATE INDEX IF NOT EXISTS idx_user_status_mastery ON user_node_status(mastery_score);
CREATE INDEX IF NOT EXISTS idx_user_status_review ON user_node_status(next_review_at);

-- ============================================
-- 6. å­¦ä¹ è®°å½•è¡¨ (è¯¦ç»†å­¦ä¹ å†å²)
-- ============================================
CREATE TABLE IF NOT EXISTS study_records (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    node_id UUID NOT NULL REFERENCES knowledge_nodes(id) ON DELETE CASCADE,
    task_id UUID REFERENCES tasks(id) ON DELETE SET NULL,
    
    -- å­¦ä¹ æ•°æ®
    study_minutes INTEGER NOT NULL,
    mastery_delta FLOAT NOT NULL, -- æœ¬æ¬¡å­¦ä¹ å¢åŠ çš„æŒæ¡åº¦
    
    -- å­¦ä¹ ç±»å‹
    record_type VARCHAR(20) DEFAULT 'task_complete',
    -- task_complete: å®Œæˆä»»åŠ¡
    -- review: å¤ä¹ 
    -- exploration: ä¸»åŠ¨æ¢ç´¢
    
    -- å…ƒæ•°æ®
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_records_user ON study_records(user_id);
CREATE INDEX IF NOT EXISTS idx_records_node ON study_records(node_id);
CREATE INDEX IF NOT EXISTS idx_records_time ON study_records(created_at);

-- ============================================
-- 7. èŠ‚ç‚¹æ‹“å±•é˜Ÿåˆ—è¡¨ (LLM æ‹“å±•ä»»åŠ¡é˜Ÿåˆ—)
-- ============================================
CREATE TABLE IF NOT EXISTS node_expansion_queue (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    
    -- è§¦å‘ä¿¡æ¯
    trigger_node_id UUID NOT NULL REFERENCES knowledge_nodes(id) ON DELETE CASCADE,
    trigger_task_id UUID REFERENCES tasks(id) ON DELETE SET NULL,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    
    -- æ‹“å±•è¯·æ±‚
    expansion_context TEXT NOT NULL, -- å‘é€ç»™ LLM çš„ä¸Šä¸‹æ–‡
    
    -- çŠ¶æ€
    status VARCHAR(20) DEFAULT 'pending',
    -- pending: ç­‰å¾…å¤„ç†
    -- processing: å¤„ç†ä¸­
    -- completed: å·²å®Œæˆ
    -- failed: å¤±è´¥
    
    -- ç»“æœ
    expanded_nodes JSONB, -- LLM è¿”å›çš„æ–°èŠ‚ç‚¹
    error_message TEXT,
    
    -- å…ƒæ•°æ®
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    processed_at TIMESTAMP WITH TIME ZONE
);

CREATE INDEX IF NOT EXISTS idx_expansion_status ON node_expansion_queue(status);
CREATE INDEX IF NOT EXISTS idx_expansion_user ON node_expansion_queue(user_id);

-- ============================================
-- 8. æ›´æ–° tasks è¡¨ (æ·»åŠ çŸ¥è¯†èŠ‚ç‚¹å…³è”)
-- ============================================
ALTER TABLE tasks ADD COLUMN IF NOT EXISTS knowledge_node_id UUID REFERENCES knowledge_nodes(id);
ALTER TABLE tasks ADD COLUMN IF NOT EXISTS auto_expand_enabled BOOLEAN DEFAULT TRUE;

-- ============================================
-- 9. è§¦å‘å™¨ï¼šè‡ªåŠ¨æ›´æ–° updated_at
-- ============================================
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_knowledge_nodes_updated_at
    BEFORE UPDATE ON knowledge_nodes
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_user_node_status_updated_at
    BEFORE UPDATE ON user_node_status
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();2.3 ç§å­æ•°æ®ç¤ºä¾‹sql-- ============================================
-- ç§å­æ•°æ®ï¼šæ˜ŸåŸŸé…ç½®
-- ============================================
UPDATE subjects SET 
    sector_code = 'COSMOS', 
    hex_color = '#00BFFF', 
    glow_color = '#87CEEB',
    position_angle = 300,
    icon_name = 'atom'
WHERE name IN ('æ•°å­¦', 'ç‰©ç†', 'åŒ–å­¦');

UPDATE subjects SET 
    sector_code = 'TECH', 
    hex_color = '#C0C0C0', 
    glow_color = '#E8E8E8',
    position_angle = 60,
    icon_name = 'cpu'
WHERE name IN ('è®¡ç®—æœºç§‘å­¦', 'è½¯ä»¶å·¥ç¨‹', 'äººå·¥æ™ºèƒ½');

-- ... å…¶ä»–æ˜ŸåŸŸé…ç½®

-- ============================================
-- ç§å­æ•°æ®ï¼šæ ¸å¿ƒçŸ¥è¯†èŠ‚ç‚¹ (ä»¥è®¡ç®—æœºç§‘å­¦ä¸ºä¾‹)
-- ============================================
INSERT INTO knowledge_nodes (id, subject_id, name, name_en, description, importance_level, is_seed, keywords) VALUES
-- è®¡ç®—æœºç§‘å­¦æ ¸å¿ƒèŠ‚ç‚¹
('11111111-1111-1111-1111-111111111101', 
 (SELECT id FROM subjects WHERE name = 'è®¡ç®—æœºç§‘å­¦'),
 'ç®—æ³•ä¸æ•°æ®ç»“æ„', 'Algorithms and Data Structures',
 'è®¡ç®—æœºç§‘å­¦çš„åŸºçŸ³ï¼Œç ”ç©¶å¦‚ä½•é«˜æ•ˆåœ°ç»„ç»‡å’Œå¤„ç†æ•°æ®',
 5, TRUE, ARRAY['ç®—æ³•', 'æ•°æ®ç»“æ„', 'algorithm', 'data structure']),

('11111111-1111-1111-1111-111111111102',
 (SELECT id FROM subjects WHERE name = 'è®¡ç®—æœºç§‘å­¦'),
 'æ•°ç»„ä¸é“¾è¡¨', 'Arrays and Linked Lists',
 'æœ€åŸºç¡€çš„çº¿æ€§æ•°æ®ç»“æ„',
 3, TRUE, ARRAY['æ•°ç»„', 'é“¾è¡¨', 'array', 'linked list']),

('11111111-1111-1111-1111-111111111103',
 (SELECT id FROM subjects WHERE name = 'è®¡ç®—æœºç§‘å­¦'),
 'æ’åºç®—æ³•', 'Sorting Algorithms',
 'å°†æ•°æ®æŒ‰ç‰¹å®šé¡ºåºæ’åˆ—çš„ç®—æ³•é›†åˆ',
 4, TRUE, ARRAY['æ’åº', 'å¿«é€Ÿæ’åº', 'å½’å¹¶æ’åº', 'sorting', 'quicksort']),

('11111111-1111-1111-1111-111111111104',
 (SELECT id FROM subjects WHERE name = 'è®¡ç®—æœºç§‘å­¦'),
 'æ ‘ä¸å›¾', 'Trees and Graphs',
 'éçº¿æ€§æ•°æ®ç»“æ„ï¼Œç”¨äºè¡¨ç¤ºå±‚çº§å’Œç½‘ç»œå…³ç³»',
 4, TRUE, ARRAY['äºŒå‰æ ‘', 'å›¾', 'tree', 'graph', 'binary tree']),

('11111111-1111-1111-1111-111111111105',
 (SELECT id FROM subjects WHERE name = 'è®¡ç®—æœºç§‘å­¦'),
 'æ“ä½œç³»ç»Ÿ', 'Operating Systems',
 'ç®¡ç†è®¡ç®—æœºç¡¬ä»¶å’Œè½¯ä»¶èµ„æºçš„ç³»ç»Ÿè½¯ä»¶',
 5, TRUE, ARRAY['æ“ä½œç³»ç»Ÿ', 'OS', 'è¿›ç¨‹', 'å†…å­˜ç®¡ç†']);

-- å»ºç«‹çŸ¥è¯†ç‚¹å…³ç³»
INSERT INTO node_relations (source_node_id, target_node_id, relation_type, strength, created_by) VALUES
-- æ•°ç»„ä¸é“¾è¡¨ æ˜¯ ç®—æ³•ä¸æ•°æ®ç»“æ„ çš„ç»„æˆéƒ¨åˆ†
('11111111-1111-1111-1111-111111111102', '11111111-1111-1111-1111-111111111101', 'composition', 0.8, 'seed'),
-- æ’åºç®—æ³• ä¾èµ– æ•°ç»„ä¸é“¾è¡¨
('11111111-1111-1111-1111-111111111102', '11111111-1111-1111-1111-111111111103', 'prerequisite', 0.9, 'seed'),
-- æ ‘ä¸å›¾ æ˜¯ ç®—æ³•ä¸æ•°æ®ç»“æ„ çš„ç»„æˆéƒ¨åˆ†
('11111111-1111-1111-1111-111111111104', '11111111-1111-1111-1111-111111111101', 'composition', 0.8, 'seed'),
-- æ“ä½œç³»ç»Ÿ åº”ç”¨ ç®—æ³•ä¸æ•°æ®ç»“æ„
('11111111-1111-1111-1111-111111111101', '11111111-1111-1111-1111-111111111105', 'application', 0.7, 'seed');3. åç«¯æ¶æ„è®¾è®¡3.1 æœåŠ¡æ¶æ„å›¾â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        API Gateway                               â”‚
â”‚                    /api/v1/galaxy/*                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
           â–¼               â–¼               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  GalaxyService  â”‚ â”‚ TaskService â”‚ â”‚ ExpansionServiceâ”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚ â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚ â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
â”‚ â€¢ get_graph()   â”‚ â”‚ â€¢ complete()â”‚ â”‚ â€¢ expand_nodes()â”‚
â”‚ â€¢ spark_node()  â”‚ â”‚ â€¢ create()  â”‚ â”‚ â€¢ process_queueâ”‚
â”‚ â€¢ search()      â”‚ â”‚             â”‚ â”‚                 â”‚
â”‚ â€¢ apply_decay() â”‚ â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚                 â”‚
         â”‚                 â”‚                 â”‚
         â–¼                 â–¼                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     Event Bus (Redis)                            â”‚
â”‚  â€¢ task_completed  â€¢ node_expanded  â€¢ decay_applied              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                 â”‚                 â”‚
         â–¼                 â–¼                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    PostgreSQL + pgvector                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    LLM Service (Qwen/DeepSeek)                   â”‚
â”‚  â€¢ Embedding API  â€¢ Chat Completion (èŠ‚ç‚¹æ‹“å±•)                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜3.2 ç›®å½•ç»“æ„backend/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â””â”€â”€ v1/
â”‚   â”‚       â”œâ”€â”€ galaxy/
â”‚   â”‚       â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚       â”‚   â”œâ”€â”€ router.py      # API è·¯ç”±
â”‚   â”‚       â”‚   â”œâ”€â”€ schemas.py     # Pydantic æ¨¡å‹
â”‚   â”‚       â”‚   â””â”€â”€ dependencies.py
â”‚   â”‚       â””â”€â”€ ...
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”œâ”€â”€ galaxy_service.py      # æ˜Ÿå›¾æ ¸å¿ƒæœåŠ¡
â”‚   â”‚   â”œâ”€â”€ expansion_service.py   # LLM æ‹“å±•æœåŠ¡
â”‚   â”‚   â”œâ”€â”€ decay_service.py       # é—å¿˜è¡°å‡æœåŠ¡
â”‚   â”‚   â””â”€â”€ embedding_service.py   # å‘é‡åµŒå…¥æœåŠ¡
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”œâ”€â”€ knowledge_node.py
â”‚   â”‚   â”œâ”€â”€ node_relation.py
â”‚   â”‚   â”œâ”€â”€ user_node_status.py
â”‚   â”‚   â””â”€â”€ study_record.py
â”‚   â”œâ”€â”€ jobs/
â”‚   â”‚   â”œâ”€â”€ decay_job.py           # æ¯æ—¥è¡°å‡ä»»åŠ¡
â”‚   â”‚   â””â”€â”€ expansion_worker.py    # æ‹“å±•é˜Ÿåˆ—æ¶ˆè´¹è€…
â”‚   â””â”€â”€ core/
â”‚       â””â”€â”€ llm_client.py          # LLM å®¢æˆ·ç«¯å°è£…
â””â”€â”€ seeds/
    â”œâ”€â”€ sectors.json               # æ˜ŸåŸŸé…ç½®
    â””â”€â”€ nodes/
        â”œâ”€â”€ cosmos.json            # ç†æ€§æ˜ŸåŸŸç§å­
        â”œâ”€â”€ tech.json              # é€ ç‰©æ˜ŸåŸŸç§å­
        â””â”€â”€ ...3.3 æ ¸å¿ƒæœåŠ¡å®ç°3.3.1 GalaxyService (æ˜Ÿå›¾æ ¸å¿ƒæœåŠ¡)python# backend/app/services/galaxy_service.py

from uuid import UUID
from typing import Optional, List
from datetime import datetime, timedelta
from sqlalchemy import select, and_
from sqlalchemy.ext.asyncio import AsyncSession

from app.models import KnowledgeNode, UserNodeStatus, NodeRelation, StudyRecord
from app.services.embedding_service import EmbeddingService
from app.services.expansion_service import ExpansionService
from app.schemas.galaxy import (
    GalaxyGraphResponse, NodeWithStatus, SparkEvent, 
    SparkResult, SearchResult
)


class GalaxyService:
    """çŸ¥è¯†æ˜Ÿå›¾æ ¸å¿ƒæœåŠ¡"""
    
    # æŒæ¡åº¦è®¡ç®—å¸¸é‡
    BASE_MASTERY_POINTS = 5.0
    MAX_MASTERY = 100.0
    
    # é—å¿˜æ›²çº¿å¸¸é‡ (è‰¾å®¾æµ©æ–¯)
    MEMORY_HALF_LIFE_DAYS = 7.0  # è®°å¿†åŠè¡°æœŸ
    DECAY_THRESHOLD = 10.0       # ä½äºæ­¤å€¼æ˜Ÿæ˜Ÿå˜æš—
    
    def __init__(
        self, 
        db: AsyncSession,
        embedding_service: EmbeddingService,
        expansion_service: ExpansionService
    ):
        self.db = db
        self.embedding_service = embedding_service
        self.expansion_service = expansion_service

    # ==========================================
    # 1. è·å–æ˜Ÿå›¾æ•°æ®
    # ==========================================
    async def get_galaxy_graph(
        self, 
        user_id: UUID,
        sector_code: Optional[str] = None,
        include_locked: bool = True
    ) -> GalaxyGraphResponse:
        """
        è·å–ç”¨æˆ·çš„çŸ¥è¯†æ˜Ÿå›¾æ•°æ®
        
        Args:
            user_id: ç”¨æˆ· ID
            sector_code: å¯é€‰ï¼Œç­›é€‰ç‰¹å®šæ˜ŸåŸŸ
            include_locked: æ˜¯å¦åŒ…å«æœªè§£é”çš„èŠ‚ç‚¹
        
        Returns:
            GalaxyGraphResponse: åŒ…å«èŠ‚ç‚¹ã€å…³ç³»ã€ç”¨æˆ·çŠ¶æ€çš„å®Œæ•´æ˜Ÿå›¾æ•°æ®
        """
        # 1. æŸ¥è¯¢çŸ¥è¯†èŠ‚ç‚¹ (å¸¦ç”¨æˆ·çŠ¶æ€)
        query = (
            select(KnowledgeNode, UserNodeStatus)
            .outerjoin(
                UserNodeStatus,
                and_(
                    UserNodeStatus.node_id == KnowledgeNode.id,
                    UserNodeStatus.user_id == user_id
                )
            )
        )
        
        if sector_code:
            query = query.join(Subject).where(Subject.sector_code == sector_code)
        
        result = await self.db.execute(query)
        nodes_with_status = result.all()
        
        # 2. è¿‡æ»¤æœªè§£é”èŠ‚ç‚¹ (å¦‚æœéœ€è¦)
        if not include_locked:
            nodes_with_status = [
                (node, status) for node, status in nodes_with_status
                if status and status.is_unlocked
            ]
        
        # 3. æŸ¥è¯¢èŠ‚ç‚¹å…³ç³»
        node_ids = [node.id for node, _ in nodes_with_status]
        relations_query = select(NodeRelation).where(
            NodeRelation.source_node_id.in_(node_ids),
            NodeRelation.target_node_id.in_(node_ids)
        )
        relations_result = await self.db.execute(relations_query)
        relations = relations_result.scalars().all()
        
        # 4. ç»„è£…å“åº”
        return GalaxyGraphResponse(
            nodes=[
                NodeWithStatus.from_orm(node, status)
                for node, status in nodes_with_status
            ],
            relations=[rel.to_dict() for rel in relations],
            user_stats=await self._calculate_user_stats(user_id)
        )

    # ==========================================
    # 2. ç‚¹äº®çŸ¥è¯†ç‚¹ (Spark)
    # ==========================================
    async def spark_node(
        self,
        user_id: UUID,
        node_id: UUID,
        study_minutes: int,
        task_id: Optional[UUID] = None,
        trigger_expansion: bool = True
    ) -> SparkResult:
        """
        ç‚¹äº®/å¢å¼ºçŸ¥è¯†ç‚¹ (ä»»åŠ¡å®Œæˆæ—¶è°ƒç”¨)
        
        Args:
            user_id: ç”¨æˆ· ID
            node_id: çŸ¥è¯†èŠ‚ç‚¹ ID
            study_minutes: å­¦ä¹ æ—¶é•¿ (åˆ†é’Ÿ)
            task_id: å…³è”çš„ä»»åŠ¡ ID
            trigger_expansion: æ˜¯å¦è§¦å‘ LLM æ‹“å±•
        
        Returns:
            SparkResult: åŒ…å«åŠ¨ç”»äº‹ä»¶å’Œæ‹“å±•çŠ¶æ€
        """
        # 1. è·å–æˆ–åˆ›å»ºç”¨æˆ·èŠ‚ç‚¹çŠ¶æ€
        status = await self._get_or_create_status(user_id, node_id)
        
        # 2. è®¡ç®—æŒæ¡åº¦å¢é‡
        node = await self.db.get(KnowledgeNode, node_id)
        mastery_delta = self._calculate_mastery_delta(study_minutes, node.importance_level)
        
        # 3. è®°å½•æ—§çŠ¶æ€ (ç”¨äºåˆ¤æ–­æ˜¯å¦é¦–æ¬¡ç‚¹äº®/å‡çº§)
        old_mastery = status.mastery_score
        is_first_unlock = not status.is_unlocked
        
        # 4. æ›´æ–°çŠ¶æ€
        status.mastery_score = min(status.mastery_score + mastery_delta, self.MAX_MASTERY)
        status.total_study_minutes += study_minutes
        status.study_count += 1
        status.last_study_at = datetime.utcnow()
        status.is_unlocked = True
        
        if is_first_unlock:
            status.first_unlock_at = datetime.utcnow()
        
        # è®¡ç®—ä¸‹æ¬¡å¤ä¹ æ—¶é—´
        status.next_review_at = self._calculate_next_review(status.mastery_score)
        
        # 5. è®°å½•å­¦ä¹ å†å²
        record = StudyRecord(
            user_id=user_id,
            node_id=node_id,
            task_id=task_id,
            study_minutes=study_minutes,
            mastery_delta=mastery_delta,
            record_type='task_complete'
        )
        self.db.add(record)
        
        await self.db.commit()
        
        # 6. ç”ŸæˆåŠ¨ç”»äº‹ä»¶
        spark_event = SparkEvent(
            node_id=node_id,
            node_name=node.name,
            sector_code=node.subject.sector_code if node.subject else 'VOID',
            old_mastery=old_mastery,
            new_mastery=status.mastery_score,
            is_first_unlock=is_first_unlock,
            is_level_up=self._check_level_up(old_mastery, status.mastery_score)
        )
        
        # 7. è§¦å‘ LLM æ‹“å±• (å¼‚æ­¥)
        expansion_queued = False
        if trigger_expansion and status.study_count >= 2:  # å­¦ä¹  2 æ¬¡åå¼€å§‹æ‹“å±•
            await self.expansion_service.queue_expansion(
                trigger_node_id=node_id,
                trigger_task_id=task_id,
                user_id=user_id
            )
            expansion_queued = True
        
        return SparkResult(
            spark_event=spark_event,
            expansion_queued=expansion_queued,
            updated_status=status
        )

    # ==========================================
    # 3. è¯­ä¹‰æœç´¢
    # ==========================================
    async def semantic_search(
        self,
        user_id: UUID,
        query: str,
        limit: int = 10,
        threshold: float = 0.3
    ) -> List[SearchResult]:
        """
        ä½¿ç”¨å‘é‡ç›¸ä¼¼åº¦æœç´¢çŸ¥è¯†ç‚¹
        
        Args:
            user_id: ç”¨æˆ· ID
            query: æœç´¢æŸ¥è¯¢
            limit: è¿”å›æ•°é‡é™åˆ¶
            threshold: ç›¸ä¼¼åº¦é˜ˆå€¼ (è¶Šå°è¶Šä¸¥æ ¼)
        
        Returns:
            List[SearchResult]: åŒ¹é…çš„çŸ¥è¯†ç‚¹åˆ—è¡¨
        """
        # 1. è·å–æŸ¥è¯¢å‘é‡
        query_embedding = await self.embedding_service.get_embedding(query)
        
        # 2. å‘é‡æœç´¢
        query = (
            select(
                KnowledgeNode,
                KnowledgeNode.embedding.cosine_distance(query_embedding).label('distance')
            )
            .where(KnowledgeNode.embedding.isnot(None))
            .order_by('distance')
            .limit(limit)
        )
        
        result = await self.db.execute(query)
        matches = result.all()
        
        # 3. è¿‡æ»¤å¹¶æ ¼å¼åŒ–ç»“æœ
        search_results = []
        for node, distance in matches:
            if distance <= threshold:
                search_results.append(SearchResult(
                    node=node,
                    similarity=1 - distance,  # è½¬æ¢ä¸ºç›¸ä¼¼åº¦
                    user_status=await self._get_user_status(user_id, node.id)
                ))
        
        return search_results

    # ==========================================
    # 4. ä»»åŠ¡è‡ªåŠ¨å½’ç±»
    # ==========================================
    async def auto_classify_task(
        self, 
        task_title: str, 
        task_description: Optional[str] = None
    ) -> Optional[UUID]:
        """
        æ ¹æ®ä»»åŠ¡æ ‡é¢˜è‡ªåŠ¨åŒ¹é…çŸ¥è¯†ç‚¹
        
        Args:
            task_title: ä»»åŠ¡æ ‡é¢˜
            task_description: ä»»åŠ¡æè¿° (å¯é€‰)
        
        Returns:
            Optional[UUID]: åŒ¹é…çš„çŸ¥è¯†èŠ‚ç‚¹ IDï¼Œæ— åŒ¹é…è¿”å› None
        """
        # 1. æ„å»ºæœç´¢æ–‡æœ¬
        search_text = task_title
        if task_description:
            search_text += f" {task_description}"
        
        # 2. å°è¯•å‘é‡åŒ¹é…
        try:
            embedding = await self.embedding_service.get_embedding(search_text)
            
            query = (
                select(KnowledgeNode.id)
                .where(KnowledgeNode.embedding.isnot(None))
                .order_by(KnowledgeNode.embedding.cosine_distance(embedding))
                .limit(1)
            )
            
            result = await self.db.execute(query)
            node_id = result.scalar_one_or_none()
            
            return node_id
            
        except Exception as e:
            # é™çº§ï¼šå…³é”®è¯åŒ¹é…
            return await self._fallback_keyword_match(search_text)

    async def _fallback_keyword_match(self, text: str) -> Optional[UUID]:
        """å…³é”®è¯åŒ¹é…é™çº§ç­–ç•¥"""
        query = (
            select(KnowledgeNode.id)
            .where(KnowledgeNode.keywords.overlap(text.split()))
            .limit(1)
        )
        result = await self.db.execute(query)
        return result.scalar_one_or_none()

    # ==========================================
    # 5. ç§æœ‰è¾…åŠ©æ–¹æ³•
    # ==========================================
    def _calculate_mastery_delta(self, study_minutes: int, importance_level: int) -> float:
        """è®¡ç®—æŒæ¡åº¦å¢é‡"""
        # åŸºç¡€åˆ† * æ—¶é—´ç³»æ•° * éš¾åº¦ç³»æ•°
        time_factor = min(study_minutes / 30.0, 2.0)  # 30 åˆ†é’Ÿä¸ºæ ‡å‡†ï¼Œæœ€å¤š 2 å€
        difficulty_factor = 1 + (importance_level - 1) * 0.1  # é‡è¦æ€§è¶Šé«˜ï¼Œå¢é•¿è¶Šå¤š
        
        return self.BASE_MASTERY_POINTS * time_factor * difficulty_factor

    def _check_level_up(self, old_mastery: float, new_mastery: float) -> bool:
        """æ£€æŸ¥æ˜¯å¦å‡çº§ (è·¨è¶Šç­‰çº§é˜ˆå€¼)"""
        thresholds = [30, 60, 80, 95]  # ç­‰çº§é˜ˆå€¼
        for threshold in thresholds:
            if old_mastery < threshold <= new_mastery:
                return True
        return False

    def _calculate_next_review(self, mastery_score: float) -> datetime:
        """æ ¹æ®æŒæ¡åº¦è®¡ç®—ä¸‹æ¬¡å¤ä¹ æ—¶é—´"""
        # æŒæ¡åº¦è¶Šé«˜ï¼Œå¤ä¹ é—´éš”è¶Šé•¿
        if mastery_score >= 80:
            days = 14
        elif mastery_score >= 60:
            days = 7
        elif mastery_score >= 30:
            days = 3
        else:
            days = 1
        
        return datetime.utcnow() + timedelta(days=days)

    async def _get_or_create_status(self, user_id: UUID, node_id: UUID) -> UserNodeStatus:
        """è·å–æˆ–åˆ›å»ºç”¨æˆ·èŠ‚ç‚¹çŠ¶æ€"""
        query = select(UserNodeStatus).where(
            UserNodeStatus.user_id == user_id,
            UserNodeStatus.node_id == node_id
        )
        result = await self.db.execute(query)
        status = result.scalar_one_or_none()
        
        if not status:
            status = UserNodeStatus(user_id=user_id, node_id=node_id)
            self.db.add(status)
        
        return status

    async def _calculate_user_stats(self, user_id: UUID) -> dict:
        """è®¡ç®—ç”¨æˆ·ç»Ÿè®¡æ•°æ®"""
        # ç»Ÿè®¡å„çŠ¶æ€èŠ‚ç‚¹æ•°é‡
        query = (
            select(
                func.count().filter(UserNodeStatus.is_unlocked == True).label('unlocked_count'),
                func.count().filter(UserNodeStatus.mastery_score >= 80).label('mastered_count'),
                func.sum(UserNodeStatus.total_study_minutes).label('total_minutes')
            )
            .where(UserNodeStatus.user_id == user_id)
        )
        result = await self.db.execute(query)
        row = result.one()
        
        return {
            'unlocked_count': row.unlocked_count or 0,
            'mastered_count': row.mastered_count or 0,
            'total_study_minutes': row.total_minutes or 0
        }3.3.2 DecayService (é—å¿˜è¡°å‡æœåŠ¡)python# backend/app/services/decay_service.py

import math
from datetime import datetime, timedelta
from typing import List
from sqlalchemy import select, and_
from sqlalchemy.ext.asyncio import AsyncSession

from app.models import UserNodeStatus, KnowledgeNode


class DecayService:
    """
    é—å¿˜æ›²çº¿è¡°å‡æœåŠ¡
    
    åŸºäºè‰¾å®¾æµ©æ–¯é—å¿˜æ›²çº¿ï¼š
    Retention = e^(-t/S)
    å…¶ä¸­ t ä¸ºæ—¶é—´é—´éš”ï¼ŒS ä¸ºè®°å¿†ç¨³å®šæ€§ (ä¸æŒæ¡åº¦ç›¸å…³)
    """
    
    # è¡°å‡å‚æ•°
    BASE_HALF_LIFE_DAYS = 7.0    # åŸºç¡€åŠè¡°æœŸ (å¤©)
    MIN_MASTERY = 5.0            # æœ€ä½æŒæ¡åº¦ (ä¸ä¼šé™åˆ° 0)
    DECAY_CHECK_INTERVAL = 1     # æ£€æŸ¥é—´éš” (å¤©)
    
    # æŒæ¡åº¦é˜ˆå€¼
    THRESHOLD_DIM = 20.0         # ä½äºæ­¤å€¼æ˜Ÿæ˜Ÿå˜æš—
    THRESHOLD_COLLAPSE = 10.0    # ä½äºæ­¤å€¼å¯èƒ½åç¼©
    
    def __init__(self, db: AsyncSession):
        self.db = db

    async def apply_daily_decay(self) -> dict:
        """
        æ¯æ—¥é—å¿˜è¡°å‡ä»»åŠ¡
        
        Returns:
            dict: è¡°å‡ç»Ÿè®¡ {processed: int, dimmed: int, collapsed: int}
        """
        stats = {'processed': 0, 'dimmed': 0, 'collapsed': 0}
        now = datetime.utcnow()
        
        # 1. æŸ¥è¯¢éœ€è¦è¡°å‡çš„èŠ‚ç‚¹çŠ¶æ€
        # æ¡ä»¶ï¼šå·²è§£é” + æœªæš‚åœè¡°å‡ + ä¸Šæ¬¡å­¦ä¹ è¶…è¿‡ 1 å¤©
        query = select(UserNodeStatus).where(
            and_(
                UserNodeStatus.is_unlocked == True,
                UserNodeStatus.decay_paused == False,
                UserNodeStatus.last_study_at < now - timedelta(days=self.DECAY_CHECK_INTERVAL),
                UserNodeStatus.mastery_score > self.MIN_MASTERY
            )
        )
        
        result = await self.db.execute(query)
        statuses = result.scalars().all()
        
        # 2. é€ä¸ªåº”ç”¨è¡°å‡
        for status in statuses:
            old_mastery = status.mastery_score
            
            # è®¡ç®—è¡°å‡
            days_elapsed = (now - status.last_study_at).days
            new_mastery = self._calculate_decay(
                current_mastery=status.mastery_score,
                days_elapsed=days_elapsed
            )
            
            # æ›´æ–°çŠ¶æ€
            status.mastery_score = new_mastery
            stats['processed'] += 1
            
            # æ£€æŸ¥çŠ¶æ€å˜åŒ–
            if old_mastery >= self.THRESHOLD_DIM > new_mastery:
                stats['dimmed'] += 1
            
            if new_mastery < self.THRESHOLD_COLLAPSE and not status.is_collapsed:
                # æ ‡è®°åç¼©é£é™© (ä½†ä¸è‡ªåŠ¨åç¼©)
                stats['collapsed'] += 1
        
        await self.db.commit()
        
        return stats

    def _calculate_decay(self, current_mastery: float, days_elapsed: int) -> float:
        """
        è®¡ç®—è¡°å‡åçš„æŒæ¡åº¦
        
        ä½¿ç”¨ä¿®æ”¹çš„è‰¾å®¾æµ©æ–¯å…¬å¼ï¼š
        - é«˜æŒæ¡åº¦èŠ‚ç‚¹è¡°å‡æ›´æ…¢ (æ›´ç¨³å®šçš„è®°å¿†)
        - æœ€ä½ä¸ä¼šé™åˆ° MIN_MASTERY
        """
        # åŠ¨æ€åŠè¡°æœŸï¼šæŒæ¡åº¦è¶Šé«˜ï¼ŒåŠè¡°æœŸè¶Šé•¿
        stability_factor = 1 + (current_mastery / 100) * 2  # 1-3 å€
        effective_half_life = self.BASE_HALF_LIFE_DAYS * stability_factor
        
        # æŒ‡æ•°è¡°å‡
        decay_rate = math.log(2) / effective_half_life
        retention = math.exp(-decay_rate * days_elapsed)
        
        # è®¡ç®—æ–°æŒæ¡åº¦
        decayed_mastery = current_mastery * retention
        
        return max(decayed_mastery, self.MIN_MASTERY)

    async def get_review_suggestions(self, user_id: UUID, limit: int = 5) -> List[dict]:
        """
        è·å–å¤ä¹ å»ºè®®
        
        Returns:
            List[dict]: å»ºè®®å¤ä¹ çš„çŸ¥è¯†ç‚¹åˆ—è¡¨
        """
        now = datetime.utcnow()
        
        query = (
            select(UserNodeStatus, KnowledgeNode)
            .join(KnowledgeNode)
            .where(
                and_(
                    UserNodeStatus.user_id == user_id,
                    UserNodeStatus.is_unlocked == True,
                    UserNodeStatus.next_review_at <= now
                )
            )
            .order_by(UserNodeStatus.mastery_score.asc())  # ä¼˜å…ˆå¤ä¹ ä½æŒæ¡åº¦
            .limit(limit)
        )
        
        result = await self.db.execute(query)
        rows = result.all()
        
        return [
            {
                'node_id': node.id,
                'node_name': node.name,
                'sector_code': node.subject.sector_code if node.subject else 'VOID',
                'current_mastery': status.mastery_score,
                'days_since_study': (now - status.last_study_at).days,
                'urgency': 'high' if status.mastery_score < self.THRESHOLD_DIM else 'normal'
            }
            for status, node in rows
        ]

    async def pause_decay(self, user_id: UUID, node_id: UUID, pause: bool = True):
        """æš‚åœ/æ¢å¤ç‰¹å®šèŠ‚ç‚¹çš„è¡°å‡"""
        query = select(UserNodeStatus).where(
            UserNodeStatus.user_id == user_id,
            UserNodeStatus.node_id == node_id
        )
        result = await self.db.execute(query)
        status = result.scalar_one_or_none()
        
        if status:
            status.decay_paused = pause
            await self.db.commit()3.3.3 EmbeddingService (å‘é‡åµŒå…¥æœåŠ¡)python# backend/app/services/embedding_service.py

from typing import List, Optional
import httpx
from tenacity import retry, stop_after_attempt, wait_exponential

from app.core.config import settings


class EmbeddingService:
    """
    æ–‡æœ¬å‘é‡åµŒå…¥æœåŠ¡
    
    æ”¯æŒå¤šä¸ª LLM æä¾›å•†ï¼š
    - Qwen (é€šä¹‰åƒé—®)
    - DeepSeek
    - OpenAI (å¤‡ç”¨)
    """
    
    EMBEDDING_DIM = 1536
    
    def __init__(self):
        self.provider = settings.LLM_PROVIDER  # 'qwen' | 'deepseek' | 'openai'
        self.api_key = settings.LLM_API_KEY
        self.base_url = settings.LLM_BASE_URL
        
    @retry(
        stop=stop_after_attempt(3),
        wait=wait_exponential(multiplier=1, min=2, max=10)
    )
    async def get_embedding(self, text: str) -> List[float]:
        """
        è·å–æ–‡æœ¬çš„å‘é‡è¡¨ç¤º
        
        Args:
            text: è¾“å…¥æ–‡æœ¬
        
        Returns:
            List[float]: 1536 ç»´å‘é‡
        """
        async with httpx.AsyncClient(timeout=30.0) as client:
            if self.provider == 'qwen':
                return await self._qwen_embedding(client, text)
            elif self.provider == 'deepseek':
                return await self._deepseek_embedding(client, text)
            else:
                return await self._openai_embedding(client, text)

    async def _qwen_embedding(self, client: httpx.AsyncClient, text: str) -> List[float]:
        """é€šä¹‰åƒé—® Embedding API"""
        response = await client.post(
            f"{self.base_url}/embeddings",
            headers={"Authorization": f"Bearer {self.api_key}"},
            json={
                "model": "text-embedding-v2",
                "input": text
            }
        )
        response.raise_for_status()
        data = response.json()
        return data["data"][0]["embedding"]

    async def _deepseek_embedding(self, client: httpx.AsyncClient, text: str) -> List[float]:
        """DeepSeek Embedding API"""
        response = await client.post(
            f"{self.base_url}/embeddings",
            headers={"Authorization": f"Bearer {self.api_key}"},
            json={
                "model": "deepseek-embedding",
                "input": text
            }
        )
        response.raise_for_status()
        data = response.json()
        return data["data"][0]["embedding"]

    async def batch_embeddings(self, texts: List[str]) -> List[List[float]]:
        """æ‰¹é‡è·å–å‘é‡"""
        # å¤§å¤šæ•° API æ”¯æŒæ‰¹é‡è¯·æ±‚
        async with httpx.AsyncClient(timeout=60.0) as client:
            response = await client.post(
                f"{self.base_url}/embeddings",
                headers={"Authorization": f"Bearer {self.api_key}"},
                json={
                    "model": "text-embedding-v2",
                    "input": texts
                }
            )
            response.raise_for_status()
            data = response.json()
            
            # æŒ‰é¡ºåºè¿”å›
            embeddings = [None] * len(texts)
            for item in data["data"]:
                embeddings[item["index"]] = item["embedding"]
            
            return embeddings3.4 API è·¯ç”±å®šä¹‰python# backend/app/api/v1/galaxy/router.py

from fastapi import APIRouter, Depends, Query, HTTPException
from uuid import UUID
from typing import Optional

from app.api.deps import get_current_user, get_galaxy_service
from app.services.galaxy_service import GalaxyService
from app.schemas.galaxy import (
    GalaxyGraphResponse, SparkRequest, SparkResult,
    SearchRequest, SearchResponse, NodeDetailResponse,
    ReviewSuggestionsResponse
)

router = APIRouter(prefix="/galaxy", tags=["Knowledge Galaxy"])


@router.get("/graph", response_model=GalaxyGraphResponse)
async def get_galaxy_graph(
    sector_code: Optional[str] = Query(None, description="ç­›é€‰ç‰¹å®šæ˜ŸåŸŸ"),
    include_locked: bool = Query(True, description="æ˜¯å¦åŒ…å«æœªè§£é”èŠ‚ç‚¹"),
    current_user = Depends(get_current_user),
    galaxy_service: GalaxyService = Depends(get_galaxy_service)
):
    """
    è·å–ç”¨æˆ·çš„çŸ¥è¯†æ˜Ÿå›¾æ•°æ®
    
    è¿”å›æ‰€æœ‰çŸ¥è¯†èŠ‚ç‚¹ã€å…³ç³»å’Œç”¨æˆ·çŠ¶æ€ï¼Œç”¨äºå‰ç«¯æ¸²æŸ“å®Œæ•´æ˜Ÿå›¾ã€‚
    """
    return await galaxy_service.get_galaxy_graph(
        user_id=current_user.id,
        sector_code=sector_code,
        include_locked=include_locked
    )


@router.post("/node/{node_id}/spark", response_model=SparkResult)
async def spark_node(
    node_id: UUID,
    request: SparkRequest,
    current_user = Depends(get_current_user),
    galaxy_service: GalaxyService = Depends(get_galaxy_service)
):
    """
    ç‚¹äº®/å¢å¼ºçŸ¥è¯†ç‚¹
    
    é€šå¸¸åœ¨ä»»åŠ¡å®Œæˆæ—¶ç”± TaskService è°ƒç”¨ï¼Œä¹Ÿå¯æ‰‹åŠ¨è§¦å‘å¤ä¹ ã€‚
    è¿”å›åŠ¨ç”»äº‹ä»¶æ•°æ®ä¾›å‰ç«¯æ’­æ”¾é£å‡åŠ¨ç”»ã€‚
    """
    return await galaxy_service.spark_node(
        user_id=current_user.id,
        node_id=node_id,
        study_minutes=request.study_minutes,
        task_id=request.task_id,
        trigger_expansion=request.trigger_expansion
    )


@router.get("/node/{node_id}", response_model=NodeDetailResponse)
async def get_node_detail(
    node_id: UUID,
    current_user = Depends(get_current_user),
    galaxy_service: GalaxyService = Depends(get_galaxy_service)
):
    """
    è·å–çŸ¥è¯†ç‚¹è¯¦æƒ…
    
    åŒ…æ‹¬ï¼šåŸºç¡€ä¿¡æ¯ã€å…³è”èŠ‚ç‚¹ã€ç”¨æˆ·å­¦ä¹ å†å²ã€æ¨èèµ„æº
    """
    return await galaxy_service.get_node_detail(
        user_id=current_user.id,
        node_id=node_id
    )


@router.post("/search", response_model=SearchResponse)
async def search_nodes(
    request: SearchRequest,
    current_user = Depends(get_current_user),
    galaxy_service: GalaxyService = Depends(get_galaxy_service)
):
    """
    è¯­ä¹‰æœç´¢çŸ¥è¯†ç‚¹
    
    ä½¿ç”¨å‘é‡ç›¸ä¼¼åº¦æœç´¢ï¼Œæ”¯æŒè‡ªç„¶è¯­è¨€æŸ¥è¯¢ã€‚
    """
    results = await galaxy_service.semantic_search(
        user_id=current_user.id,
        query=request.query,
        limit=request.limit,
        threshold=request.threshold
    )
    return SearchResponse(results=results, query=request.query)


@router.get("/review/suggestions", response_model=ReviewSuggestionsResponse)
async def get_review_suggestions(
    limit: int = Query(5, ge=1, le=20),
    current_user = Depends(get_current_user),
    galaxy_service: GalaxyService = Depends(get_galaxy_service)
):
    """
    è·å–å¤ä¹ å»ºè®®
    
    åŸºäºé—å¿˜æ›²çº¿ï¼Œè¿”å›æœ€éœ€è¦å¤ä¹ çš„çŸ¥è¯†ç‚¹ã€‚
    """
    suggestions = await galaxy_service.decay_service.get_review_suggestions(
        user_id=current_user.id,
        limit=limit
    )
    return ReviewSuggestionsResponse(suggestions=suggestions)


@router.post("/node/{node_id}/pause-decay")
async def toggle_decay_pause(
    node_id: UUID,
    pause: bool = Query(True),
    current_user = Depends(get_current_user),
    galaxy_service: GalaxyService = Depends(get_galaxy_service)
):
    """
    æš‚åœ/æ¢å¤çŸ¥è¯†ç‚¹çš„é—å¿˜è¡°å‡
    
    ç”¨æˆ·å¯ä»¥æ‰‹åŠ¨æš‚åœæŸäº›é‡è¦çŸ¥è¯†ç‚¹çš„è¡°å‡ã€‚
    """
    await galaxy_service.decay_service.pause_decay(
        user_id=current_user.id,
        node_id=node_id,
        pause=pause
    )
    return {"success": True, "decay_paused": pause}


@router.get("/stats")
async def get_galaxy_stats(
    current_user = Depends(get_current_user),
    galaxy_service: GalaxyService = Depends(get_galaxy_service)
):
    """
    è·å–æ˜Ÿå›¾ç»Ÿè®¡æ•°æ®
    
    è¿”å›ï¼šè§£é”èŠ‚ç‚¹æ•°ã€æŒæ¡èŠ‚ç‚¹æ•°ã€å„æ˜ŸåŸŸåˆ†å¸ƒç­‰
    """
    return await galaxy_service.get_user_stats(current_user.id)3.5 Pydantic Schemaspython# backend/app/schemas/galaxy.py

from pydantic import BaseModel, Field
from typing import Optional, List
from uuid import UUID
from datetime import datetime
from enum import Enum


class SectorCode(str, Enum):
    COSMOS = "COSMOS"
    TECH = "TECH"
    ART = "ART"
    CIVILIZATION = "CIVILIZATION"
    LIFE = "LIFE"
    WISDOM = "WISDOM"
    VOID = "VOID"


class NodeStatus(str, Enum):
    LOCKED = "locked"       # æœªè§£é”
    UNLIT = "unlit"         # å·²è§£é”ä½†æœªå­¦ä¹ 
    GLIMMER = "glimmer"     # å¾®å…‰ (0-30)
    SHINING = "shining"     # é—ªè€€ (30-80)
    BRILLIANT = "brilliant" # ç’€ç’¨ (80-95)
    MASTERED = "mastered"   # ç²¾é€š (95-100)
    COLLAPSED = "collapsed" # åç¼©


# ==========================================
# è¯·æ±‚æ¨¡å‹
# ==========================================
class SparkRequest(BaseModel):
    study_minutes: int = Field(..., ge=1, le=480, description="å­¦ä¹ æ—¶é•¿(åˆ†é’Ÿ)")
    task_id: Optional[UUID] = Field(None, description="å…³è”çš„ä»»åŠ¡ID")
    trigger_expansion: bool = Field(True, description="æ˜¯å¦è§¦å‘çŸ¥è¯†æ‹“å±•")


class SearchRequest(BaseModel):
    query: str = Field(..., min_length=1, max_length=200)
    limit: int = Field(10, ge=1, le=50)
    threshold: float = Field(0.3, ge=0.0, le=1.0)


# ==========================================
# å“åº”æ¨¡å‹
# ==========================================
class NodeBase(BaseModel):
    id: UUID
    name: str
    name_en: Optional[str]
    description: Optional[str]
    importance_level: int
    sector_code: SectorCode
    is_seed: bool
    
    class Config:
        from_attributes = True


class UserStatusInfo(BaseModel):
    mastery_score: float
    total_study_minutes: int
    study_count: int
    is_unlocked: bool
    is_collapsed: bool
    is_favorite: bool
    last_study_at: Optional[datetime]
    next_review_at: Optional[datetime]
    decay_paused: bool
    
    # è®¡ç®—å±æ€§
    status: NodeStatus
    brightness: float  # 0-1ï¼Œç”¨äºå‰ç«¯æ¸²æŸ“


class NodeWithStatus(NodeBase):
    """èŠ‚ç‚¹ + ç”¨æˆ·çŠ¶æ€"""
    user_status: Optional[UserStatusInfo]
    
    # å¸ƒå±€ä¿¡æ¯
    position_angle: float  # åœ¨æ˜ŸåŸŸä¸­çš„è§’åº¦
    position_radius: float # è·ç¦»ä¸­å¿ƒçš„åŠå¾„
    
    @classmethod
    def from_orm(cls, node, status):
        user_status = None
        if status:
            # è®¡ç®—è§†è§‰çŠ¶æ€
            visual_status = cls._calculate_status(status)
            brightness = cls._calculate_brightness(status)
            
            user_status = UserStatusInfo(
                mastery_score=status.mastery_score,
                total_study_minutes=status.total_study_minutes,
                study_count=status.study_count,
                is_unlocked=status.is_unlocked,
                is_collapsed=status.is_collapsed,
                is_favorite=status.is_favorite,
                last_study_at=status.last_study_at,
                next_review_at=status.next_review_at,
                decay_paused=status.decay_paused,
                status=visual_status,
                brightness=brightness
            )
        
        return cls(
            id=node.id,
            name=node.name,
            name_en=node.name_en,
            description=node.description,
            importance_level=node.importance_level,
            sector_code=node.subject.sector_code if node.subject else SectorCode.VOID,
            is_seed=node.is_seed,
            user_status=user_status,
            position_angle=node.subject.position_angle if node.subject else 0,
            position_radius=100 + node.importance_level * 30  # ç®€åŒ–è®¡ç®—
        )
    
    @staticmethod
    def _calculate_status(status) -> NodeStatus:
        if status.is_collapsed:
            return NodeStatus.COLLAPSED
        if not status.is_unlocked:
            return NodeStatus.LOCKED
        
        score = status.mastery_score
        if score >= 95:
            return NodeStatus.MASTERED
        elif score >= 80:
            return NodeStatus.BRILLIANT
        elif score >= 30:
            return NodeStatus.SHINING
        elif score > 0:
            return NodeStatus.GLIMMER
        else:
            return NodeStatus.UNLIT
    
    @staticmethod
    def _calculate_brightness(status) -> float:
        if not status.is_unlocked:
            return 0.2
        if status.is_collapsed:
            return 0.1
        return 0.3 + (status.mastery_score / 100) * 0.7


class NodeRelationInfo(BaseModel):
    source_node_id: UUID
    target_node_id: UUID
    relation_type: str
    strength: float


class GalaxyUserStats(BaseModel):
    total_nodes: int
    unlocked_count: int
    mastered_count: int
    total_study_minutes: int
    sector_distribution: dict  # {sector_code: count}
    streak_days: int  # è¿ç»­å­¦ä¹ å¤©æ•°


class GalaxyGraphResponse(BaseModel):
    """æ˜Ÿå›¾å®Œæ•´æ•°æ®å“åº”"""
    nodes: List[NodeWithStatus]
    relations: List[NodeRelationInfo]
    user_stats: GalaxyUserStats


class SparkEvent(BaseModel):
    """ç‚¹äº®åŠ¨ç”»äº‹ä»¶"""
    node_id: UUID
    node_name: str
    sector_code: SectorCode
    old_mastery: float
    new_mastery: float
    is_first_unlock: bool  # é¦–æ¬¡ç‚¹äº® (æ’­æ”¾ç‰¹æ®ŠåŠ¨ç”»)
    is_level_up: bool      # å‡çº§ (è·¨è¶Šé˜ˆå€¼)
    
    # å‰ç«¯åŠ¨ç”»å‚æ•°
    particle_count: int = 20
    animation_duration_ms: int = 1500


class SparkResult(BaseModel):
    spark_event: SparkEvent
    expansion_queued: bool
    expanded_nodes: Optional[List[NodeBase]] = None  # å¦‚æœåŒæ­¥è¿”å›


class SearchResultItem(BaseModel):
    node: NodeBase
    similarity: float
    user_status: Optional[UserStatusInfo]


class SearchResponse(BaseModel):
    query: str
    results: List[SearchResultItem]
    total_count: int


class ReviewSuggestion(BaseModel):
    node_id: UUID
    node_name: str
    sector_code: SectorCode
    current_mastery: float
    days_since_study: int
    urgency: str  # 'high' | 'normal'


class ReviewSuggestionsResponse(BaseModel):
    suggestions: List[ReviewSuggestion]
    next_review_count: int  # æœªæ¥ 7 å¤©éœ€è¦å¤ä¹ çš„æ€»æ•°4. å‰ç«¯æ¶æ„ä¸è§†è§‰å®ç°4.1 ç›®å½•ç»“æ„lib/
â”œâ”€â”€ features/
â”‚   â””â”€â”€ galaxy/
â”‚       â”œâ”€â”€ data/
â”‚       â”‚   â”œâ”€â”€ galaxy_repository.dart      # æ•°æ®ä»“åº“
â”‚       â”‚   â””â”€â”€ galaxy_api.dart             # API è°ƒç”¨
â”‚       â”œâ”€â”€ domain/
â”‚       â”‚   â”œâ”€â”€ models/
â”‚       â”‚   â”‚   â”œâ”€â”€ knowledge_node.dart
â”‚       â”‚   â”‚   â”œâ”€â”€ node_relation.dart
â”‚       â”‚   â”‚   â”œâ”€â”€ user_node_status.dart
â”‚       â”‚   â”‚   â””â”€â”€ spark_event.dart
â”‚       â”‚   â””â”€â”€ galaxy_state.dart
â”‚       â”œâ”€â”€ presentation/
â”‚       â”‚   â”œâ”€â”€ screens/
â”‚       â”‚   â”‚   â”œâ”€â”€ galaxy_screen.dart      # ä¸»å±å¹•
â”‚       â”‚   â”‚   â””â”€â”€ node_detail_screen.dart # èŠ‚ç‚¹è¯¦æƒ…
â”‚       â”‚   â”œâ”€â”€ widgets/
â”‚       â”‚   â”‚   â”œâ”€â”€ galaxy_viewport.dart    # å¯äº¤äº’è§†å£
â”‚       â”‚   â”‚   â”œâ”€â”€ flame_core.dart         # Shader ç«è‹—
â”‚       â”‚   â”‚   â”œâ”€â”€ star_node.dart          # æ˜Ÿæ˜ŸèŠ‚ç‚¹
â”‚       â”‚   â”‚   â”œâ”€â”€ constellation_lines.dart# æ˜Ÿåº§è¿çº¿
â”‚       â”‚   â”‚   â”œâ”€â”€ particle_system.dart    # ç²’å­ç³»ç»Ÿ
â”‚       â”‚   â”‚   â””â”€â”€ sector_label.dart       # æ˜ŸåŸŸæ ‡ç­¾
â”‚       â”‚   â””â”€â”€ painters/
â”‚       â”‚       â”œâ”€â”€ deep_space_painter.dart # æ·±ç©ºèƒŒæ™¯
â”‚       â”‚       â””â”€â”€ node_painter.dart       # èŠ‚ç‚¹ç»˜åˆ¶
â”‚       â”œâ”€â”€ controllers/
â”‚       â”‚   â”œâ”€â”€ galaxy_controller.dart      # ä¸»æ§åˆ¶å™¨
â”‚       â”‚   â””â”€â”€ animation_controller.dart   # åŠ¨ç”»æ§åˆ¶
â”‚       â””â”€â”€ shaders/
â”‚           â”œâ”€â”€ flame.frag                  # ç«ç„° Shader
â”‚           â””â”€â”€ glow.frag                   # å‘å…‰æ•ˆæœ
â”œâ”€â”€ core/
â”‚   â””â”€â”€ theme/
â”‚       â””â”€â”€ galaxy_colors.dart              # é¢œè‰²å¸¸é‡
â””â”€â”€ shared/
    â””â”€â”€ widgets/
        â””â”€â”€ animated_counter.dart           # æ•°å­—åŠ¨ç”»4.2 ç»„ä»¶æ ‘ç»“æ„GalaxyScreen
â”œâ”€â”€ Scaffold
â”‚   â”œâ”€â”€ AppBar (åŠé€æ˜ï¼Œæ˜¾ç¤ºç»Ÿè®¡)
â”‚   â””â”€â”€ Stack
â”‚       â”œâ”€â”€ DeepSpaceBackground (CustomPainter: é™æ€æ˜Ÿå°˜)
â”‚       â”‚
â”‚       â”œâ”€â”€ GalaxyViewport (InteractiveViewer)
â”‚       â”‚   â””â”€â”€ Stack (size: 2000x2000 é€»è¾‘åƒç´ )
â”‚       â”‚       â”œâ”€â”€ ConstellationLines (CustomPainter: è¿çº¿)
â”‚       â”‚       â”œâ”€â”€ for each sector:
â”‚       â”‚       â”‚   â””â”€â”€ SectorCluster
â”‚       â”‚       â”‚       â”œâ”€â”€ SectorLabel (æ˜ŸåŸŸåç§°)
â”‚       â”‚       â”‚       â””â”€â”€ for each node in sector:
â”‚       â”‚       â”‚           â””â”€â”€ StarNode (GestureDetector + AnimatedWidget)
â”‚       â”‚       â””â”€â”€ FlameCore (ShaderMask, å§‹ç»ˆå±…ä¸­)
â”‚       â”‚
â”‚       â”œâ”€â”€ ParticleLayer (é£å‡ç²’å­åŠ¨ç”»ï¼Œpositioned: full screen)
â”‚       â”‚
â”‚       â””â”€â”€ BottomSheet (èŠ‚ç‚¹è¯¦æƒ…é¢æ¿ï¼Œå¯æ‹–æ‹½å±•å¼€)
â”‚
â””â”€â”€ FloatingActionButton (æœç´¢/åˆ›å»º)4.3 æ ¸å¿ƒç»„ä»¶å®ç°4.3.1 GalaxyScreen (ä¸»å±å¹•)dart// lib/features/galaxy/presentation/screens/galaxy_screen.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

class GalaxyScreen extends ConsumerStatefulWidget {
  const GalaxyScreen({super.key});

  @override
  ConsumerState<GalaxyScreen> createState() => _GalaxyScreenState();
}

class _GalaxyScreenState extends ConsumerState<GalaxyScreen>
    with TickerProviderStateMixin {
  final TransformationController _transformController = TransformationController();
  late AnimationController _flameAnimController;
  
  // ç²’å­ç³»ç»Ÿ
  final List<AscensionParticle> _particles = [];
  
  @override
  void initState() {
    super.initState();
    _flameAnimController = AnimationController(
      vsync: this,
      duration: const Duration(seconds: 10),
    )..repeat();
    
    // åˆå§‹åŒ–æ—¶å±…ä¸­åˆ°ç«è‹—ä½ç½®
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _centerToFlame();
    });
  }

  void _centerToFlame() {
    final screenSize = MediaQuery.of(context).size;
    final scale = 1.0;
    
    // å±…ä¸­åˆ° (1000, 1000) - ç«è‹—ä½ç½®
    _transformController.value = Matrix4.identity()
      ..translate(
        screenSize.width / 2 - 1000 * scale,
        screenSize.height / 2 - 1000 * scale,
      )
      ..scale(scale);
  }

  @override
  Widget build(BuildContext context) {
    final galaxyState = ref.watch(galaxyControllerProvider);
    
    return Scaffold(
      backgroundColor: const Color(0xFF0A0A1A), // æ·±ç©ºé»‘
      extendBodyBehindAppBar: true,
      appBar: _buildAppBar(galaxyState),
      body: Stack(
        children: [
          // 1. æ·±ç©ºèƒŒæ™¯ (é™æ€)
          const DeepSpaceBackground(),
          
          // 2. å¯äº¤äº’çš„æ˜Ÿå›¾è§†å£
          InteractiveViewer(
            transformationController: _transformController,
            minScale: 0.3,
            maxScale: 3.0,
            boundaryMargin: const EdgeInsets.all(500),
            child: SizedBox(
              width: 2000,
              height: 2000,
              child: Stack(
                children: [
                  // æ˜Ÿåº§è¿çº¿
                  if (galaxyState.relations.isNotEmpty)
                    ConstellationLines(
                      relations: galaxyState.relations,
                      nodes: galaxyState.nodePositions,
                    ),
                  
                  // æ˜ŸåŸŸå’ŒèŠ‚ç‚¹
                  ...galaxyState.sectors.map((sector) => SectorCluster(
                    sector: sector,
                    nodes: galaxyState.getNodesInSector(sector.code),
                    onNodeTap: _handleNodeTap,
                  )),
                  
                  // ä¸­å¿ƒç«è‹—
                  Positioned(
                    left: 1000 - 60, // å±…ä¸­
                    top: 1000 - 80,
                    child: FlameCore(
                      animation: _flameAnimController,
                      intensity: galaxyState.flameIntensity,
                    ),
                  ),
                ],
              ),
            ),
          ),
          
          // 3. ç²’å­å±‚ (é£å‡åŠ¨ç”»)
          if (_particles.isNotEmpty)
            ParticleLayer(
              particles: _particles,
              onParticleComplete: _handleParticleComplete,
            ),
          
          // 4. åº•éƒ¨ç»Ÿè®¡é¢æ¿
          Positioned(
            left: 0,
            right: 0,
            bottom: 0,
            child: GalaxyStatsBar(stats: galaxyState.userStats),
          ),
        ],
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: _showSearchDialog,
        backgroundColor: Colors.white.withOpacity(0.1),
        child: const Icon(Icons.search, color: Colors.white),
      ),
    );
  }

  PreferredSizeWidget _buildAppBar(GalaxyState state) {
    return AppBar(
      backgroundColor: Colors.transparent,
      elevation: 0,
      title: Row(
        children: [
          const Icon(Icons.auto_awesome, color: Colors.amber, size: 20),
          const SizedBox(width: 8),
          Text(
            'çŸ¥è¯†æ˜Ÿå›¾',
            style: TextStyle(
              color: Colors.white.withOpacity(0.9),
              fontSize: 18,
              fontWeight: FontWeight.w500,
            ),
          ),
        ],
      ),
      actions: [
        // å¤ä¹ æé†’å¾½ç« 
        if (state.reviewSuggestions.isNotEmpty)
          IconButton(
            icon: Badge(
              label: Text('${state.reviewSuggestions.length}'),
              child: const Icon(Icons.notifications_outlined, color: Colors.white70),
            ),
            onPressed: _showReviewSuggestions,
          ),
      ],
    );
  }

  void _handleNodeTap(KnowledgeNode node) {
    // æ˜¾ç¤ºèŠ‚ç‚¹è¯¦æƒ…åº•éƒ¨é¢æ¿
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) => NodeDetailSheet(node: node),
    );
  }

  /// æ’­æ”¾é£å‡åŠ¨ç”»
  void playAscension(SparkEvent event) {
    final targetNode = ref.read(galaxyControllerProvider).getNode(event.nodeId);
    if (targetNode == null) return;
    
    setState(() {
      // ç”Ÿæˆç²’å­
      for (int i = 0; i < event.particleCount; i++) {
        _particles.add(AscensionParticle(
          id: UniqueKey(),
          startPosition: const Offset(1000, 1000), // ç«è‹—ä¸­å¿ƒ
          endPosition: targetNode.position,
          color: _getSectorColor(event.sectorCode),
          delay: Duration(milliseconds: i * 50),
        ));
      }
    });
  }

  void _handleParticleComplete(AscensionParticle particle) {
    setState(() {
      _particles.remove(particle);
    });
    
    // è§¦å‘ç›®æ ‡èŠ‚ç‚¹çš„ Bloom åŠ¨ç”»
    ref.read(galaxyControllerProvider.notifier).triggerNodeBloom(particle.targetNodeId);
  }

  Color _getSectorColor(String sectorCode) {
    return switch (sectorCode) {
      'COSMOS' => const Color(0xFF00BFFF),
      'TECH' => const Color(0xFFC0C0C0),
      'ART' => const Color(0xFFFF00FF),
      'CIVILIZATION' => const Color(0xFFFFD700),
      'LIFE' => const Color(0xFF32CD32),
      'WISDOM' => const Color(0xFFFFFFFF),
      _ => const Color(0xFF2F4F4F),
    };
  }

  void _showSearchDialog() {
    showDialog(
      context: context,
      builder: (context) => GalaxySearchDialog(
        onNodeSelected: (node) {
          Navigator.pop(context);
          _focusOnNode(node);
        },
      ),
    );
  }

  void _focusOnNode(KnowledgeNode node) {
    // å¹³æ»‘ç§»åŠ¨åˆ°ç›®æ ‡èŠ‚ç‚¹
    final screenSize = MediaQuery.of(context).size;
    final targetMatrix = Matrix4.identity()
      ..translate(
        screenSize.width / 2 - node.position.dx,
        screenSize.height / 2 - node.position.dy,
      )
      ..scale(1.5); // æ”¾å¤§
    
    // TODO: ä½¿ç”¨åŠ¨ç”»è¿‡æ¸¡
    _transformController.value = targetMatrix;
  }

  @override
  void dispose() {
    _flameAnimController.dispose();
    _transformController.dispose();
    super.dispose();
  }
}4.3.2 FlameCore (Shader ç«è‹—)dart// lib/features/galaxy/presentation/widgets/flame_core.dart

import 'package:flutter/material.dart';
import 'dart:ui' as ui;

class FlameCore extends StatefulWidget {
  final Animation<double> animation;
  final double intensity; // 0-1ï¼Œå½±å“ç«ç„°å¤§å°å’Œäº®åº¦
  
  const FlameCore({
    super.key,
    required this.animation,
    this.intensity = 0.7,
  });

  @override
  State<FlameCore> createState() => _FlameCoreState();
}

class _FlameCoreState extends State<FlameCore> {
  ui.FragmentProgram? _program;
  ui.FragmentShader? _shader;
  bool _shaderLoaded = false;

  @override
  void initState() {
    super.initState();
    _loadShader();
  }

  Future<void> _loadShader() async {
    try {
      _program = await ui.FragmentProgram.fromAsset('shaders/flame.frag');
      _shader = _program!.fragmentShader();
      setState(() => _shaderLoaded = true);
    } catch (e) {
      debugPrint('Shader loading failed: $e');
      // Shader åŠ è½½å¤±è´¥æ—¶ä½¿ç”¨é™çº§æ–¹æ¡ˆ
    }
  }

  @override
  Widget build(BuildContext context) {
    if (!_shaderLoaded) {
      // é™çº§æ–¹æ¡ˆï¼šä½¿ç”¨æ¸å˜ + åŠ¨ç”»æ¨¡æ‹Ÿç«ç„°
      return _buildFallbackFlame();
    }
    
    return AnimatedBuilder(
      animation: widget.animation,
      builder: (context, child) {
        return CustomPaint(
          size: const Size(120, 160),
          painter: FlamePainter(
            shader: _shader!,
            time: widget.animation.value * 10,
            intensity: widget.intensity,
          ),
        );
      },
    );
  }

  Widget _buildFallbackFlame() {
    return AnimatedBuilder(
      animation: widget.animation,
      builder: (context, child) {
        final scale = 0.9 + 0.1 * (0.5 + 0.5 * 
            (widget.animation.value * 6.28).sin());
        
        return Transform.scale(
          scale: scale,
          child: Container(
            width: 120,
            height: 160,
            decoration: BoxDecoration(
              gradient: RadialGradient(
                center: const Alignment(0, 0.5),
                radius: 0.8,
                colors: [
                  Colors.white,
                  Colors.amber.shade300,
                  Colors.orange,
                  Colors.deepOrange,
                  Colors.transparent,
                ],
                stops: const [0.0, 0.2, 0.4, 0.7, 1.0],
              ),
              boxShadow: [
                BoxShadow(
                  color: Colors.orange.withOpacity(0.6),
                  blurRadius: 40,
                  spreadRadius: 20,
                ),
              ],
            ),
          ),
        );
      },
    );
  }
}


class FlamePainter extends CustomPainter {
  final ui.FragmentShader shader;
  final double time;
  final double intensity;

  FlamePainter({
    required this.shader,
    required this.time,
    required this.intensity,
  });

  @override
  void paint(Canvas canvas, Size size) {
    // è®¾ç½® uniform å˜é‡
    shader.setFloat(0, size.width);   // u_resolution.x
    shader.setFloat(1, size.height);  // u_resolution.y
    shader.setFloat(2, time);         // u_time
    shader.setFloat(3, intensity);    // u_intensity
    
    // é¢œè‰²æ··åˆ (RGB)
    shader.setFloat(4, 1.0);  // r
    shader.setFloat(5, 0.6);  // g
    shader.setFloat(6, 0.2);  // b

    final paint = Paint()..shader = shader;
    canvas.drawRect(
      Rect.fromLTWH(0, 0, size.width, size.height),
      paint,
    );
  }

  @override
  bool shouldRepaint(FlamePainter oldDelegate) {
    return oldDelegate.time != time || oldDelegate.intensity != intensity;
  }
}4.3.3 GLSL Shader (ç«ç„°æ•ˆæœ)glsl// assets/shaders/flame.frag

#version 460 core

#include <flutter/runtime_effect.glsl>

precision mediump float;

uniform vec2 u_resolution;
uniform float u_time;
uniform float u_intensity;
uniform vec3 u_color;

out vec4 fragColor;

// Simplex å™ªå£°å‡½æ•°
vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }

float snoise(vec2 v) {
    const vec4 C = vec4(0.211324865405187, 0.366025403784439,
                       -0.577350269189626, 0.024390243902439);
    vec2 i  = floor(v + dot(v, C.yy));
    vec2 x0 = v - i + dot(i, C.xx);
    vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
    vec4 x12 = x0.xyxy + C.xxzz;
    x12.xy -= i1;
    i = mod289(i);
    vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0))
                            + i.x + vec3(0.0, i1.x, 1.0));
    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),
                           dot(x12.zw,x12.zw)), 0.0);
    m = m*m;
    m = m*m;
    vec3 x = 2.0 * fract(p * C.www) - 1.0;
    vec3 h = abs(x) - 0.5;
    vec3 ox = floor(x + 0.5);
    vec3 a0 = x - ox;
    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);
    vec3 g;
    g.x  = a0.x  * x0.x  + h.x  * x0.y;
    g.yz = a0.yz * x12.xz + h.yz * x12.yw;
    return 130.0 * dot(m, g);
}

// FBM (åˆ†å½¢å¸ƒæœ—è¿åŠ¨)
float fbm(vec2 st) {
    float value = 0.0;
    float amplitude = 0.5;
    float frequency = 1.0;
    
    for (int i = 0; i < 5; i++) {
        value += amplitude * snoise(st * frequency);
        frequency *= 2.0;
        amplitude *= 0.5;
    }
    
    return value;
}

void main() {
    vec2 st = FlutterFragCoord().xy / u_resolution;
    
    // è°ƒæ•´åæ ‡ç³»ï¼Œç«ç„°æ ¹éƒ¨åœ¨åº•éƒ¨ä¸­å¿ƒ
    st.x = st.x * 2.0 - 1.0;  // -1 to 1
    st.y = 1.0 - st.y;        // ç¿»è½¬ Y
    
    // ç«ç„°å½¢çŠ¶ (é”¥å½¢)
    float shape = 1.0 - length(vec2(st.x * 1.5, st.y - 0.2));
    shape = smoothstep(0.0, 0.8 * u_intensity, shape);
    
    // åŠ¨æ€å™ªå£°æ‰°åŠ¨
    vec2 q = vec2(0.0);
    q.x = fbm(st + 0.1 * u_time);
    q.y = fbm(st + vec2(1.0));
    
    vec2 r = vec2(0.0);
    r.x = fbm(st + 1.0 * q + vec2(1.7, 9.2) + 0.15 * u_time);
    r.y = fbm(st + 1.0 * q + vec2(8.3, 2.8) + 0.126 * u_time);
    
    float noise = fbm(st + r);
    
    // åˆå¹¶å½¢çŠ¶å’Œå™ªå£°
    float flame = shape * (0.5 + 0.5 * noise);
    flame = smoothstep(0.1, 0.9, flame);
    
    // é¢œè‰²æ¸å˜ (ç™½ â†’ é»„ â†’ æ©™ â†’ çº¢)
    vec3 color = mix(
        vec3(0.1, 0.0, 0.0),       // è¾¹ç¼˜æš—çº¢
        vec3(1.0, 0.9, 0.7),       // æ ¸å¿ƒäº®ç™½
        pow(flame, 1.5)
    );
    
    color = mix(color, u_color, 0.3); // æ··å…¥è‡ªå®šä¹‰é¢œè‰²
    
    // å‘å…‰æ•ˆæœ
    float glow = exp(-3.0 * length(st - vec2(0.0, 0.3))) * u_intensity;
    color += vec3(1.0, 0.6, 0.2) * glow * 0.5;
    
    fragColor = vec4(color, flame);
}4.3.4 StarNode (æ˜Ÿæ˜ŸèŠ‚ç‚¹)dart// lib/features/galaxy/presentation/widgets/star_node.dart

import 'package:flutter/material.dart';

class StarNode extends StatefulWidget {
  final KnowledgeNode node;
  final UserNodeStatus? status;
  final VoidCallback onTap;
  
  const StarNode({
    super.key,
    required this.node,
    this.status,
    required this.onTap,
  });

  @override
  State<StarNode> createState() => _StarNodeState();
}

class _StarNodeState extends State<StarNode> 
    with SingleTickerProviderStateMixin {
  late AnimationController _pulseController;
  bool _isHovered = false;
  
  // æ­£åœ¨æ’­æ”¾ Bloom åŠ¨ç”»
  bool _blooming = false;

  @override
  void initState() {
    super.initState();
    _pulseController = AnimationController(
      vsync: this,
      duration: const Duration(seconds: 2),
    );
    
    // æ ¹æ®çŠ¶æ€å†³å®šæ˜¯å¦æ’­æ”¾è„‰å†²åŠ¨ç”»
    if (_shouldPulse) {
      _pulseController.repeat(reverse: true);
    }
  }

  bool get _shouldPulse {
    if (widget.status == null) return false;
    // é«˜æŒæ¡åº¦èŠ‚ç‚¹æŒç»­è„‰å†²
    return widget.status!.masteryScore >= 80;
  }

  @override
  Widget build(BuildContext context) {
    final size = _calculateSize();
    final color = _calculateColor();
    final brightness = widget.status?.brightness ?? 0.2;
    
    return GestureDetector(
      onTap: widget.onTap,
      child: MouseRegion(
        onEnter: (_) => setState(() => _isHovered = true),
        onExit: (_) => setState(() => _isHovered = false),
        child: AnimatedBuilder(
          animation: _pulseController,
          builder: (context, child) {
            final pulseScale = _shouldPulse 
                ? 1.0 + 0.1 * _pulseController.value 
                : 1.0;
            final hoverScale = _isHovered ? 1.2 : 1.0;
            
            return Transform.scale(
              scale: pulseScale * hoverScale * (_blooming ? 1.5 : 1.0),
              child: _buildStar(size, color, brightness),
            );
          },
        ),
      ),
    );
  }

  Widget _buildStar(double size, Color color, double brightness) {
    // åç¼©çŠ¶æ€ç‰¹æ®Šå¤„ç†
    if (widget.status?.isCollapsed == true) {
      return _buildCollapsedStar(size);
    }
    
    return Container(
      width: size,
      height: size,
      decoration: BoxDecoration(
        shape: BoxShape.circle,
        gradient: RadialGradient(
          colors: [
            Colors.white.withOpacity(brightness),
            color.withOpacity(brightness * 0.8),
            color.withOpacity(brightness * 0.4),
            Colors.transparent,
          ],
          stops: const [0.0, 0.3, 0.6, 1.0],
        ),
        boxShadow: brightness > 0.5 ? [
          BoxShadow(
            color: color.withOpacity(0.6),
            blurRadius: size * 0.8,
            spreadRadius: size * 0.2,
          ),
        ] : null,
      ),
      child: _isHovered ? _buildLabel() : null,
    );
  }

  Widget _buildCollapsedStar(double size) {
    // åç¼©æ˜Ÿï¼šé»‘è‰²æ ¸å¿ƒ + çº¢è‰²è„‰å†²è¾¹ç¼˜
    return AnimatedBuilder(
      animation: _pulseController,
      builder: (context, child) {
        return Container(
          width: size,
          height: size,
          decoration: BoxDecoration(
            shape: BoxShape.circle,
            gradient: RadialGradient(
              colors: [
                Colors.black,
                Colors.red.withOpacity(0.3 + 0.3 * _pulseController.value),
                Colors.transparent,
              ],
              stops: const [0.3, 0.6, 1.0],
            ),
            boxShadow: [
              BoxShadow(
                color: Colors.red.withOpacity(0.5),
                blurRadius: size * 0.5,
              ),
            ],
          ),
        );
      },
    );
  }

  Widget _buildLabel() {
    return Center(
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
        decoration: BoxDecoration(
          color: Colors.black.withOpacity(0.7),
          borderRadius: BorderRadius.circular(4),
        ),
        child: Text(
          widget.node.name,
          style: const TextStyle(
            color: Colors.white,
            fontSize: 10,
            fontWeight: FontWeight.w500,
          ),
          maxLines: 1,
          overflow: TextOverflow.ellipsis,
        ),
      ),
    );
  }

  double _calculateSize() {
    // åŸºç¡€å¤§å°æ ¹æ®é‡è¦æ€§ç­‰çº§
    final baseSize = 20.0 + widget.node.importanceLevel * 8.0;
    
    // æŒæ¡åº¦å½±å“å¤§å°
    final masteryBonus = (widget.status?.masteryScore ?? 0) / 100 * 10;
    
    return baseSize + masteryBonus;
  }

  Color _calculateColor() {
    return switch (widget.node.sectorCode) {
      'COSMOS' => const Color(0xFF00BFFF),
      'TECH' => const Color(0xFFC0C0C0),
      'ART' => const Color(0xFFFF00FF),
      'CIVILIZATION' => const Color(0xFFFFD700),
      'LIFE' => const Color(0xFF32CD32),
      'WISDOM' => const Color(0xFFFFFFFF),
      _ => const Color(0xFF2F4F4F),
    };
  }

  /// è§¦å‘ Bloom åŠ¨ç”» (ç²’å­åˆ°è¾¾æ—¶è°ƒç”¨)
  void triggerBloom() {
    setState(() => _blooming = true);
    
    Future.delayed(const Duration(milliseconds: 500), () {
      if (mounted) {
        setState(() => _blooming = false);
      }
    });
  }

  @override
  void dispose() {
    _pulseController.dispose();
    super.dispose();
  }
}4.3.5 ParticleSystem (é£å‡ç²’å­åŠ¨ç”»)dart// lib/features/galaxy/presentation/widgets/particle_system.dart

import 'package:flutter/material.dart';
import 'dart:math' as math;

class AscensionParticle {
  final Key id;
  final Offset startPosition;
  final Offset endPosition;
  final Color color;
  final Duration delay;
  final UUID targetNodeId;
  
  AscensionParticle({
    required this.id,
    required this.startPosition,
    required this.endPosition,
    required this.color,
    required this.targetNodeId,
    this.delay = Duration.zero,
  });
}


class ParticleLayer extends StatelessWidget {
  final List<AscensionParticle> particles;
  final void Function(AscensionParticle) onParticleComplete;
  
  const ParticleLayer({
    super.key,
    required this.particles,
    required this.onParticleComplete,
  });

  @override
  Widget build(BuildContext context) {
    return Stack(
      children: particles.map((particle) => 
        _AnimatedParticle(
          key: particle.id,
          particle: particle,
          onComplete: () => onParticleComplete(particle),
        ),
      ).toList(),
    );
  }
}


class _AnimatedParticle extends StatefulWidget {
  final AscensionParticle particle;
  final VoidCallback onComplete;

  const _AnimatedParticle({
    super.key,
    required this.particle,
    required this.onComplete,
  });

  @override
  State<_AnimatedParticle> createState() => _AnimatedParticleState();
}

class _AnimatedParticleState extends State<_AnimatedParticle>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _progressAnimation;
  late Animation<double> _opacityAnimation;
  
  // è´å¡å°”æ›²çº¿æ§åˆ¶ç‚¹
  late Offset _controlPoint;
  
  // æ‹–å°¾ä½ç½®å†å²
  final List<Offset> _trail = [];
  static const int _maxTrailLength = 10;

  @override
  void initState() {
    super.initState();
    
    _controller = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 1200),
    );
    
    _progressAnimation = CurvedAnimation(
      parent: _controller,
      curve: Curves.easeInOutCubic,
    );
    
    _opacityAnimation = Tween<double>(begin: 1.0, end: 0.0).animate(
      CurvedAnimation(
        parent: _controller,
        curve: const Interval(0.7, 1.0, curve: Curves.easeOut),
      ),
    );
    
    // è®¡ç®—è´å¡å°”æ§åˆ¶ç‚¹ (åœ¨è·¯å¾„ä¸­å‚çº¿ä¸Šéšæœºåç§»)
    _calculateControlPoint();
    
    // å»¶è¿Ÿåå¼€å§‹åŠ¨ç”»
    Future.delayed(widget.particle.delay, () {
      if (mounted) {
        _controller.forward().whenComplete(widget.onComplete);
      }
    });
    
    // ç›‘å¬åŠ¨ç”»æ›´æ–°æ‹–å°¾
    _controller.addListener(_updateTrail);
  }

  void _calculateControlPoint() {
    final start = widget.particle.startPosition;
    final end = widget.particle.endPosition;
    
    // ä¸­ç‚¹
    final midPoint = Offset(
      (start.dx + end.dx) / 2,
      (start.dy + end.dy) / 2,
    );
    
    // è·¯å¾„å‘é‡
    final direction = end - start;
    
    // å‚ç›´å‘é‡ (å½’ä¸€åŒ–åä¹˜ä»¥åç§»é‡)
    final perpendicular = Offset(-direction.dy, direction.dx);
    final normalizedPerp = perpendicular / perpendicular.distance;
    
    // éšæœºåç§» (æ­£è´Ÿéšæœº)
    final random = math.Random();
    final offsetMagnitude = direction.distance * 0.3 * (random.nextBool() ? 1 : -1);
    
    _controlPoint = midPoint + normalizedPerp * offsetMagnitude;
  }

  void _updateTrail() {
    final currentPos = _calculatePosition(_progressAnimation.value);
    _trail.add(currentPos);
    
    if (_trail.length > _maxTrailLength) {
      _trail.removeAt(0);
    }
  }

  Offset _calculatePosition(double t) {
    final start = widget.particle.startPosition;
    final end = widget.particle.endPosition;
    final control = _controlPoint;
    
    // äºŒé˜¶è´å¡å°”æ›²çº¿
    final x = math.pow(1 - t, 2) * start.dx +
              2 * (1 - t) * t * control.dx +
              math.pow(t, 2) * end.dx;
    final y = math.pow(1 - t, 2) * start.dy +
              2 * (1 - t) * t * control.dy +
              math.pow(t, 2) * end.dy;
    
    return Offset(x, y);
  }

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: _controller,
      builder: (context, child) {
        return CustomPaint(
          size: Size.infinite,
          painter: _ParticlePainter(
            position: _calculatePosition(_progressAnimation.value),
            trail: List.from(_trail),
            color: widget.particle.color,
            opacity: _opacityAnimation.value,
          ),
        );
      },
    );
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }
}


class _ParticlePainter extends CustomPainter {
  final Offset position;
  final List<Offset> trail;
  final Color color;
  final double opacity;

  _ParticlePainter({
    required this.position,
    required this.trail,
    required this.color,
    required this.opacity,
  });

  @override
  void paint(Canvas canvas, Size size) {
    // ç»˜åˆ¶æ‹–å°¾
    if (trail.length >= 2) {
      final trailPaint = Paint()
        ..style = PaintingStyle.stroke
        ..strokeCap = StrokeCap.round;
      
      for (int i = 1; i < trail.length; i++) {
        final progress = i / trail.length;
        trailPaint
          ..strokeWidth = 3.0 * progress
          ..color = color.withOpacity(opacity * progress * 0.5);
        
        canvas.drawLine(trail[i - 1], trail[i], trailPaint);
      }
    }
    
    // ç»˜åˆ¶ç²’å­ä¸»ä½“
    final particlePaint = Paint()
      ..color = Colors.white.withOpacity(opacity)
      ..maskFilter = MaskFilter.blur(BlurStyle.normal, 4);
    
    canvas.drawCircle(position, 6, particlePaint);
    
    // ç»˜åˆ¶å‘å…‰
    final glowPaint = Paint()
      ..color = color.withOpacity(opacity * 0.6)
      ..maskFilter = MaskFilter.blur(BlurStyle.normal, 12);
    
    canvas.drawCircle(position, 10, glowPaint);
  }

  @override
  bool shouldRepaint(_ParticlePainter oldDelegate) => true;
}4.3.6 ConstellationLines (æ˜Ÿåº§è¿çº¿)dart// lib/features/galaxy/presentation/widgets/constellation_lines.dart

import 'package:flutter/material.dart';

class ConstellationLines extends StatelessWidget {
  final List<NodeRelation> relations;
  final Map<UUID, Offset> nodePositions;
  
  const ConstellationLines({
    super.key,
    required this.relations,
    required this.nodePositions,
  });

  @override
  Widget build(BuildContext context) {
    return CustomPaint(
      size: Size.infinite,
      painter: _ConstellationPainter(
        relations: relations,
        nodePositions: nodePositions,
      ),
    );
  }
}


class _ConstellationPainter extends CustomPainter {
  final List<NodeRelation> relations;
  final Map<UUID, Offset> nodePositions;

  _ConstellationPainter({
    required this.relations,
    required this.nodePositions,
  });

  @override
  void paint(Canvas canvas, Size size) {
    for (final relation in relations) {
      final startPos = nodePositions[relation.sourceNodeId];
      final endPos = nodePositions[relation.targetNodeId];
      
      if (startPos == null || endPos == null) continue;
      
      _drawConnection(canvas, startPos, endPos, relation);
    }
  }

  void _drawConnection(
    Canvas canvas, 
    Offset start, 
    Offset end, 
    NodeRelation relation
  ) {
    final color = _getRelationColor(relation.relationType);
    final opacity = relation.strength * 0.6;
    
    // ä¸»çº¿
    final linePaint = Paint()
      ..color = color.withOpacity(opacity)
      ..strokeWidth = 1.0 + relation.strength
      ..style = PaintingStyle.stroke;
    
    canvas.drawLine(start, end, linePaint);
    
    // å‘å…‰æ•ˆæœ
    final glowPaint = Paint()
      ..color = color.withOpacity(opacity * 0.3)
      ..strokeWidth = 4.0
      ..style = PaintingStyle.stroke
      ..maskFilter = MaskFilter.blur(BlurStyle.normal, 3);
    
    canvas.drawLine(start, end, glowPaint);
    
    // å¦‚æœæ˜¯å‰ç½®å…³ç³»ï¼Œç»˜åˆ¶ç®­å¤´
    if (relation.relationType == 'prerequisite') {
      _drawArrow(canvas, start, end, color.withOpacity(opacity));
    }
  }

  void _drawArrow(Canvas canvas, Offset start, Offset end, Color color) {
    final direction = (end - start);
    final normalized = direction / direction.distance;
    
    // ç®­å¤´ä½ç½® (åœ¨çº¿æ®µ 70% å¤„)
    final arrowPos = start + direction * 0.7;
    
    // ç®­å¤´å¤§å°
    const arrowSize = 8.0;
    
    // è®¡ç®—ç®­å¤´ä¸¤ç¿¼
    final perpendicular = Offset(-normalized.dy, normalized.dx);
    final arrowLeft = arrowPos - normalized * arrowSize + perpendicular * arrowSize * 0.5;
    final arrowRight = arrowPos - normalized * arrowSize - perpendicular * arrowSize * 0.5;
    
    final arrowPath = Path()
      ..moveTo(arrowPos.dx, arrowPos.dy)
      ..lineTo(arrowLeft.dx, arrowLeft.dy)
      ..lineTo(arrowRight.dx, arrowRight.dy)
      ..close();
    
    canvas.drawPath(arrowPath, Paint()..color = color);
  }

  Color _getRelationColor(String relationType) {
    return switch (relationType) {
      'prerequisite' => Colors.cyan,
      'related' => Colors.purple,
      'application' => Colors.green,
      'composition' => Colors.orange,
      'evolution' => Colors.amber,
      _ => Colors.grey,
    };
  }

  @override
  bool shouldRepaint(_ConstellationPainter oldDelegate) {
    return oldDelegate.relations != relations ||
           oldDelegate.nodePositions != nodePositions;
  }
}4.4 çŠ¶æ€ç®¡ç† (Riverpod)dart// lib/features/galaxy/controllers/galaxy_controller.dart

import 'package:flutter_riverpod/flutter_riverpod.dart';

final galaxyControllerProvider = StateNotifierProvider<GalaxyController, GalaxyState>((ref) {
  final repository = ref.watch(galaxyRepositoryProvider);
  return GalaxyController(repository);
});


class GalaxyState {
  final List<KnowledgeNode> nodes;
  final List<NodeRelation> relations;
  final Map<UUID, UserNodeStatus> userStatuses;
  final GalaxyUserStats userStats;
  final List<ReviewSuggestion> reviewSuggestions;
  final bool isLoading;
  final String? error;
  
  // è®¡ç®—å±æ€§
  Map<UUID, Offset> get nodePositions => _calculatePositions();
  double get flameIntensity => _calculateFlameIntensity();
  
  List<Sector> get sectors => SectorCode.values
      .map((code) => Sector(code: code))
      .toList();
  
  List<KnowledgeNode> getNodesInSector(SectorCode code) {
    return nodes.where((n) => n.sectorCode == code).toList();
  }
  
  KnowledgeNode? getNode(UUID id) {
    return nodes.firstWhereOrNull((n) => n.id == id);
  }
  
  GalaxyState({
    this.nodes = const [],
    this.relations = const [],
    this.userStatuses = const {},
    this.userStats = const GalaxyUserStats(),
    this.reviewSuggestions = const [],
    this.isLoading = false,
    this.error,
  });
  
  GalaxyState copyWith({...}) => GalaxyState(...);
  
  Map<UUID, Offset> _calculatePositions() {
    final positions = <UUID, Offset>{};
    final random = math.Random(42); // å›ºå®šç§å­ä¿è¯ä¸€è‡´æ€§
    
    for (final node in nodes) {
      // è·å–æ˜ŸåŸŸåŸºå‡†è§’åº¦
      final sectorAngle = _getSectorBaseAngle(node.sectorCode);
      
      // æ ¹æ®é‡è¦æ€§ç¡®å®šåŠå¾„å±‚çº§
      final baseRadius = 150.0 + (5 - node.importanceLevel) * 80.0;
      
      // æ·»åŠ å™ªå£°
      final noiseAngle = (random.nextDouble() - 0.5) * 50;
      final noiseRadius = (random.nextDouble() - 0.5) * 40;
      
      final angle = (sectorAngle + noiseAngle) * math.pi / 180;
      final radius = baseRadius + noiseRadius;
      
      // è½¬æ¢ä¸ºç¬›å¡å°”åæ ‡ (ä»¥ 1000,1000 ä¸ºä¸­å¿ƒ)
      positions[node.id] = Offset(
        1000 + radius * math.cos(angle),
        1000 + radius * math.sin(angle),
      );
    }
    
    return positions;
  }
  
  double _getSectorBaseAngle(SectorCode code) {
    return switch (code) {
      SectorCode.COSMOS => 300,
      SectorCode.TECH => 60,
      SectorCode.ART => 180,
      SectorCode.CIVILIZATION => 0,
      SectorCode.LIFE => 240,
      SectorCode.WISDOM => 330,
      SectorCode.VOID => 120,
    };
  }
  
  double _calculateFlameIntensity() {
    // æ ¹æ®ä»Šæ—¥å­¦ä¹ æƒ…å†µè®¡ç®—ç«ç„°å¼ºåº¦
    if (userStats.totalStudyMinutes == 0) return 0.3;
    
    // ä»Šæ—¥å­¦ä¹ æ—¶é•¿å½±å“å¼ºåº¦ (30åˆ†é’Ÿä¸ºåŸºå‡†)
    final todayMinutes = userStats.todayStudyMinutes;
    return (0.3 + 0.7 * (todayMinutes / 60).clamp(0.0, 1.0));
  }
}


class GalaxyController extends StateNotifier<GalaxyState> {
  final GalaxyRepository _repository;
  
  GalaxyController(this._repository) : super(GalaxyState()) {
    loadGalaxy();
  }

  Future<void> loadGalaxy({String? sectorCode}) async {
    state = state.copyWith(isLoading: true, error: null);
    
    try {
      final response = await _repository.getGalaxyGraph(sectorCode: sectorCode);
      
      state = state.copyWith(
        nodes: response.nodes,
        relations: response.relations,
        userStatuses: {for (var n in response.nodes) 
          if (n.userStatus != null) n.id: n.userStatus!},
        userStats: response.userStats,
        isLoading: false,
      );
      
      // åŠ è½½å¤ä¹ å»ºè®®
      await loadReviewSuggestions();
      
    } catch (e) {
      state = state.copyWith(isLoading: false, error: e.toString());
    }
  }

  Future<void> loadReviewSuggestions() async {
    try {
      final suggestions = await _repository.getReviewSuggestions();
      state = state.copyWith(reviewSuggestions: suggestions);
    } catch (e) {
      // éå…³é”®é”™è¯¯ï¼Œé™é»˜å¤„ç†
      debugPrint('Failed to load review suggestions: $e');
    }
  }

  /// å¤„ç†ä»»åŠ¡å®Œæˆäº‹ä»¶
  Future<SparkEvent?> handleTaskCompleted(UUID taskId, UUID? nodeId, int studyMinutes) async {
    if (nodeId == null) return null;
    
    try {
      final result = await _repository.sparkNode(
        nodeId: nodeId,
        studyMinutes: studyMinutes,
        taskId: taskId,
      );
      
      // æ›´æ–°æœ¬åœ°çŠ¶æ€
      _updateNodeStatus(nodeId, result.updatedStatus);
      
      return result.sparkEvent;
      
    } catch (e) {
      debugPrint('Failed to spark node: $e');
      return null;
    }
  }

  void _updateNodeStatus(UUID nodeId, UserNodeStatus newStatus) {
    final updatedStatuses = Map<UUID, UserNodeStatus>.from(state.userStatuses);
    updatedStatuses[nodeId] = newStatus;
    
    state = state.copyWith(userStatuses: updatedStatuses);
  }

  /// è§¦å‘èŠ‚ç‚¹ Bloom åŠ¨ç”» (ç²’å­åˆ°è¾¾æ—¶)
  void triggerNodeBloom(UUID nodeId) {
    // é€šè¿‡ GlobalKey æˆ–äº‹ä»¶é€šçŸ¥å¯¹åº”çš„ StarNode
    // è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…å¯ç”¨äº‹ä»¶æ€»çº¿
  }

  /// è¯­ä¹‰æœç´¢
  Future<List<SearchResultItem>> search(String query) async {
    return await _repository.searchNodes(query);
  }
}5. LLM æ™ºèƒ½æ‹“å±•ç³»ç»Ÿ5.1 æ‹“å±•æœºåˆ¶æ¦‚è¿°ç”¨æˆ·å®Œæˆä»»åŠ¡ "å­¦ä¹ å¿«é€Ÿæ’åºç®—æ³•"
        â”‚
        â–¼
GalaxyService.spark_node()
        â”‚
        â”œâ”€â”€ æ›´æ–°æŒæ¡åº¦
        â”‚
        â””â”€â”€ è§¦å‘æ‹“å±•æ£€æŸ¥
                â”‚
                â–¼
        ExpansionService.should_expand()
        æ¡ä»¶ï¼šstudy_count >= 2 && last_expansion > 1 day
                â”‚
                â–¼ (æ»¡è¶³æ¡ä»¶)
        åŠ å…¥æ‹“å±•é˜Ÿåˆ— expansion_queue
                â”‚
                â–¼ (åå° Worker)
        ExpansionWorker.process()
                â”‚
                â”œâ”€â”€ 1. æ”¶é›†ä¸Šä¸‹æ–‡ (å½“å‰èŠ‚ç‚¹ + ç›¸é‚»èŠ‚ç‚¹ + ç”¨æˆ·å­¦ä¹ å†å²)
                â”‚
                â”œâ”€â”€ 2. æ„å»º Prompt
                â”‚
                â”œâ”€â”€ 3. è°ƒç”¨ LLM
                â”‚
                â”œâ”€â”€ 4. è§£æå“åº” â†’ æ–°èŠ‚ç‚¹åˆ—è¡¨
                â”‚
                â”œâ”€â”€ 5. å»é‡ & éªŒè¯
                â”‚
                â”œâ”€â”€ 6. å†™å…¥æ•°æ®åº“
                â”‚
                â””â”€â”€ 7. SSE é€šçŸ¥å‰ç«¯ â†’ æ’­æ”¾"æ¶Œç°"åŠ¨ç”»5.2 ExpansionService å®ç°python# backend/app/services/expansion_service.py

import json
from uuid import UUID
from typing import List, Optional
from datetime import datetime, timedelta
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from app.models import KnowledgeNode, NodeExpansionQueue, NodeRelation
from app.core.llm_client import LLMClient
from app.services.embedding_service import EmbeddingService


class ExpansionService:
    """
    LLM çŸ¥è¯†æ‹“å±•æœåŠ¡
    
    å½“ç”¨æˆ·æ·±å…¥å­¦ä¹ æŸä¸ªçŸ¥è¯†ç‚¹åï¼Œè‡ªåŠ¨æ‹“å±•ç›¸å…³çŸ¥è¯†èŠ‚ç‚¹ï¼Œ
    å®ç°çŸ¥è¯†æ˜Ÿå›¾çš„æœ‰æœºç”Ÿé•¿ã€‚
    """
    
    # æ‹“å±•é™åˆ¶
    MAX_EXPANDED_NODES_PER_REQUEST = 5  # æ¯æ¬¡æœ€å¤šæ‹“å±• 5 ä¸ªèŠ‚ç‚¹
    MIN_STUDY_COUNT_FOR_EXPANSION = 2   # è‡³å°‘å­¦ä¹  2 æ¬¡æ‰è§¦å‘æ‹“å±•
    EXPANSION_COOLDOWN_HOURS = 24       # åŒä¸€èŠ‚ç‚¹æ‹“å±•å†·å´æ—¶é—´
    
    def __init__(
        self,
        db: AsyncSession,
        llm_client: LLMClient,
        embedding_service: EmbeddingService
    ):
        self.db = db
        self.llm_client = llm_client
        self.embedding_service = embedding_service

    async def queue_expansion(
        self,
        trigger_node_id: UUID,
        trigger_task_id: Optional[UUID],
        user_id: UUID
    ) -> bool:
        """
        å°†æ‹“å±•è¯·æ±‚åŠ å…¥é˜Ÿåˆ—
        
        Returns:
            bool: æ˜¯å¦æˆåŠŸåŠ å…¥é˜Ÿåˆ—
        """
        # 1. æ£€æŸ¥æ˜¯å¦æ»¡è¶³æ‹“å±•æ¡ä»¶
        if not await self._should_expand(trigger_node_id, user_id):
            return False
        
        # 2. æ”¶é›†æ‹“å±•ä¸Šä¸‹æ–‡
        context = await self._build_expansion_context(trigger_node_id, user_id)
        
        # 3. åˆ›å»ºé˜Ÿåˆ—ä»»åŠ¡
        queue_item = NodeExpansionQueue(
            trigger_node_id=trigger_node_id,
            trigger_task_id=trigger_task_id,
            user_id=user_id,
            expansion_context=context,
            status='pending'
        )
        
        self.db.add(queue_item)
        await self.db.commit()
        
        return True

    async def _should_expand(self, node_id: UUID, user_id: UUID) -> bool:
        """æ£€æŸ¥æ˜¯å¦åº”è¯¥è§¦å‘æ‹“å±•"""
        # æ£€æŸ¥æœ€è¿‘æ˜¯å¦å·²æ‹“å±•è¿‡
        cooldown_time = datetime.utcnow() - timedelta(hours=self.EXPANSION_COOLDOWN_HOURS)
        
        query = select(NodeExpansionQueue).where(
            NodeExpansionQueue.trigger_node_id == node_id,
            NodeExpansionQueue.user_id == user_id,
            NodeExpansionQueue.created_at > cooldown_time
        )
        
        result = await self.db.execute(query)
        recent_expansion = result.scalar_one_or_none()
        
        return recent_expansion is None

    async def _build_expansion_context(self, node_id: UUID, user_id: UUID) -> str:
        """æ„å»ºå‘é€ç»™ LLM çš„æ‹“å±•ä¸Šä¸‹æ–‡"""
        # è·å–è§¦å‘èŠ‚ç‚¹
        node = await self.db.get(KnowledgeNode, node_id)
        
        # è·å–ç›¸é‚»èŠ‚ç‚¹
        neighbors = await self._get_neighbor_nodes(node_id)
        
        # è·å–ç”¨æˆ·å·²å­¦ä¹ çš„èŠ‚ç‚¹ (é¿å…é‡å¤æ¨è)
        learned_nodes = await self._get_user_learned_nodes(user_id)
        
        context = {
            "trigger_node": {
                "name": node.name,
                "description": node.description,
                "sector": node.subject.sector_code if node.subject else "VOID",
            },
            "neighbor_nodes": [
                {"name": n.name, "relation": rel}
                for n, rel in neighbors
            ],
            "already_learned": [n.name for n in learned_nodes],
        }
        
        return json.dumps(context, ensure_ascii=False)

    async def _get_neighbor_nodes(self, node_id: UUID, limit: int = 10):
        """è·å–èŠ‚ç‚¹çš„é‚»å±…èŠ‚ç‚¹"""
        query = (
            select(KnowledgeNode, NodeRelation.relation_type)
            .join(
                NodeRelation,
                (NodeRelation.source_node_id == node_id) | 
                (NodeRelation.target_node_id == node_id)
            )
            .where(KnowledgeNode.id != node_id)
            .limit(limit)
        )
        
        result = await self.db.execute(query)
        return result.all()

    async def process_expansion(self, queue_id: UUID) -> List[KnowledgeNode]:
        """
        å¤„ç†æ‹“å±•è¯·æ±‚ (ç”± Worker è°ƒç”¨)
        
        Returns:
            List[KnowledgeNode]: æ–°åˆ›å»ºçš„çŸ¥è¯†èŠ‚ç‚¹
        """
        # 1. è·å–é˜Ÿåˆ—ä»»åŠ¡
        queue_item = await self.db.get(NodeExpansionQueue, queue_id)
        if not queue_item or queue_item.status != 'pending':
            return []
        
        # 2. æ ‡è®°ä¸ºå¤„ç†ä¸­
        queue_item.status = 'processing'
        await self.db.commit()
        
        try:
            # 3. è°ƒç”¨ LLM
            prompt = self._build_expansion_prompt(queue_item.expansion_context)
            response = await self.llm_client.chat_completion(
                messages=[{"role": "user", "content": prompt}],
                response_format={"type": "json_object"}
            )
            
            # 4. è§£æå“åº”
            expanded_data = self._parse_expansion_response(response)
            
            # 5. åˆ›å»ºæ–°èŠ‚ç‚¹
            new_nodes = await self._create_expanded_nodes(
                expanded_data,
                trigger_node_id=queue_item.trigger_node_id,
                user_id=queue_item.user_id
            )
            
            # 6. æ›´æ–°é˜Ÿåˆ—çŠ¶æ€
            queue_item.status = 'completed'
            queue_item.expanded_nodes = json.dumps([
                {"id": str(n.id), "name": n.name} for n in new_nodes
            ])
            queue_item.processed_at = datetime.utcnow()
            await self.db.commit()
            
            return new_nodes
            
        except Exception as e:
            queue_item.status = 'failed'
            queue_item.error_message = str(e)
            await self.db.commit()
            raise

    def _build_expansion_prompt(self, context_json: str) -> str:
        """æ„å»ºæ‹“å±• Prompt"""
        context = json.loads(context_json)
        
        return f"""ä½ æ˜¯ä¸€ä¸ªçŸ¥è¯†å›¾è°±æ‹“å±•ä¸“å®¶ã€‚ç”¨æˆ·æ­£åœ¨å­¦ä¹ "{context['trigger_node']['name']}"è¿™ä¸ªçŸ¥è¯†ç‚¹ã€‚

## å½“å‰çŸ¥è¯†ç‚¹ä¿¡æ¯
- åç§°ï¼š{context['trigger_node']['name']}
- æè¿°ï¼š{context['trigger_node']['description']}
- æ‰€å±é¢†åŸŸï¼š{context['trigger_node']['sector']}

## ç›¸é‚»çŸ¥è¯†ç‚¹
{chr(10).join([f"- {n['name']} ({n['relation']})" for n in context['neighbor_nodes']])}

## ç”¨æˆ·å·²å­¦ä¹ çš„çŸ¥è¯†ç‚¹
{', '.join(context['already_learned'][:20])}

## ä»»åŠ¡
è¯·æ¨è 3-5 ä¸ªä¸"{context['trigger_node']['name']}"ç›¸å…³çš„ã€ç”¨æˆ·å¯èƒ½æ„Ÿå…´è¶£çš„çŸ¥è¯†ç‚¹ã€‚

è¦æ±‚ï¼š
1. ä¸è¦æ¨èç”¨æˆ·å·²å­¦ä¹ çš„çŸ¥è¯†ç‚¹
2. æ¨èçš„çŸ¥è¯†ç‚¹åº”è¯¥æ˜¯æ¸è¿›å¼çš„ï¼Œä»ç®€å•åˆ°å¤æ‚
3. åŒ…å«ç†è®ºæ·±åŒ–å’Œå®é™…åº”ç”¨ä¸¤ä¸ªæ–¹å‘
4. æ¯ä¸ªçŸ¥è¯†ç‚¹éœ€è¦è¯´æ˜ä¸è§¦å‘çŸ¥è¯†ç‚¹çš„å…³ç³»

## è¾“å‡ºæ ¼å¼ (JSON)
```json{{
"expanded_nodes": [
{{
"name": "çŸ¥è¯†ç‚¹åç§°",
"name_en": "English Name",
"description": "ç®€è¦æè¿° (50å­—ä»¥å†…)",
"importance_level": 3,  // 1-5
"relation_to_trigger": "prerequisite|related|application|evolution",
"relation_strength": 0.8,  // 0-1
"keywords": ["å…³é”®è¯1", "å…³é”®è¯2"]
}}
]
}}

    def _parse_expansion_response(self, response: str) -> dict:
        """è§£æ LLM å“åº”"""
        try:
            data = json.loads(response)
            return data
        except json.JSONDecodeError:
            # å°è¯•æå– JSON å—
            import re
            json_match = re.search(r'```json\s*(.*?)\s*```', response, re.DOTALL)
            if json_match:
                return json.loads(json_match.group(1))
            raise ValueError("Failed to parse LLM response as JSON")

    async def _create_expanded_nodes(
        self,
        expanded_data: dict,
        trigger_node_id: UUID,
        user_id: UUID
    ) -> List[KnowledgeNode]:
        """åˆ›å»ºæ‹“å±•çš„çŸ¥è¯†èŠ‚ç‚¹"""
        trigger_node = await self.db.get(KnowledgeNode, trigger_node_id)
        new_nodes = []
        
        for item in expanded_data.get('expanded_nodes', [])[:self.MAX_EXPANDED_NODES_PER_REQUEST]:
            # æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ (é€šè¿‡åç§°å»é‡)
            existing = await self._find_existing_node(item['name'])
            if existing:
                # å¦‚æœå·²å­˜åœ¨ï¼Œåªåˆ›å»ºå…³ç³»
                await self._ensure_relation(trigger_node_id, existing.id, item)
                continue
            
            # åˆ›å»ºæ–°èŠ‚ç‚¹
            node = KnowledgeNode(
                subject_id=trigger_node.subject_id,
                parent_id=trigger_node_id if item['relation_to_trigger'] == 'composition' else None,
                name=item['name'],
                name_en=item.get('name_en'),
                description=item.get('description'),
                importance_level=item.get('importance_level', 2),
                is_seed=False,
                source_type='llm_expanded',
                keywords=item.get('keywords', []),
            )
            
            # ç”Ÿæˆ embedding
            embed_text = f"{node.name} {node.description or ''}"
            node.embedding = await self.embedding_service.get_embedding(embed_text)
            
            self.db.add(node)
            await self.db.flush()  # è·å– ID
            
            # åˆ›å»ºä¸è§¦å‘èŠ‚ç‚¹çš„å…³ç³»
            relation = NodeRelation(
                source_node_id=trigger_node_id,
                target_node_id=node.id,
                relation_type=item.get('relation_to_trigger', 'related'),
                strength=item.get('relation_strength', 0.5),
                created_by='llm'
            )
            self.db.add(relation)
            
            new_nodes.append(node)
        
        await self.db.commit()
        return new_nodes

    async def _find_existing_node(self, name: str) -> Optional[KnowledgeNode]:
        """æŸ¥æ‰¾æ˜¯å¦å­˜åœ¨åŒåèŠ‚ç‚¹"""
        query = select(KnowledgeNode).where(KnowledgeNode.name == name)
        result = await self.db.execute(query)
        return result.scalar_one_or_none()

    async def _ensure_relation(self, source_id: UUID, target_id: UUID, item: dict):
        """ç¡®ä¿å…³ç³»å­˜åœ¨"""
        query = select(NodeRelation).where(
            NodeRelation.source_node_id == source_id,
            NodeRelation.target_node_id == target_id
        )
        result = await self.db.execute(query)
        if not result.scalar_one_or_none():
            relation = NodeRelation(
                source_node_id=source_id,
                target_node_id=target_id,
                relation_type=item.get('relation_to_trigger', 'related'),
                strength=item.get('relation_strength', 0.5),
                created_by='llm'
            )
            self.db.add(relation)5.3 æ‹“å±• Worker (åå°ä»»åŠ¡)python# backend/app/jobs/expansion_worker.py

import asyncio
from datetime import datetime
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from app.models import NodeExpansionQueue
from app.services.expansion_service import ExpansionService
from app.core.sse import SSEManager


class ExpansionWorker:
    """
    çŸ¥è¯†æ‹“å±•åå° Worker
    
    æŒç»­å¤„ç†æ‹“å±•é˜Ÿåˆ—ä¸­çš„ä»»åŠ¡
    """
    
    POLL_INTERVAL = 5  # ç§’
    BATCH_SIZE = 10
    
    def __init__(
        self,
        db_session_factory,
        expansion_service_factory,
        sse_manager: SSEManager
    ):
        self.db_session_factory = db_session_factory
        self.expansion_service_factory = expansion_service_factory
        self.sse_manager = sse_manager
        self._running = False

    async def start(self):
        """å¯åŠ¨ Worker"""
        self._running = True
        print("Expansion Worker started")
        
        while self._running:
            try:
                await self._process_batch()
            except Exception as e:
                print(f"Expansion Worker error: {e}")
            
            await asyncio.sleep(self.POLL_INTERVAL)

    async def stop(self):
        """åœæ­¢ Worker"""
        self._running = False
        print("Expansion Worker stopped")

    async def _process_batch(self):
        """å¤„ç†ä¸€æ‰¹æ‹“å±•ä»»åŠ¡"""
        async with self.db_session_factory() as db:
            # è·å–å¾…å¤„ç†ä»»åŠ¡
            query = (
                select(NodeExpansionQueue)
                .where(NodeExpansionQueue.status == 'pending')
                .order_by(NodeExpansionQueue.created_at)
                .limit(self.BATCH_SIZE)
            )
            
            result = await db.execute(query)
            pending_tasks = result.scalars().all()
            
            if not pending_tasks:
                return
            
            expansion_service = self.expansion_service_factory(db)
            
            for task in pending_tasks:
                try:
                    new_nodes = await expansion_service.process_expansion(task.id)
                    
                    if new_nodes:
                        # é€šè¿‡ SSE é€šçŸ¥å‰ç«¯
                        await self._notify_expansion(task.user_id, new_nodes)
                        
                except Exception as e:
                    print(f"Failed to process expansion {task.id}: {e}")

    async def _notify_expansion(self, user_id, new_nodes):
        """é€šçŸ¥å‰ç«¯æ–°èŠ‚ç‚¹å·²åˆ›å»º"""
        event_data = {
            "type": "nodes_expanded",
            "nodes": [
                {
                    "id": str(node.id),
                    "name": node.name,
                    "sector_code": node.subject.sector_code if node.subject else "VOID",
                }
                for node in new_nodes
            ],
            "timestamp": datetime.utcnow().isoformat()
        }
        
        await self.sse_manager.send_to_user(user_id, event_data)5.4 å‰ç«¯æ¶Œç°åŠ¨ç”»dart// lib/features/galaxy/presentation/widgets/emergence_animation.dart

import 'package:flutter/material.dart';

/// æ–°èŠ‚ç‚¹æ¶Œç°åŠ¨ç”»
/// 
/// å½“ LLM æ‹“å±•å‡ºæ–°çŸ¥è¯†ç‚¹æ—¶ï¼Œæ’­æ”¾ä»è™šç©ºä¸­æ˜¾ç°çš„åŠ¨ç”»
class EmergenceAnimation extends StatefulWidget {
  final KnowledgeNode node;
  final Offset position;
  final VoidCallback onComplete;
  
  const EmergenceAnimation({
    super.key,
    required this.node,
    required this.position,
    required this.onComplete,
  });

  @override
  State<EmergenceAnimation> createState() => _EmergenceAnimationState();
}

class _EmergenceAnimationState extends State<EmergenceAnimation>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _scaleAnimation;
  late Animation<double> _opacityAnimation;
  late Animation<double> _glowAnimation;

  @override
  void initState() {
    super.initState();
    
    _controller = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 2000),
    );
    
    // ç¼©æ”¾ï¼šä» 0 åˆ° 1.2 å†åˆ° 1
    _scaleAnimation = TweenSequence<double>([
      TweenSequenceItem(
        tween: Tween(begin: 0.0, end: 1.3)
            .chain(CurveTween(curve: Curves.easeOutBack)),
        weight: 60,
      ),
      TweenSequenceItem(
        tween: Tween(begin: 1.3, end: 1.0)
            .chain(CurveTween(curve: Curves.easeInOut)),
        weight: 40,
      ),
    ]).animate(_controller);
    
    // é€æ˜åº¦ï¼šæ¸å…¥
    _opacityAnimation = Tween<double>(begin: 0.0, end: 1.0).animate(
      CurvedAnimation(
        parent: _controller,
        curve: const Interval(0.0, 0.5, curve: Curves.easeIn),
      ),
    );
    
    // å…‰æ™•ï¼šè„‰å†²æ•ˆæœ
    _glowAnimation = TweenSequence<double>([
      TweenSequenceItem(tween: Tween(begin: 0.0, end: 1.0), weight: 30),
      TweenSequenceItem(tween: Tween(begin: 1.0, end: 0.3), weight: 70),
    ]).animate(_controller);
    
    _controller.forward().whenComplete(widget.onComplete);
  }

  @override
  Widget build(BuildContext context) {
    return Positioned(
      left: widget.position.dx - 40,
      top: widget.position.dy - 40,
      child: AnimatedBuilder(
        animation: _controller,
        builder: (context, child) {
          return Transform.scale(
            scale: _scaleAnimation.value,
            child: Opacity(
              opacity: _opacityAnimation.value,
              child: _buildEmergingNode(),
            ),
          );
        },
      ),
    );
  }

  Widget _buildEmergingNode() {
    final color = _getSectorColor(widget.node.sectorCode);
    
    return Container(
      width: 80,
      height: 80,
      decoration: BoxDecoration(
        shape: BoxShape.circle,
        gradient: RadialGradient(
          colors: [
            Colors.white,
            color,
            color.withOpacity(0.5),
            Colors.transparent,
          ],
          stops: const [0.0, 0.3, 0.6, 1.0],
        ),
        boxShadow: [
          BoxShadow(
            color: color.withOpacity(_glowAnimation.value * 0.8),
            blurRadius: 30 * _glowAnimation.value,
            spreadRadius: 10 * _glowAnimation.value,
          ),
        ],
      ),
      child: Center(
        child: AnimatedOpacity(
          duration: const Duration(milliseconds: 500),
          opacity: _controller.value > 0.5 ? 1.0 : 0.0,
          child: Text(
            widget.node.name,
            style: const TextStyle(
              color: Colors.white,
              fontSize: 10,
              fontWeight: FontWeight.w500,
            ),
            textAlign: TextAlign.center,
            maxLines: 2,
            overflow: TextOverflow.ellipsis,
          ),
        ),
      ),
    );
  }

  Color _getSectorColor(String sectorCode) {
    return switch (sectorCode) {
      'COSMOS' => const Color(0xFF00BFFF),
      'TECH' => const Color(0xFFC0C0C0),
      'ART' => const Color(0xFFFF00FF),
      'CIVILIZATION' => const Color(0xFFFFD700),
      'LIFE' => const Color(0xFF32CD32),
      'WISDOM' => const Color(0xFFFFFFFF),
      _ => const Color(0xFF2F4F4F),
    };
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }
}6. ç”¨æˆ·ä½“éªŒè®¾è®¡6.1 ç”¨æˆ·æ—…ç¨‹åœ°å›¾ç¬¬ä¸€æ¬¡æ‰“å¼€æ˜Ÿå›¾                  å®Œæˆç¬¬ä¸€ä¸ªä»»åŠ¡                 æŒç»­å­¦ä¹ 
     â”‚                              â”‚                          â”‚
     â–¼                              â–¼                          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ç©ºçŠ¶æ€å¼•å¯¼  â”‚              â”‚  é¦–æ¬¡ç‚¹äº®    â”‚              â”‚  æ˜Ÿå›¾ç”Ÿé•¿   â”‚
â”‚             â”‚              â”‚             â”‚              â”‚             â”‚
â”‚ â€¢ æ··æ²Œå®‡å®™  â”‚ â”€â”€ä»»åŠ¡å®Œæˆâ”€â”€â†’â”‚ â€¢ é£å‡åŠ¨ç”»  â”‚ â”€â”€æŒç»­å­¦ä¹ â”€â”€â†’â”‚ â€¢ èŠ‚ç‚¹æ‹“å±•  â”‚
â”‚ â€¢ ä¸­å¿ƒç«è‹—  â”‚              â”‚ â€¢ é¦–æ˜Ÿé—ªè€€  â”‚              â”‚ â€¢ æ˜Ÿåº§è¿çº¿  â”‚
â”‚ â€¢ å¼•å¯¼æç¤º  â”‚              â”‚ â€¢ æˆå°±å¼¹çª—  â”‚              â”‚ â€¢ é¢†åŸŸæ‰©å±•  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                                    â–¼
                             â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                             â”‚  å¤ä¹ æé†’   â”‚
                             â”‚             â”‚
                             â”‚ â€¢ æ˜Ÿæ˜Ÿå˜æš—  â”‚
                             â”‚ â€¢ å¤ä¹ å»ºè®®  â”‚
                             â”‚ â€¢ é‡æ–°ç‚¹äº®  â”‚
                             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜6.2 ç©ºçŠ¶æ€è®¾è®¡dart// é¦–æ¬¡è¿›å…¥æ˜Ÿå›¾æ—¶çš„ä½“éªŒ

class GalaxyEmptyState extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Stack(
      children: [
        // 1. æ··æ²ŒèƒŒæ™¯ (æ¯”æ­£å¸¸æ›´æš—æ·¡)
        DeepSpaceBackground(opacity: 0.3),
        
        // 2. 6 ä¸ªæ˜ŸåŸŸè½®å»“ (ä½é€æ˜åº¦ï¼Œè™šçº¿æè¾¹)
        ...SectorCode.values.map((sector) => 
          SectorOutline(
            sector: sector,
            opacity: 0.2,
            style: BorderStyle.dashed,
          ),
        ),
        
        // 3. ä¸­å¿ƒç«è‹— (è¾ƒå°ï¼Œè¾ƒæš—)
        Center(
          child: FlameCore(
            intensity: 0.3,
            size: Size(80, 100),
          ),
        ),
        
        // 4. å¼•å¯¼æ–‡æ¡ˆ
        Positioned(
          bottom: 200,
          left: 0,
          right: 0,
          child: Column(
            children: [
              Text(
                'ä½ çš„çŸ¥è¯†å®‡å®™åˆšåˆšè¯ç”Ÿ',
                style: TextStyle(
                  color: Colors.white.withOpacity(0.9),
                  fontSize: 20,
                  fontWeight: FontWeight.w500,
                ),
              ),
              SizedBox(height: 8),
              Text(
                'å®Œæˆç¬¬ä¸€ä¸ªå­¦ä¹ ä»»åŠ¡ï¼Œç‚¹äº®ä½ çš„ç¬¬ä¸€é¢—æ˜Ÿ',
                style: TextStyle(
                  color: Colors.white.withOpacity(0.6),
                  fontSize: 14,
                ),
              ),
              SizedBox(height: 24),
              // æŒ‡å‘ä»»åŠ¡ Tab çš„ç®­å¤´åŠ¨ç”»
              AnimatedArrow(
                direction: AxisDirection.down,
                color: Colors.amber,
              ),
            ],
          ),
        ),
      ],
    );
  }
}6.3 é¦–æ¬¡ç‚¹äº®ä½“éªŒdart// é¦–æ¬¡ç‚¹äº®ä¸€é¢—æ˜Ÿæ—¶çš„ç‰¹æ®ŠåŠ¨ç”»åºåˆ—

class FirstSparkCelebration extends StatefulWidget {
  final SparkEvent event;
  final VoidCallback onComplete;
  
  @override
  State<FirstSparkCelebration> createState() => _FirstSparkCelebrationState();
}

class _FirstSparkCelebrationState extends State<FirstSparkCelebration> {
  int _step = 0;  // åŠ¨ç”»æ­¥éª¤

  @override
  void initState() {
    super.initState();
    _playSequence();
  }

  Future<void> _playSequence() async {
    // Step 1: ç«è‹—å¢å¼º (0.5s)
    setState(() => _step = 1);
    await Future.delayed(Duration(milliseconds: 500));
    
    // Step 2: ç²’å­å–·å°„ (1.5s)
    setState(() => _step = 2);
    await Future.delayed(Duration(milliseconds: 1500));
    
    // Step 3: æ˜Ÿæ˜Ÿç‚¹äº® + Bloom (0.8s)
    setState(() => _step = 3);
    await Future.delayed(Duration(milliseconds: 800));
    
    // Step 4: ç›¸æœºèšç„¦åˆ°æ–°æ˜Ÿ (0.5s)
    setState(() => _step = 4);
    await Future.delayed(Duration(milliseconds: 500));
    
    // Step 5: æˆå°±å¼¹çª—
    setState(() => _step = 5);
    
    // æ˜¾ç¤ºæˆå°±å¼¹çª—
    _showAchievementDialog();
  }

  void _showAchievementDialog() {
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => AchievementDialog(
        title: 'ğŸŒŸ ç¬¬ä¸€é¢—æ˜Ÿ',
        subtitle: 'ä½ ç‚¹äº®äº† "${widget.event.nodeName}"',
        description: 'ç»§ç»­æ¢ç´¢æ›´å¤šçŸ¥è¯†é¢†åŸŸï¼Œè®©ä½ çš„å®‡å®™æ›´åŠ ç’€ç’¨ï¼',
        onDismiss: () {
          Navigator.pop(context);
          widget.onComplete();
        },
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    // æ ¹æ® _step è¿”å›å¯¹åº”åŠ¨ç”»ç»„ä»¶
    return Stack(
      children: [
        // ç«è‹—å¢å¼º
        if (_step >= 1)
          FlameCore(intensity: _step >= 2 ? 1.0 : 0.7),
        
        // ç²’å­å–·å°„
        if (_step >= 2)
          ParticleLayer(
            particles: _generateFirstSparkParticles(),
            count: 30,  // é¦–æ¬¡ç‚¹äº®æ›´å¤šç²’å­
          ),
        
        // å±å¹•é—ªå…‰
        if (_step == 3)
          AnimatedOpacity(
            duration: Duration(milliseconds: 200),
            opacity: _step == 3 ? 0.3 : 0.0,
            child: Container(color: Colors.white),
          ),
      ],
    );
  }
}6.4 èŠ‚ç‚¹è¯¦æƒ…é¢æ¿dart// ç‚¹å‡»æ˜Ÿæ˜Ÿåæ˜¾ç¤ºçš„åº•éƒ¨é¢æ¿

class NodeDetailSheet extends StatelessWidget {
  final KnowledgeNode node;
  
  @override
  Widget build(BuildContext context) {
    return DraggableScrollableSheet(
      initialChildSize: 0.4,
      minChildSize: 0.2,
      maxChildSize: 0.9,
      builder: (context, scrollController) {
        return Container(
          decoration: BoxDecoration(
            color: Color(0xFF1A1A2E),
            borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
            boxShadow: [
              BoxShadow(
                color: _getSectorColor(node.sectorCode).withOpacity(0.3),
                blurRadius: 20,
                offset: Offset(0, -5),
              ),
            ],
          ),
          child: ListView(
            controller: scrollController,
            padding: EdgeInsets.all(20),
            children: [
              // æ‹–åŠ¨æŒ‡ç¤ºå™¨
              Center(
                child: Container(
                  width: 40,
                  height: 4,
                  decoration: BoxDecoration(
                    color: Colors.white30,
                    borderRadius: BorderRadius.circular(2),
                  ),
                ),
              ),
              SizedBox(height: 20),
              
              // èŠ‚ç‚¹æ ‡é¢˜
              Row(
                children: [
                  // çŠ¶æ€æŒ‡ç¤ºå™¨
                  _StatusIndicator(status: node.userStatus?.status),
                  SizedBox(width: 12),
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          node.name,
                          style: TextStyle(
                            color: Colors.white,
                            fontSize: 20,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                        if (node.nameEn != null)
                          Text(
                            node.nameEn!,
                            style: TextStyle(
                              color: Colors.white60,
                              fontSize: 14,
                            ),
                          ),
                      ],
                    ),
                  ),
                  // æ”¶è—æŒ‰é’®
                  IconButton(
                    icon: Icon(
                      node.userStatus?.isFavorite == true
                          ? Icons.star
                          : Icons.star_border,
                      color: Colors.amber,
                    ),
                    onPressed: () => _toggleFavorite(context),
                  ),
                ],
              ),
              SizedBox(height: 16),
              
              // æŒæ¡åº¦è¿›åº¦
              if (node.userStatus != null) ...[
                _MasteryProgress(
                  status: node.userStatus!,
                  sectorColor: _getSectorColor(node.sectorCode),
                ),
                SizedBox(height: 16),
              ],
              
              // æè¿°
              if (node.description != null) ...[
                Text(
                  node.description!,
                  style: TextStyle(
                    color: Colors.white70,
                    fontSize: 14,
                    height: 1.6,
                  ),
                ),
                SizedBox(height: 16),
              ],
              
              // å­¦ä¹ ç»Ÿè®¡
              if (node.userStatus?.isUnlocked == true)
                _StudyStats(status: node.userStatus!),
              
              // ç›¸å…³çŸ¥è¯†ç‚¹
              SizedBox(height: 24),
              _RelatedNodes(nodeId: node.id),
              
              // æ“ä½œæŒ‰é’®
              SizedBox(height: 24),
              Row(
                children: [
                  Expanded(
                    child: ElevatedButton.icon(
                      onPressed: () => _startStudy(context, node),
                      icon: Icon(Icons.play_arrow),
                      label: Text('å¼€å§‹å­¦ä¹ '),
                      style: ElevatedButton.styleFrom(
                        backgroundColor: _getSectorColor(node.sectorCode),
                        padding: EdgeInsets.symmetric(vertical: 12),
                      ),
                    ),
                  ),
                  SizedBox(width: 12),
                  OutlinedButton.icon(
                    onPressed: () => _showDetails(context, node),
                    icon: Icon(Icons.info_outline),
                    label: Text('è¯¦æƒ…'),
                    style: OutlinedButton.styleFrom(
                      foregroundColor: Colors.white70,
                      side: BorderSide(color: Colors.white30),
                      padding: EdgeInsets.symmetric(vertical: 12),
                    ),
                  ),
                ],
              ),
            ],
          ),
        );
      },
    );
  }
}


class _MasteryProgress extends StatelessWidget {
  final UserNodeStatus status;
  final Color sectorColor;
  
  @override
  Widget build(BuildContext context) {
    final nextLevel = _getNextLevelInfo(status.masteryScore);
    
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Text(
              'æŒæ¡åº¦',
              style: TextStyle(color: Colors.white60, fontSize: 12),
            ),
            Text(
              '${status.masteryScore.toInt()}%',
              style: TextStyle(
                color: sectorColor,
                fontSize: 14,
                fontWeight: FontWeight.bold,
              ),
            ),
          ],
        ),
        SizedBox(height: 8),
        Stack(
          children: [
            // èƒŒæ™¯
            Container(
              height: 8,
              decoration: BoxDecoration(
                color: Colors.white10,
                borderRadius: BorderRadius.circular(4),
              ),
            ),
            // è¿›åº¦
            FractionallySizedBox(
              widthFactor: status.masteryScore / 100,
              child: Container(
                height: 8,
                decoration: BoxDecoration(
                  gradient: LinearGradient(
                    colors: [sectorColor.withOpacity(0.7), sectorColor],
                  ),
                  borderRadius: BorderRadius.circular(4),
                  boxShadow: [
                    BoxShadow(
                      color: sectorColor.withOpacity(0.5),
                      blurRadius: 8,
                    ),
                  ],
                ),
              ),
            ),
          ],
        ),
        SizedBox(height: 8),
        if (nextLevel != null)
          Text(
            nextLevel,
            style: TextStyle(color: Colors.white38, fontSize: 11),
          ),
      ],
    );
  }
  
  String? _getNextLevelInfo(double score) {
    if (score < 30) return 'å†å­¦ä¹  ${((30 - score) / 5).ceil()} æ¬¡è¾¾åˆ°ã€Œé—ªè€€ã€';
    if (score < 80) return 'å†å­¦ä¹  ${((80 - score) / 5).ceil()} æ¬¡è¾¾åˆ°ã€Œç’€ç’¨ã€';
    if (score < 95) return 'å†å­¦ä¹  ${((95 - score) / 5).ceil()} æ¬¡è¾¾åˆ°ã€Œç²¾é€šã€';
    return 'å·²è¾¾åˆ°æœ€é«˜å¢ƒç•Œ âœ¨';
  }
}6.5 å¤ä¹ æé†’ç³»ç»Ÿdart// å¤ä¹ æé†’å¡ç‰‡

class ReviewReminderCard extends StatelessWidget {
  final List<ReviewSuggestion> suggestions;
  
  @override
  Widget build(BuildContext context) {
    if (suggestions.isEmpty) return SizedBox.shrink();
    
    return Card(
      color: Color(0xFF1A1A2E),
      margin: EdgeInsets.all(16),
      child: Padding(
        padding: EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Icon(Icons.wb_twilight, color: Colors.amber, size: 20),
                SizedBox(width: 8),
                Text(
                  'çŸ¥è¯†éœ€è¦æ¸©æ•…',
                  style: TextStyle(
                    color: Colors.white,
                    fontSize: 16,
                    fontWeight: FontWeight.w500,
                  ),
                ),
                Spacer(),
                Text(
                  '${suggestions.length} ä¸ªçŸ¥è¯†ç‚¹å˜æš—äº†',
                  style: TextStyle(color: Colors.white60, fontSize: 12),
                ),
              ],
            ),
            SizedBox(height: 12),
            
            // æ˜¾ç¤ºå‰ 3 ä¸ªéœ€è¦å¤ä¹ çš„çŸ¥è¯†ç‚¹
            ...suggestions.take(3).map((s) => _ReviewItem(suggestion: s)),
            
            if (suggestions.length > 3) ...[
              SizedBox(height: 8),
              TextButton(
                onPressed: () => _showAllReviews(context),
                child: Text('æŸ¥çœ‹å…¨éƒ¨ ${suggestions.length} ä¸ª'),
              ),
            ],
          ],
        ),
      ),
    );
  }
}


class _ReviewItem extends StatelessWidget {
  final ReviewSuggestion suggestion;
  
  @override
  Widget build(BuildContext context) {
    final isUrgent = suggestion.urgency == 'high';
    
    return Padding(
      padding: EdgeInsets.symmetric(vertical: 6),
      child: Row(
        children: [
          // æš—æ·¡çš„æ˜Ÿæ˜Ÿå›¾æ ‡
          Container(
            width: 24,
            height: 24,
            decoration: BoxDecoration(
              shape: BoxShape.circle,
              color: _getSectorColor(suggestion.sectorCode).withOpacity(0.3),
            ),
            child: Center(
              child: Icon(
                Icons.star,
                size: 14,
                color: isUrgent ? Colors.red[300] : Colors.grey,
              ),
            ),
          ),
          SizedBox(width: 12),
          
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  suggestion.nodeName,
                  style: TextStyle(color: Colors.white, fontSize: 14),
                ),
                Text(
                  '${suggestion.daysSinceStudy} å¤©å‰å­¦ä¹  Â· æŒæ¡åº¦ ${suggestion.currentMastery.toInt()}%',
                  style: TextStyle(color: Colors.white38, fontSize: 11),
                ),
              ],
            ),
          ),
          
          // å¿«é€Ÿå¤ä¹ æŒ‰é’®
          TextButton(
            onPressed: () => _quickReview(context, suggestion),
            child: Text(
              'å¤ä¹ ',
              style: TextStyle(
                color: isUrgent ? Colors.amber : Colors.white60,
              ),
            ),
          ),
        ],
      ),
    );
  }
}6.6 æˆå°±ç³»ç»Ÿè®¾è®¡dart// æˆå°±å®šä¹‰

enum GalaxyAchievement {
  firstStar(
    id: 'first_star