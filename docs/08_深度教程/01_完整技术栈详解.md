# 完整技术栈详解 (Full Stack Deep Dive)

## 1. 导论：为何选择混合架构？

Sparkle 项目经历了一次重大的架构演进，从最初的 Python 单体应用（MVP v0.1）进化为目前的 **Flutter + Go Gateway + Python Engine** 混合微服务架构（v0.3.0）。

### 1.1 架构演进的动力
- **实时性需求**: 聊天打字机效果、状态同步需要高并发长连接，Python (GIL) 在处理海量 WebSocket 连接时显得力不从心。
- **计算密集型任务**: 向量检索、LLM 推理是 CPU/GPU 密集型，需要与 I/O 密集型任务隔离。
- **开发效率**: Flutter 的声明式 UI 和热重载极大提升了客户端开发效率；Python 拥有最丰富的 AI 生态（LangChain, NumPy）。

### 1.2 最终形态
我们选择了 **"各取所长"** 的策略：
- **Go**: 负责接入层（网关），抗高并发，管理连接。
- **Python**: 负责智能层（大脑），处理复杂的 AI 逻辑。
- **Flutter**: 负责表现层（终端），提供极致的交互体验。

---

## 2. 移动端 (Mobile): Flutter & Riverpod

### 2.1 架构模式: Feature-First + Repository Pattern
代码组织不再按层分（View/Model/Controller），而是按**功能特性 (Feature)** 分：
```
mobile/lib/features/
  ├── auth/         # 认证模块
  ├── chat/         # 聊天模块
  │   ├── data/     # 数据层 (Repository, DTO)
  │   ├── domain/   # 领域层 (Entity)
  │   └── presentation/ # 表现层 (Widget, Provider)
  └── galaxy/       # 星图模块
```

### 2.2 状态管理: Riverpod 2.0
我们全面使用 `NotifierProvider` 和 `AsyncNotifierProvider`。

- **全局状态**: `userProvider`, `themeProvider`
- **局部状态**: `chatProvider` (负责单个会话的消息流)

### 2.3 关键技术点
- **WebSocketService**: 封装了指数退避重连机制，确保弱网下的连接稳定性。
- **Design System V2**: 基于 `MaterialStyler` 的渲染引擎，实现了 `NeoGlass` 等高级材质。
- **PerformanceService**: 动态监控 FPS，自动降级渲染质量以适配低端机型。

---

## 3. 接入层 (Gateway): Go & Gin

### 3.1 核心职责
Go Gateway 是系统的**守门人**，它对外暴露 HTTP 和 WebSocket 接口，对内通过 gRPC 与 AI 引擎通信。

### 3.2 WebSocket 架构
使用了 `Gorilla WebSocket` 库。
- **ReadPump**: 每个连接一个 Goroutine 读取客户端消息。
- **WritePump**: 每个连接一个 Goroutine 推送消息给客户端。
- **Orchestrator**: 协调器，将接收到的 WS 消息转换为 gRPC 请求发送给 Python 服务，并将 gRPC 的流式响应转发回 WS 通道。

### 3.3 性能优化
- **对象池 (`sync.Pool`)**: 复用 `chatInput` 结构体和缓冲区，减少 GC 压力。
- **连接复用**: 对 gRPC Client 使用单例长连接，避免频繁握手。

---

## 4. 智能层 (Engine): Python & FastAPI

### 4.1 核心职责
AI Engine 是系统的**大脑**，不直接面对用户，只处理经过网关清洗和验证的请求。

### 4.2 异步任务: Celery
对于耗时超过 500ms 的任务，一律异步化：
- **高优先级**: 生成 Embedding（影响搜索）。
- **默认优先级**: 批量错题分析。
- **低优先级**: 数据清理。

### 4.3 数据存储: PostgreSQL + pgvector
- **关系数据**: 用户、任务、聊天记录。
- **向量数据**: `embedding` 字段存储 1536 维向量，使用 HNSW 索引加速 ANN 搜索。
- **SQLAlchemy 2.0**: 全面使用 Async Session。

---

## 5. 全链路通信流 (End-to-End Flow)

以"用户发送一条消息"为例：

1.  **Mobile**:
    -   用户点击发送 -> `ChatNotifier` 乐观更新 UI。
    -   `WebSocketService` 发送 JSON: `{"type":"message", "content":"..."}`。
2.  **Gateway**:
    -   `ReadPump` 收到消息 -> 解析 JSON。
    -   `ChatOrchestrator` 获取当前用户 Context (从 Redis/DB)。
    -   调用 gRPC `agent_client.StreamChat(req)`。
3.  **Engine**:
    -   gRPC Server 收到请求 -> 启动 `LangChain` Agent。
    -   Agent 思考 -> 生成 `ReasoningStep`。
    -   Agent 调用工具 -> 生成 `ToolStart` / `ToolResult`。
    -   Agent 生成回复 -> 生成 `Delta` 文本。
    -   以上所有事件通过 `yield` 写入 gRPC 响应流。
4.  **Gateway**:
    -   `Recv()` 循环读取 gRPC 流。
    -   将 Protobuf 对象转换为 JSON。
    -   `WritePump` 将 JSON 推送回 WebSocket。
5.  **Mobile**:
    -   `WebSocketService` 收到 JSON。
    -   `ChatNotifier` 根据 `type` 更新状态 (追加文本、显示卡片)。

---

## 6. 调试与运维

### 6.1 本地调试技巧
- **三终端启动法**: 分别启动 Infrastructure, Python, Go，便于查看各自日志。
- **gRPC 调试**: 使用 `Postman` 或 `grpcurl` 直接测试 Python gRPC 接口，排除网关干扰。

### 6.2 生产运维
- **Docker Compose**: 使用 `.env.production` 控制配置。
- **监控**: Grafana 面板能看到 Go 的 Goroutine 数和 Python 的 Celery 队列长度，这是判断系统负载的两个关键指标。

---

*文档维护者: Architecture Team*
*最后更新: 2026-01-10*
