# Sparkle AI Learning Assistant - æ·±åº¦æŠ€æœ¯è®²è§£æ–‡æ¡£ï¼ˆå¢å¼ºç‰ˆï¼‰

> **æ–‡æ¡£ç‰ˆæœ¬**: v2.0 å¢å¼ºç‰ˆ
> **ç¼–å†™æ—¥æœŸ**: 2025-12-27
> **ç”Ÿäº§å°±ç»ªåº¦**: 9.5/10
> **ç›®æ ‡è¯»è€…**: ä»é›¶åŸºç¡€åˆ°é«˜çº§å·¥ç¨‹å¸ˆ
> **å­¦ä¹ è·¯å¾„**: ä»£ç æ³¨é‡Š + ç¼–ç¨‹æ€æƒ³ + è¯„å§”è€ƒå¯Ÿç‚¹

---

## ğŸ“‹ ç›®å½•

1. [ç³»ç»Ÿæ¶æ„å…¨æ™¯](#1-ç³»ç»Ÿæ¶æ„å…¨æ™¯)
2. [Go Gateway - é«˜æ€§èƒ½ç½‘å…³å±‚](#2-go-gateway---é«˜æ€§èƒ½ç½‘å…³å±‚)
3. [Python Agent Engine - AI æ ¸å¿ƒå¼•æ“](#3-python-agent-engine---ai-æ ¸å¿ƒå¼•æ“)
4. [Flutter Mobile - è·¨å¹³å°ç§»åŠ¨ç«¯](#4-flutter-mobile---è·¨å¹³å°ç§»åŠ¨ç«¯)
5. [æ•°æ®åº“æ¶æ„æ·±åº¦è§£æ](#5-æ•°æ®åº“æ¶æ„æ·±åº¦è§£æ)
6. [æ ¸å¿ƒåŠŸèƒ½å®ç°è¯¦è§£](#6-æ ¸å¿ƒåŠŸèƒ½å®ç°è¯¦è§£)
7. [ç”Ÿäº§çº§ç‰¹æ€§ä¸å¢å¼º](#7-ç”Ÿäº§çº§ç‰¹æ€§ä¸å¢å¼º)
8. [å®Œæ•´è¯·æ±‚æµç¨‹è¿½è¸ª](#8-å®Œæ•´è¯·æ±‚æµç¨‹è¿½è¸ª)
9. [æ€§èƒ½ä¼˜åŒ–ä¸æœ€ä½³å®è·µ](#9-æ€§èƒ½ä¼˜åŒ–ä¸æœ€ä½³å®è·µ)
10. [é¢è¯•å¸¸è§é—®é¢˜è§£ç­”](#10-é¢è¯•å¸¸è§é—®é¢˜è§£ç­”)

---

## 1. ç³»ç»Ÿæ¶æ„å…¨æ™¯

### 1.1 é«˜å±‚æ¶æ„è®¾è®¡

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Sparkle AI Learning Assistant                     â”‚
â”‚                  æ˜Ÿç« - AI å¤§å­¦ç”Ÿå­¦ä¹ è¾…åŠ©ç³»ç»Ÿ                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    WebSocket    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    gRPC      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚              â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚              â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚              â”‚ â”‚
â”‚  â”‚ Flutter App  â”‚    (8080)       â”‚ Go Gateway   â”‚  (50051)     â”‚ Python Agent â”‚ â”‚
â”‚  â”‚              â”‚                 â”‚              â”‚              â”‚   Engine     â”‚ â”‚
â”‚  â”‚  Riverpod    â”‚                 â”‚  Gin +       â”‚              â”‚              â”‚ â”‚
â”‚  â”‚  State Mgmt  â”‚                 â”‚  WebSocket   â”‚              â”‚  FastAPI     â”‚ â”‚
â”‚  â”‚  Hive/SQLite â”‚                 â”‚  + Auth      â”‚              â”‚  + Orchestrationâ”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚         â–²                                â”‚                              â”‚         â”‚
â”‚         â”‚                                â”‚                              â”‚         â”‚
â”‚         â”‚                                â–¼                              â–¼         â”‚
â”‚         â”‚                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚         â”‚                        â”‚   Redis      â”‚              â”‚ PostgreSQL   â”‚ â”‚
â”‚         â”‚                        â”‚  (Sessions,  â”‚              â”‚  + pgvector  â”‚ â”‚
â”‚         â”‚                        â”‚   Cache,     â”‚              â”‚              â”‚
â”‚         â”‚                        â”‚   Queues)    â”‚              â”‚              â”‚ â”‚
â”‚         â”‚                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚         â”‚                                â–²                              â–²         â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚                                    Internal Communication                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ã€æ¶æ„æ€æƒ³è®²è§£ã€‘**

è¿™ä¸ªæ¶æ„ä½“ç°äº†**åˆ†å±‚è®¾è®¡**å’Œ**èŒè´£åˆ†ç¦»**çš„æ ¸å¿ƒæ€æƒ³ï¼š

1. **å‰ç«¯å±‚ (Flutter)**: åªè´Ÿè´£ç”¨æˆ·äº¤äº’å’Œç•Œé¢å±•ç¤º
2. **ç½‘å…³å±‚ (Go)**: å¤„ç†è¿æ¥ã€è®¤è¯ã€é™æµï¼ˆç½‘ç»œå±‚ï¼‰
3. **ä¸šåŠ¡å±‚ (Python)**: AI é€»è¾‘ã€å·¥å…·è°ƒç”¨ï¼ˆä¸šåŠ¡å±‚ï¼‰
4. **æ•°æ®å±‚ (DB/Cache)**: æŒä¹…åŒ–å­˜å‚¨å’Œé«˜é€Ÿç¼“å­˜

**ã€å‰åç«¯äº¤äº’æ€æƒ³ã€‘**
- **å‰ç«¯ â†’ åç«¯**: WebSocket é•¿è¿æ¥ï¼Œå®æ—¶åŒå‘é€šä¿¡
- **Go â†’ Python**: gRPC çŸ­è¿æ¥ï¼Œé«˜æ•ˆäºŒè¿›åˆ¶ä¼ è¾“
- **Python â†’ DB**: å¼‚æ­¥è¿æ¥ï¼Œé¿å…é˜»å¡

**ã€è¯„å§”è€ƒå¯Ÿç‚¹ã€‘**
- Q: ä¸ºä»€ä¹ˆç”¨ WebSocket è€Œä¸æ˜¯ HTTP çŸ­è½®è¯¢ï¼Ÿ
  - A: WebSocket å»ºç«‹ä¸€æ¬¡è¿æ¥åå¯å¤ç”¨ï¼Œå‡å°‘æ¡æ‰‹å¼€é”€ï¼Œé€‚åˆå®æ—¶å¯¹è¯åœºæ™¯
- Q: ä¸ºä»€ä¹ˆ Go å’Œ Python è¦åˆ†å¼€ï¼Ÿ
  - A: Go æ“…é•¿é«˜å¹¶å‘ç½‘ç»œï¼ŒPython æ“…é•¿ AI ç”Ÿæ€ï¼Œå„å–æ‰€é•¿

---

## 2. Go Gateway - é«˜æ€§èƒ½ç½‘å…³å±‚

### 2.1 WebSocket å¤„ç†å™¨æ·±åº¦è§£æ

#### 2.2.1 è¿æ¥ç”Ÿå‘½å‘¨æœŸç®¡ç†

```go
// backend/gateway/internal/handler/chat_orchestrator.go

// ChatHandler ç»“æ„ä½“ï¼šç®¡ç† WebSocket è¿æ¥çš„æ‰€æœ‰ä¾èµ–æœåŠ¡
// ç¼–ç¨‹æ€æƒ³ï¼šä¾èµ–æ³¨å…¥ï¼ˆDependency Injectionï¼‰ï¼Œæ‰€æœ‰å¤–éƒ¨ä¾èµ–é€šè¿‡ç»“æ„ä½“å­—æ®µä¼ å…¥
type ChatHandler struct {
    grpcClient   pb.AgentServiceClient  // gRPC å®¢æˆ·ç«¯ï¼Œç”¨äºè°ƒç”¨ Python æœåŠ¡
    redisClient  *redis.Client          // Redis å®¢æˆ·ç«¯ï¼Œç”¨äºä¼šè¯ç®¡ç†å’Œç¼“å­˜
    sessionMgr   *SessionManager        // ä¼šè¯ç®¡ç†å™¨ï¼Œç»´æŠ¤è¿æ¥æ˜ å°„
    quotaService *QuotaService          // é…é¢æœåŠ¡ï¼Œæ§åˆ¶ç”¨æˆ·è¯·æ±‚é¢‘ç‡
}

// HandleWebSocketï¼šWebSocket ä¸»å¤„ç†å‡½æ•°
// å‚æ•°ï¼šconn - WebSocket è¿æ¥å¯¹è±¡ï¼ŒuserID - ç”¨æˆ·å”¯ä¸€æ ‡è¯†
// è¿”å›ï¼šæ— ï¼ˆå‡½æ•°åœ¨è¿æ¥æ–­å¼€æ—¶è¿”å›ï¼‰
func (h *ChatHandler) HandleWebSocket(conn *websocket.Conn, userID string) {
    // ã€æ­¥éª¤1ã€‘è¿æ¥å»ºç«‹ä¸è®¤è¯
    // ç¼–ç¨‹æ€æƒ³ï¼šä¼šè¯éš”ç¦»ï¼Œæ¯ä¸ªç”¨æˆ·è¿æ¥éƒ½æœ‰ç‹¬ç«‹çš„ä¼šè¯ID
    // è¯„å§”è€ƒå¯Ÿï¼šå¦‚ä½•ä¿è¯ä¼šè¯ä¸å†²çªï¼Ÿ
    sessionID := h.sessionMgr.CreateSession(userID)

    // ã€æ­¥éª¤2ã€‘æ³¨å†Œè¿æ¥åˆ°ä¼šè¯ç®¡ç†å™¨
    // ç¼–ç¨‹æ€æƒ³ï¼šèµ„æºç®¡ç†ï¼Œä½¿ç”¨ defer ç¡®ä¿è¿æ¥æ–­å¼€æ—¶æ¸…ç†èµ„æº
    // è¯„å§”è€ƒå¯Ÿï¼šä¸ºä»€ä¹ˆç”¨ deferï¼Ÿå¦‚æœä¸æ¸…ç†ä¼šæœ‰ä»€ä¹ˆåæœï¼Ÿ
    h.sessionMgr.Register(sessionID, conn)
    defer h.sessionMgr.Unregister(sessionID)  // defer ä¿è¯å‡½æ•°é€€å‡ºæ—¶æ‰§è¡Œ

    // ã€æ­¥éª¤3ã€‘å¯åŠ¨å¿ƒè·³åç¨‹ï¼ˆgoroutineï¼‰
    // ç¼–ç¨‹æ€æƒ³ï¼šå¹¶å‘ç¼–ç¨‹ï¼Œä½¿ç”¨ goroutine å®ç°éé˜»å¡
    // è¯„å§”è€ƒå¯Ÿï¼šgoroutine å’Œçº¿ç¨‹çš„åŒºåˆ«ï¼Ÿä¸ºä»€ä¹ˆè¿™é‡Œç”¨ goroutineï¼Ÿ
    go h.heartbeat(conn, sessionID)

    // ã€æ­¥éª¤4ã€‘æ¶ˆæ¯å¾ªç¯ï¼ˆé˜»å¡å¼è¯»å–ï¼‰
    // ç¼–ç¨‹æ€æƒ³ï¼šäº‹ä»¶é©±åŠ¨ï¼Œä¸æ–­ç›‘å¬å®¢æˆ·ç«¯æ¶ˆæ¯
    // è¯„å§”è€ƒå¯Ÿï¼šfor å¾ªç¯å¦‚ä½•é€€å‡ºï¼Ÿbreak å’Œ return çš„åŒºåˆ«ï¼Ÿ
    for {
        var msg ChatMessage
        // è¯»å– JSON æ¶ˆæ¯ï¼Œå¦‚æœå‡ºé”™ï¼ˆè¿æ¥æ–­å¼€ï¼‰åˆ™é€€å‡ºå¾ªç¯
        if err := conn.ReadJSON(&msg); err != nil {
            h.handleError(sessionID, err)
            break  // è·³å‡º for å¾ªç¯ï¼Œå‡½æ•°è¿”å›
        }

        // ã€æ­¥éª¤5ã€‘é…é¢æ£€æŸ¥ï¼ˆé™æµï¼‰
        // ç¼–ç¨‹æ€æƒ³ï¼šé˜²å¾¡æ€§ç¼–ç¨‹ï¼Œé˜²æ­¢æ¶æ„è¯·æ±‚è€—å°½èµ„æº
        // è¯„å§”è€ƒå¯Ÿï¼šé…é¢æœåŠ¡å¦‚ä½•å®ç°ï¼ŸRedis è¿˜æ˜¯æ•°æ®åº“ï¼Ÿ
        if !h.quotaService.CheckQuota(userID) {
            conn.WriteJSON(QuotaExceededResponse)
            break  // é…é¢è¶…é™ï¼Œæ–­å¼€è¿æ¥
        }

        // ã€æ­¥éª¤6ã€‘è½¬å‘åˆ° gRPC æœåŠ¡ï¼ˆæ ¸å¿ƒä¸šåŠ¡é€»è¾‘ï¼‰
        // ç¼–ç¨‹æ€æƒ³ï¼šç½‘å…³æ¨¡å¼ï¼Œåªåšè·¯ç”±å’Œè½¬å‘ï¼Œä¸å¤„ç†ä¸šåŠ¡
        // è¯„å§”è€ƒå¯Ÿï¼šgRPC å’Œ REST API çš„åŒºåˆ«ï¼Ÿä¸ºä»€ä¹ˆç”¨ gRPCï¼Ÿ
        response, err := h.forwardToPython(userID, sessionID, msg)
        if err != nil {
            // é”™è¯¯å¤„ç†ï¼šè¿”å›é”™è¯¯ç ï¼Œä½†ä¸ä¸­æ–­è¿æ¥ï¼ˆcontinueï¼‰
            conn.WriteJSON(ErrorResponse{Code: "GRPC_ERROR"})
            continue  // ç»§ç»­ç›‘å¬ä¸‹ä¸€æ¡æ¶ˆæ¯
        }

        // ã€æ­¥éª¤7ã€‘æµå¼è¿”å›ï¼ˆServer Pushï¼‰
        // ç¼–ç¨‹æ€æƒ³ï¼šæµå¼å¤„ç†ï¼Œé€æ­¥è¿”å›ç»“æœï¼Œå‡å°‘ç”¨æˆ·ç­‰å¾…
        // è¯„å§”è€ƒå¯Ÿï¼šå¦‚ä½•å®ç°æµå¼ï¼Ÿå’Œä¸€æ¬¡æ€§è¿”å›çš„åŒºåˆ«ï¼Ÿ
        for _, chunk := range response {
            if err := conn.WriteJSON(chunk); err != nil {
                break  // å†™å…¥å¤±è´¥ï¼Œé€€å‡ºå†…å±‚å¾ªç¯
            }
        }
    }
}
```

**ã€ç¼–ç¨‹æ€æƒ³æ€»ç»“ã€‘**
1. **ä¾èµ–æ³¨å…¥**: æ‰€æœ‰æœåŠ¡é€šè¿‡ç»“æ„ä½“å­—æ®µä¼ å…¥ï¼Œä¾¿äºæµ‹è¯•å’Œæ›¿æ¢
2. **èµ„æºç®¡ç†**: defer ç¡®ä¿èµ„æºæ¸…ç†ï¼Œé˜²æ­¢å†…å­˜æ³„æ¼
3. **å¹¶å‘ç¼–ç¨‹**: goroutine å®ç°å¿ƒè·³ï¼Œä¸é˜»å¡ä¸»æµç¨‹
4. **äº‹ä»¶é©±åŠ¨**: for å¾ªç¯ç›‘å¬æ¶ˆæ¯ï¼Œå“åº”å¼ç¼–ç¨‹
5. **é˜²å¾¡æ€§ç¼–ç¨‹**: é…é¢æ£€æŸ¥ã€é”™è¯¯å¤„ç†ï¼Œä¿è¯ç³»ç»Ÿç¨³å®š
6. **æµå¼å¤„ç†**: é€æ­¥è¿”å›ï¼Œæå‡ç”¨æˆ·ä½“éªŒ

**ã€å‰åç«¯æ•°æ®æµã€‘**
```
Flutter: å‘é€ JSON â†’ Go: conn.ReadJSON() â†’ è§£æä¸º ChatMessage
         â†“
Go: quotaService.CheckQuota() â†’ Redis æŸ¥è¯¢é…é¢
         â†“
Go: forwardToPython() â†’ gRPC è°ƒç”¨ Python
         â†“
Python: å¤„ç† â†’ è¿”å›æµå¼ chunks
         â†“
Go: for å¾ªç¯ â†’ conn.WriteJSON() â†’ Flutter é€å—æ˜¾ç¤º
```

**ã€è¯„å§”å¯èƒ½é—®ã€‘**
- Q: `defer h.sessionMgr.Unregister(sessionID)` ä¸ºä»€ä¹ˆèƒ½ä¿è¯æ¸…ç†ï¼Ÿ
  - A: defer ä¼šåœ¨å‡½æ•° returnã€panic æˆ–æ‰§è¡Œå®Œæ—¶è§¦å‘ï¼Œå³ä½¿ä¸­é—´æœ‰ break ä¹Ÿä¼šæ‰§è¡Œ
- Q: `go h.heartbeat()` è¿™ä¸ª goroutine ä¼šæ³„æ¼å—ï¼Ÿ
  - A: ä¸ä¼šï¼Œå½“ä¸»è¿æ¥æ–­å¼€æ—¶ï¼Œå¿ƒè·³å‡½æ•°ä¸­çš„ conn.WriteControl ä¼šå¤±è´¥ï¼Œgoroutine è‡ªç„¶é€€å‡º
- Q: å¦‚æœ Python æœåŠ¡æŒ‚äº†ï¼ŒGo ä¼šæ€ä¹ˆå¤„ç†ï¼Ÿ
  - A: forwardToPython è¿”å›é”™è¯¯ï¼ŒGo å†™å…¥é”™è¯¯æ¶ˆæ¯ç»™å®¢æˆ·ç«¯ï¼Œä½†ä¸ä¸­æ–­è¿æ¥

---

#### 2.2.2 å¿ƒè·³æœºåˆ¶ï¼ˆé˜²æ–­è¿ï¼‰

```go
func (h *ChatHandler) heartbeat(conn *websocket.Conn, sessionID string) {
    // ã€æ­¥éª¤1ã€‘åˆ›å»ºå®šæ—¶å™¨ï¼ˆTickerï¼‰
    // ç¼–ç¨‹æ€æƒ³ï¼šæ—¶é—´é©±åŠ¨ï¼Œå®šæœŸæ‰§è¡Œä»»åŠ¡
    // å‚æ•°ï¼š30ç§’é—´éš”ï¼Œå¯æ ¹æ®å®é™…è°ƒæ•´
    ticker := time.NewTicker(30 * time.Second)

    // ã€æ­¥éª¤2ã€‘ç¡®ä¿å®šæ—¶å™¨èµ„æºé‡Šæ”¾
    // è¯„å§”è€ƒå¯Ÿï¼šå¦‚æœä¸è°ƒç”¨ Stop() ä¼šæ€æ ·ï¼Ÿ
    // ç­”æ¡ˆï¼šgoroutine æ³„æ¼ï¼Œå®šæ—¶å™¨ä¼šä¸€ç›´è¿è¡Œï¼Œæ— æ³•è¢« GC å›æ”¶
    defer ticker.Stop()

    // ã€æ­¥éª¤3ã€‘æ— é™å¾ªç¯ï¼Œç›´åˆ°è¿æ¥æ–­å¼€
    for {
        select {
        // ã€æ­¥éª¤4ã€‘å®šæ—¶å™¨è§¦å‘æ—¶æ‰§è¡Œ
        case <-ticker.C:
            // å‘é€ Ping æ¶ˆæ¯ï¼ˆWebSocket åè®®æ ‡å‡†ï¼‰
            // ç¼–ç¨‹æ€æƒ³ï¼šåè®®å±‚å¿ƒè·³ï¼Œæ£€æµ‹è¿æ¥æ´»æ€§
            // å‚æ•°ï¼šWriteControl ç”¨äºå‘é€æ§åˆ¶å¸§ï¼Œä¸å ç”¨æ™®é€šæ¶ˆæ¯å¸¦å®½
            if err := conn.WriteControl(websocket.PingMessage, nil, time.Now().Add(10*time.Second)); err != nil {
                // å‘é€å¤±è´¥è¯´æ˜è¿æ¥å·²æ–­å¼€ï¼Œé€€å‡º goroutine
                return
            }

            // ã€æ­¥éª¤5ã€‘æ›´æ–° Redis ä¸­çš„ä¼šè¯æ´»è·ƒæ—¶é—´
            // ç¼–ç¨‹æ€æƒ³ï¼šåˆ†å¸ƒå¼ä¼šè¯ç®¡ç†ï¼ŒRedis å­˜å‚¨æ´»è·ƒçŠ¶æ€
            // ç”¨é€”ï¼šç”¨äºä¼šè¯æ¸…ç†ã€æ´»è·ƒç”¨æˆ·ç»Ÿè®¡
            h.redisClient.Expire(context.Background(),
                fmt.Sprintf("session:%s:active", sessionID),  // Redis key æ ¼å¼
                60*time.Second)  // TTL 60ç§’
        }
    }
}
```

**ã€ç¼–ç¨‹æ€æƒ³æ€»ç»“ã€‘**
1. **å®šæ—¶ä»»åŠ¡**: Ticker å®ç°å‘¨æœŸæ€§ä»»åŠ¡
2. **èµ„æºæ¸…ç†**: defer ä¿è¯èµ„æºé‡Šæ”¾
3. **é”™è¯¯å¤„ç†**: å‘é€å¤±è´¥ç«‹å³é€€å‡ºï¼Œé¿å…æ— æ•ˆå·¥ä½œ
4. **åˆ†å¸ƒå¼çŠ¶æ€**: Redis å­˜å‚¨ä¼šè¯çŠ¶æ€ï¼Œæ”¯æŒå¤šå®ä¾‹éƒ¨ç½²

**ã€è¯„å§”è€ƒå¯Ÿç‚¹ã€‘**
- Q: ä¸ºä»€ä¹ˆç”¨ Ping è€Œä¸æ˜¯è‡ªå®šä¹‰æ¶ˆæ¯ï¼Ÿ
  - A: Ping æ˜¯ WebSocket åè®®æ ‡å‡†ï¼Œæµè§ˆå™¨/å®¢æˆ·ç«¯è‡ªåŠ¨å¤„ç†ï¼Œæ— éœ€ä¸šåŠ¡é€»è¾‘
- Q: 30ç§’é—´éš”å¦‚ä½•é€‰æ‹©ï¼Ÿ
  - A: å¤ªçŸ­æµªè´¹èµ„æºï¼Œå¤ªé•¿å¯èƒ½è¢«ä¸­é—´ä»¶æ–­å¼€ã€‚30ç§’æ˜¯ç»éªŒå€¼
- Q: Redis çš„ Expire ä½œç”¨æ˜¯ä»€ä¹ˆï¼Ÿ
  - A: è‡ªåŠ¨æ¸…ç†è¿‡æœŸä¼šè¯ï¼Œé˜²æ­¢åƒµå°¸è¿æ¥å ç”¨å†…å­˜

---

### 2.3 è®¤è¯ä¸é™æµä¸­é—´ä»¶

#### 2.3.1 JWT è®¤è¯

```go
// backend/gateway/internal/middleware/auth.go

// AuthMiddlewareï¼šJWT è®¤è¯ä¸­é—´ä»¶å·¥å‚å‡½æ•°
// ç¼–ç¨‹æ€æƒ³ï¼šé«˜é˜¶å‡½æ•°ï¼Œè¿”å›ä¸€ä¸ª gin.HandlerFuncï¼ˆä¸­é—´ä»¶å‡½æ•°ï¼‰
// å‚æ•°ï¼šjwtSecret - JWT ç­¾åå¯†é’¥
// è¿”å›ï¼šgin.HandlerFunc - Gin æ¡†æ¶çš„ä¸­é—´ä»¶å‡½æ•°ç±»å‹
func AuthMiddleware(jwtSecret string) gin.HandlerFunc {
    // è¿”å›é—­åŒ…å‡½æ•°ï¼Œæ•è· jwtSecret å˜é‡
    return func(c *gin.Context) {
        // ã€æ­¥éª¤1ã€‘ä» HTTP Header è·å– Token
        // ç¼–ç¨‹æ€æƒ³ï¼šåè®®å±‚è®¤è¯ï¼ŒåŸºäº HTTP æ ‡å‡†
        // Header æ ¼å¼ï¼šAuthorization: Bearer <token>
        authHeader := c.GetHeader("Authorization")

        // ã€æ­¥éª¤2ã€‘ç©ºå€¼æ£€æŸ¥ï¼ˆé˜²å¾¡æ€§ç¼–ç¨‹ï¼‰
        // è¯„å§”è€ƒå¯Ÿï¼šä¸ºä»€ä¹ˆä¸ç›´æ¥è§£æï¼Ÿç›´æ¥è§£æä¼šæœ‰ä»€ä¹ˆé—®é¢˜ï¼Ÿ
        // ç­”æ¡ˆï¼šç©ºå­—ç¬¦ä¸²è§£æä¼šæŠ¥é”™ï¼Œå…ˆæ£€æŸ¥å¯ä»¥è¿”å›æ›´å‹å¥½çš„é”™è¯¯ä¿¡æ¯
        if authHeader == "" {
            // Abort ç»ˆæ­¢è¯·æ±‚ï¼Œä¸æ‰§è¡Œåç»­ä¸­é—´ä»¶å’Œå¤„ç†å™¨
            c.AbortWithStatusJSON(401, gin.H{"error": "Missing token"})
            return
        }

        // ã€æ­¥éª¤3ã€‘æå– Tokenï¼ˆå»é™¤ "Bearer " å‰ç¼€ï¼‰
        // å­—ç¬¦ä¸²æ“ä½œï¼Œåˆ‡ç‰‡å–å­ä¸²
        tokenString := strings.TrimPrefix(authHeader, "Bearer ")

        // ã€æ­¥éª¤4ã€‘è§£æå¹¶éªŒè¯ JWT
        // ç¼–ç¨‹æ€æƒ³ï¼šåŠ å¯†ç­¾åéªŒè¯ï¼Œé˜²æ­¢ç¯¡æ”¹
        // ParseWithClaims ä¼šéªŒè¯ç­¾åã€è¿‡æœŸæ—¶é—´ç­‰
        claims, err := jwt.ParseWithClaims(tokenString, &Claims{},
            func(token *jwt.Token) (interface{}, error) {
                // è¿”å›ç­¾åå¯†é’¥ï¼Œç”¨äºéªŒè¯
                return []byte(jwtSecret), nil
            })

        // ã€æ­¥éª¤5ã€‘éªŒè¯ç»“æœ
        // è¯„å§”è€ƒå¯Ÿï¼šJWT çš„å®‰å…¨æ€§å¦‚ä½•ä¿è¯ï¼Ÿ
        // ç­”æ¡ˆï¼š1. ç­¾åé˜²æ­¢ç¯¡æ”¹ 2. è¿‡æœŸæ—¶é—´é˜²æ­¢é‡æ”¾ 3. æœåŠ¡ç«¯ä¸å­˜å‚¨çŠ¶æ€
        if err != nil || !claims.Valid {
            c.AbortWithStatusJSON(401, gin.H{"error": "Invalid token"})
            return
        }

        // ã€æ­¥éª¤6ã€‘å°†ç”¨æˆ·ä¿¡æ¯å­˜å…¥ä¸Šä¸‹æ–‡
        // ç¼–ç¨‹æ€æƒ³ï¼šè¯·æ±‚ä¸Šä¸‹æ–‡ä¼ é€’æ•°æ®ï¼Œåç»­å¤„ç†å™¨å¯ç›´æ¥è¯»å–
        c.Set("userID", claims.UserID)
        c.Set("sessionID", claims.SessionID)

        // ã€æ­¥éª¤7ã€‘æ”¾è¡Œï¼Œæ‰§è¡Œåç»­ä¸­é—´ä»¶å’Œå¤„ç†å™¨
        c.Next()
    }
}
```

**ã€JWT è®¤è¯æµç¨‹ã€‘**
```
1. å®¢æˆ·ç«¯ç™»å½• â†’ æœåŠ¡ç«¯ç”Ÿæˆ JWT (Header.Payload.Signature)
2. å®¢æˆ·ç«¯å­˜å‚¨ JWT
3. æ¯æ¬¡è¯·æ±‚æºå¸¦ JWT
4. æœåŠ¡ç«¯éªŒè¯ç­¾å â†’ è§£æ Payload â†’ æ£€æŸ¥è¿‡æœŸæ—¶é—´
5. é€šè¿‡åˆ™æ”¾è¡Œï¼Œæ‹’ç»åˆ™è¿”å› 401
```

**ã€JWT vs Sessionã€‘**
| ç‰¹æ€§ | JWT | Session |
|------|-----|---------|
| çŠ¶æ€ | æ— çŠ¶æ€ | æœ‰çŠ¶æ€ |
| å­˜å‚¨ | å®¢æˆ·ç«¯ | æœåŠ¡ç«¯ |
| æ‰©å±•æ€§ | å¥½ï¼ˆæ— éœ€å…±äº« sessionï¼‰ | éœ€è¦å…±äº«å­˜å‚¨ |
| å®‰å…¨æ€§ | é˜²ç¯¡æ”¹ï¼ˆç­¾åï¼‰ | ä¾èµ–å­˜å‚¨å®‰å…¨ |

**ã€è¯„å§”è€ƒå¯Ÿç‚¹ã€‘**
- Q: JWT çš„ Payload å¯ä»¥å­˜å‚¨ä»€ä¹ˆï¼Ÿ
  - A: ç”¨æˆ· IDã€è§’è‰²ã€æƒé™ã€è¿‡æœŸæ—¶é—´ç­‰ï¼Œä½†ä¸èƒ½å­˜æ•æ„Ÿä¿¡æ¯ï¼ˆå¯†ç ï¼‰
- Q: JWT å¦‚ä½•å®ç°è‡ªåŠ¨ç»­æœŸï¼Ÿ
  - A: 1. çŸ­æœ‰æ•ˆæœŸ + åˆ·æ–°ä»¤ç‰Œ 2. æ¯æ¬¡è¯·æ±‚å»¶é•¿æœ‰æ•ˆæœŸ
- Q: JWT è¢«ç›—äº†æ€ä¹ˆåŠï¼Ÿ
  - A: 1. è®¾ç½®çŸ­æœ‰æ•ˆæœŸ 2. ä½¿ç”¨ HTTPS 3. æ·»åŠ è®¾å¤‡æŒ‡çº¹ 4. æä¾›åŠé”€æœºåˆ¶

---

#### 2.3.2 åˆ†å¸ƒå¼é™æµ

```go
// backend/gateway/internal/middleware/rate_limit.go

func RateLimitMiddleware(redisClient *redis.Client) gin.HandlerFunc {
    return func(c *gin.Context) {
        // ã€æ­¥éª¤1ã€‘è·å–ç”¨æˆ·IDï¼ˆä» JWT ä¸­é—´ä»¶è®¾ç½®çš„ä¸Šä¸‹æ–‡ï¼‰
        userID := c.GetString("userID")

        // ã€æ­¥éª¤2ã€‘æ„å»º Redis Key
        // ç¼–ç¨‹æ€æƒ³ï¼šå‘½åè§„èŒƒï¼Œä¾¿äºç®¡ç†å’Œç›‘æ§
        key := fmt.Sprintf("rate_limit:%s", userID)

        // ã€æ­¥éª¤3ã€‘ä½¿ç”¨ Lua è„šæœ¬å®ç°åŸå­æ“ä½œ
        // ç¼–ç¨‹æ€æƒ³ï¼šåŸå­æ€§ä¿è¯ï¼Œé¿å…ç«æ€æ¡ä»¶
        // ä¸ºä»€ä¹ˆç”¨ Luaï¼Ÿå› ä¸º Redis æ˜¯å•çº¿ç¨‹æ‰§è¡Œ Lua è„šæœ¬çš„
        script := `
        local current = redis.call('GET', KEYS[1])
        if current and tonumber(current) >= tonumber(ARGV[1]) then
            return 0  -- è¶…è¿‡é™åˆ¶
        else
            redis.call('INCR', KEYS[1])  -- è®¡æ•°+1
            redis.call('EXPIRE', KEYS[1], ARGV[2])  -- è®¾ç½®è¿‡æœŸæ—¶é—´
            return 1  -- å…è®¸é€šè¿‡
        end
        `

        // ã€æ­¥éª¤4ã€‘æ‰§è¡Œ Lua è„šæœ¬
        // KEYS[1] = key, ARGV[1] = 100ï¼ˆä¸Šé™ï¼‰, ARGV[2] = 60ï¼ˆç§’ï¼‰
        allowed, err := redisClient.Eval(context.Background(), script,
            []string{key}, "100", "60").Result()

        // ã€æ­¥éª¤5ã€‘æ£€æŸ¥ç»“æœ
        // è¯„å§”è€ƒå¯Ÿï¼šä¸ºä»€ä¹ˆç”¨ int64 ç±»å‹ï¼Ÿ
        // ç­”æ¡ˆï¼šRedis è¿”å›çš„æ˜¯ int64 ç±»å‹ï¼Œéœ€è¦ç±»å‹æ–­è¨€
        if err != nil || allowed.(int64) == 0 {
            c.AbortWithStatusJSON(429, gin.H{"error": "Rate limit exceeded"})
            return
        }

        // ã€æ­¥éª¤6ã€‘æ”¾è¡Œ
        c.Next()
    }
}
```

**ã€é™æµç®—æ³•å¯¹æ¯”ã€‘**

1. **å›ºå®šçª—å£è®¡æ•°å™¨**ï¼ˆæœ¬å®ç°ï¼‰
   - ä¼˜ç‚¹ï¼šç®€å•ã€é«˜æ•ˆ
   - ç¼ºç‚¹ï¼šä¸´ç•Œé—®é¢˜ï¼ˆè¾¹ç•Œæ—¶åˆ»å¯èƒ½è¶…ä¸¤å€ï¼‰

2. **æ»‘åŠ¨çª—å£**
   - ä¼˜ç‚¹ï¼šæ›´ç²¾ç¡®
   - ç¼ºç‚¹ï¼šå®ç°å¤æ‚ï¼Œå­˜å‚¨å¼€é”€å¤§

3. **ä»¤ç‰Œæ¡¶**
   - ä¼˜ç‚¹ï¼šå…è®¸çªå‘æµé‡
   - ç¼–ç¨‹æ€æƒ³ï¼šç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å‹

4. **æ¼æ¡¶**
   - ä¼˜ç‚¹ï¼šå¹³æ»‘æµé‡
   - ç¼–ç¨‹æ€æƒ³ï¼šé˜Ÿåˆ—æ¨¡å‹

**ã€Lua è„šæœ¬åŸå­æ€§ã€‘**
```
Redis å•çº¿ç¨‹æ‰§è¡Œ Lua è„šæœ¬ï¼Œä¿è¯ï¼š
1. GET å’Œ INCR ä¸ä¼šè¢«å…¶ä»–å‘½ä»¤æ‰“æ–­
2. ä¸éœ€è¦åˆ†å¸ƒå¼é”
3. æ€§èƒ½é«˜ï¼ˆè„šæœ¬ç¼“å­˜ï¼‰
```

**ã€è¯„å§”è€ƒå¯Ÿç‚¹ã€‘**
- Q: ä¸ºä»€ä¹ˆç”¨ Lua è€Œä¸æ˜¯å¤šä¸ª Redis å‘½ä»¤ï¼Ÿ
  - A: å¤šä¸ªå‘½ä»¤ä¸åŸå­ï¼Œå¯èƒ½è¢«å…¶ä»–å®¢æˆ·ç«¯æ‰“æ–­
- Q: 100 æ¬¡/åˆ†é’Ÿçš„é™åˆ¶å¦‚ä½•é€‰æ‹©ï¼Ÿ
  - A: æ ¹æ®ä¸šåŠ¡éœ€æ±‚ï¼ŒèŠå¤©åœºæ™¯é€šå¸¸ 60-100 æ¬¡/åˆ†é’Ÿ
- Q: å¦‚æœ Redis æŒ‚äº†æ€ä¹ˆåŠï¼Ÿ
  - A: é™çº§å¤„ç†ï¼š1. ç›´æ¥æ”¾è¡Œ 2. ä½¿ç”¨æœ¬åœ°å†…å­˜é™æµ 3. è¿”å›é”™è¯¯

---

## 3. Python Agent Engine - AI æ ¸å¿ƒå¼•æ“

### 3.1 ç”Ÿäº§çº§ç¼–æ’å™¨

#### 3.2.1 å®Œæ•´å¤„ç†æµç¨‹ï¼ˆ11æ­¥å®‰å…¨é“¾ï¼‰

```python
# backend/app/orchestration/orchestrator_production.py

class ProductionChatOrchestrator:
    """
    ç”Ÿäº§çº§èŠå¤©ç¼–æ’å™¨

    ã€æ ¸å¿ƒèŒè´£ã€‘
    1. è¯·æ±‚éªŒè¯ï¼šé˜²æ­¢æ¶æ„è¯·æ±‚
    2. å¹¶å‘æ§åˆ¶ï¼šé¿å…èµ„æºè€—å°½
    3. çŠ¶æ€ç®¡ç†ï¼šä¿è¯ä¸€è‡´æ€§
    4. é”™è¯¯å¤„ç†ï¼šä¼˜é›…é™çº§
    5. ç›‘æ§åŸ‹ç‚¹ï¼šå¯è§‚æµ‹æ€§

    ã€ç¼–ç¨‹æ€æƒ³ã€‘
    - è´£ä»»é“¾æ¨¡å¼ï¼š11ä¸ªæ­¥éª¤ä¾æ¬¡æ‰§è¡Œ
    - ç†”æ–­å™¨æ¨¡å¼ï¼šé˜²æ­¢çº§è”æ•…éšœ
    - å¹‚ç­‰æ€§è®¾è®¡ï¼šé‡å¤è¯·æ±‚å®‰å…¨
    """

    def __init__(self, config: ProductionSettings):
        # ã€æ­¥éª¤1ã€‘æ ¸å¿ƒç»„ä»¶åˆå§‹åŒ–
        # ç¼–ç¨‹æ€æƒ³ï¼šä¾èµ–æ³¨å…¥ï¼Œæ‰€æœ‰ç»„ä»¶å¯æ›¿æ¢
        self.state_manager = SessionStateManager()      # ä¼šè¯çŠ¶æ€ç®¡ç†
        self.validator = RequestValidator()              # è¯·æ±‚éªŒè¯å™¨
        self.tool_executor = ToolExecutor()              # å·¥å…·æ‰§è¡Œå™¨
        self.response_composer = ResponseComposer()      # å“åº”ç»„åˆå™¨

        # ã€æ­¥éª¤2ã€‘ç”Ÿäº§çº§å¢å¼ºç»„ä»¶
        self.context_pruner = ContextPruner(             # ä¸Šä¸‹æ–‡ä¿®å‰ªå™¨
            redis_client=config.redis_client,
            max_history_messages=config.MAX_HISTORY_MESSAGES,
            summary_threshold=config.SUMMARY_THRESHOLD
        )
        self.token_tracker = TokenTracker()              # Token è¿½è¸ªå™¨
        self.circuit_breaker = CircuitBreaker(           # ç†”æ–­å™¨
            failure_threshold=config.CIRCUIT_BREAKER_THRESHOLD,
            recovery_timeout=config.CIRCUIT_BREAKER_TIMEOUT
        )
        self.message_tracker = MessageTracker()          # æ¶ˆæ¯å»é‡å™¨

        # ã€æ­¥éª¤3ã€‘ç›‘æ§ç»„ä»¶
        self.metrics = MetricsCollector()                # æŒ‡æ ‡æ”¶é›†å™¨

    # ä¸»å¤„ç†å‡½æ•°ï¼š11æ­¥å®‰å…¨é“¾
    async def process_stream(self, request: ChatRequest) -> AsyncIterator[StreamEvent]:
        """
        å¤„ç†èŠå¤©è¯·æ±‚ï¼Œè¿”å›æµå¼å“åº”

        ã€å‚æ•°ã€‘
        request: ChatRequest å¯¹è±¡ï¼ŒåŒ…å« user_id, session_id, message

        ã€è¿”å›ã€‘
        AsyncIterator: å¼‚æ­¥è¿­ä»£å™¨ï¼Œé€ä¸ªè¿”å› StreamEvent

        ã€ç¼–ç¨‹æ€æƒ³ã€‘
        - å¼‚æ­¥æµå¼ï¼šasync for é€å—è¿”å›
        - ç”Ÿæˆå™¨æ¨¡å¼ï¼šyield å…³é”®å­—å®ç°æµå¼
        - é”™è¯¯å¤„ç†ï¼šæ¯ä¸ªæ­¥éª¤éƒ½æœ‰å¼‚å¸¸æ•è·
        """
        request_id = request.request_id
        session_id = request.session_id
        user_id = request.user_id

        # ========== ç¬¬1æ­¥ï¼šæ¶ˆæ¯å»é‡æ£€æŸ¥ ==========
        # ã€ç›®çš„ã€‘é˜²æ­¢é‡å¤å¤„ç†ï¼ˆç½‘ç»œé‡ä¼ ã€å®¢æˆ·ç«¯é‡è¯•ï¼‰
        # ã€ç¼–ç¨‹æ€æƒ³ã€‘å¹‚ç­‰æ€§è®¾è®¡
        if await self.message_tracker.is_processed(request_id):
            yield ErrorEvent(code="DUPLICATE_REQUEST", message="è¯·æ±‚å·²å¤„ç†")
            return  # ç›´æ¥è¿”å›ï¼Œä¸æ‰§è¡Œåç»­æ­¥éª¤

        # ========== ç¬¬2æ­¥ï¼šç†”æ–­å™¨æ£€æŸ¥ ==========
        # ã€ç›®çš„ã€‘é˜²æ­¢ç³»ç»Ÿè¿‡è½½
        # ã€ç¼–ç¨‹æ€æƒ³ã€‘ç†”æ–­å™¨æ¨¡å¼ï¼Œç±»ä¼¼ç”µè·¯ä¿é™©ä¸
        if not await self.circuit_breaker.can_execute():
            yield ErrorEvent(code="CIRCUIT_BREAKER_OPEN",
                           message="ç³»ç»Ÿè¿‡è½½ï¼Œè¯·ç¨åé‡è¯•")
            return

        # ========== ç¬¬3æ­¥ï¼šå¹¶å‘æ§åˆ¶ ==========
        # ã€ç›®çš„ã€‘é™åˆ¶å•ä¸ªç”¨æˆ·çš„å¹¶å‘è¯·æ±‚æ•°
        # ã€ç¼–ç¨‹æ€æƒ³ã€‘ä¿¡å·é‡æ¨¡å¼ï¼Œæ§åˆ¶èµ„æºè®¿é—®
        if not await self._track_session(session_id, add=True):
            yield ErrorEvent(code="RATE_LIMIT", message="å¹¶å‘è¯·æ±‚è¿‡å¤š")
            return

        try:
            # ========== ç¬¬4æ­¥ï¼šè¯·æ±‚éªŒè¯ ==========
            # ã€ç›®çš„ã€‘è¾“å…¥éªŒè¯ï¼Œé˜²æ­¢æ³¨å…¥æ”»å‡»
            # ã€ç¼–ç¨‹æ€æƒ³ã€‘é˜²å¾¡æ€§ç¼–ç¨‹ï¼Œè¾¹ç•Œæ£€æŸ¥
            validation = await self.validator.validate_chat_request(request)
            if not validation.is_valid:
                yield ErrorEvent(code="VALIDATION_FAILED",
                               message=validation.error_message)
                return

            # ========== ç¬¬5æ­¥ï¼šå¹‚ç­‰æ€§æ£€æŸ¥ ==========
            # ã€ç›®çš„ã€‘æ£€æŸ¥æ˜¯å¦å·²å¤„ç†è¿‡ç›¸åŒè¯·æ±‚
            # ã€ç¼–ç¨‹æ€æƒ³ã€‘ç¼“å­˜å¹‚ç­‰ï¼Œä½¿ç”¨ Redis å­˜å‚¨è¯·æ±‚ID
            cached = await self._check_idempotency(session_id, request_id)
            if cached:
                yield cached  # è¿”å›ç¼“å­˜ç»“æœ
                return

            # ========== ç¬¬6æ­¥ï¼šåˆ†å¸ƒå¼é” ==========
            # ã€ç›®çš„ã€‘é˜²æ­¢åŒä¸€ä¼šè¯çš„å¤šä¸ªè¯·æ±‚å¹¶å‘ä¿®æ”¹çŠ¶æ€
            # ã€ç¼–ç¨‹æ€æƒ³ã€‘åˆ†å¸ƒå¼é”ï¼ŒRedis SETNX å®ç°
            lock_acquired = await self._acquire_session_lock(
                session_id, request_id, timeout=10
            )
            if not lock_acquired:
                yield ErrorEvent(code="LOCK_FAILED", message="ä¼šè¯ç¹å¿™")
                return

            # ========== ç¬¬7æ­¥ï¼šæ„å»ºä¸Šä¸‹æ–‡ ==========
            # ã€ç›®çš„ã€‘æ”¶é›†æ‰€æœ‰éœ€è¦çš„ä¿¡æ¯
            # ã€ç¼–ç¨‹æ€æƒ³ã€‘ä¸Šä¸‹æ–‡æ¨¡å¼ï¼Œç»Ÿä¸€ç®¡ç†çŠ¶æ€

            # 7.1 ç”¨æˆ·ä¸Šä¸‹æ–‡ï¼ˆåŸºæœ¬ä¿¡æ¯ã€è¿›åº¦ã€è®¡åˆ’ï¼‰
            user_context = await self._build_user_context(user_id)

            # 7.2 å¯¹è¯å†å²ï¼ˆå¸¦ä¿®å‰ªå’Œæ€»ç»“ï¼‰
            conversation_context = await self.context_pruner.get_pruned_history(
                session_id, user_id
            )

            # ========== ç¬¬8æ­¥ï¼šçŸ¥è¯†æ£€ç´¢ï¼ˆGraphRAGï¼‰ ==========
            # ã€ç›®çš„ã€‘è·å–ç›¸å…³çŸ¥è¯†ï¼Œå¢å¼ºå›ç­”å‡†ç¡®æ€§
            # ã€ç¼–ç¨‹æ€æƒ³ã€‘RAGï¼ˆæ£€ç´¢å¢å¼ºç”Ÿæˆï¼‰
            knowledge_context = await self._retrieve_knowledge(
                user_id, request.message, conversation_context
            )

            # ========== ç¬¬9æ­¥ï¼šLLM è°ƒç”¨ + å·¥å…·æ‰§è¡Œ ==========
            # ã€ç›®çš„ã€‘ç”Ÿæˆå›ç­”ï¼Œå¯èƒ½è°ƒç”¨å·¥å…·
            # ã€ç¼–ç¨‹æ€æƒ³ã€‘å‡½æ•°è°ƒç”¨ï¼ŒLLM å†³å®šæ˜¯å¦ä½¿ç”¨å·¥å…·
            async for chunk in self._call_llm_with_tools(
                request=request,
                user_context=user_context,
                conversation_context=conversation_context,
                knowledge_context=knowledge_context
            ):
                yield chunk  # æµå¼è¿”å›

            # ========== ç¬¬10æ­¥ï¼šç¼“å­˜ä¸æŒ‡æ ‡ ==========
            # ã€ç›®çš„ã€‘è®°å½•æ•°æ®ï¼Œä¼˜åŒ–åç»­è¯·æ±‚
            # ã€ç¼–ç¨‹æ€æƒ³ã€‘å¯è§‚æµ‹æ€§ï¼ŒåŸ‹ç‚¹ç›‘æ§
            await self._cache_response(session_id, request_id, request.message)
            await self._record_metrics(request, user_context)

        finally:
            # ========== ç¬¬11æ­¥ï¼šæ¸…ç†èµ„æº ==========
            # ã€ç›®çš„ã€‘é‡Šæ”¾é”ã€å‡å°‘å¹¶å‘è®¡æ•°
            # ã€ç¼–ç¨‹æ€æƒ³ã€‘èµ„æºç®¡ç†ï¼Œç¡®ä¿æ¸…ç†
            await self._release_session_lock(session_id, request_id)
            await self._track_session(session_id, add=False)
```

**ã€ç¼–ç¨‹æ€æƒ³è¯¦è§£ã€‘**

1. **è´£ä»»é“¾æ¨¡å¼ï¼ˆChain of Responsibilityï¼‰**
   ```
   11ä¸ªæ­¥éª¤åƒæµæ°´çº¿ï¼Œæ¯ä¸ªæ­¥éª¤ï¼š
   - æ£€æŸ¥æ¡ä»¶
   - é€šè¿‡åˆ™ç»§ç»­
   - å¤±è´¥åˆ™è¿”å›é”™è¯¯
   - finally ä¿è¯æ¸…ç†
   ```

2. **ç†”æ–­å™¨æ¨¡å¼ï¼ˆCircuit Breakerï¼‰**
   ```
   ä¸‰ç§çŠ¶æ€ï¼š
   - CLOSED: æ­£å¸¸ï¼ˆå¤±è´¥æ¬¡æ•° < é˜ˆå€¼ï¼‰
   - OPEN: ç†”æ–­ï¼ˆå¤±è´¥æ¬¡æ•° >= é˜ˆå€¼ï¼Œæ‹’ç»è¯·æ±‚ï¼‰
   - HALF_OPEN: åŠå¼€ï¼ˆå°è¯•æ¢å¤ï¼Œå…è®¸ä¸€ä¸ªè¯·æ±‚ï¼‰
   ```

3. **å¹‚ç­‰æ€§è®¾è®¡ï¼ˆIdempotencyï¼‰**
   ```
   ç›¸åŒè¯·æ±‚å¤šæ¬¡æ‰§è¡Œï¼Œç»“æœç›¸åŒï¼š
   - è¯·æ±‚IDå»é‡ï¼ˆRedisï¼‰
   - ç¼“å­˜ç»“æœï¼ˆRedisï¼‰
   - é˜²æ­¢é‡å¤æ‰£æ¬¾ã€é‡å¤åˆ›å»ºç­‰
   ```

4. **åˆ†å¸ƒå¼é”ï¼ˆDistributed Lockï¼‰**
   ```
   å¤šè¿›ç¨‹/å¤šæœåŠ¡å™¨ç¯å¢ƒä¸‹ï¼š
   - Redis SETNX åŸå­æ“ä½œ
   - å¸¦è¶…æ—¶ï¼ˆé˜²æ­¢æ­»é”ï¼‰
   - é‡Šæ”¾é”éœ€éªŒè¯ï¼ˆé˜²æ­¢è¯¯åˆ ï¼‰
   ```

**ã€å‰åç«¯äº¤äº’æµç¨‹ã€‘**
```
Flutter: å‘é€è¯·æ±‚
    â†“
Go: éªŒè¯ã€é™æµ
    â†“
Python: 11æ­¥å¤„ç†é“¾
    â†“
    1. å»é‡æ£€æŸ¥
    2. ç†”æ–­æ£€æŸ¥
    3. å¹¶å‘æ§åˆ¶
    4. è¯·æ±‚éªŒè¯
    5. å¹‚ç­‰æ£€æŸ¥
    6. åˆ†å¸ƒå¼é”
    7. æ„å»ºä¸Šä¸‹æ–‡
    8. çŸ¥è¯†æ£€ç´¢
    9. LLMè°ƒç”¨
    10. ç¼“å­˜è®°å½•
    11. èµ„æºæ¸…ç†
    â†“
æ•°æ®åº“/Redis/LLM
    â†“
æµå¼è¿”å› â†’ Flutter é€å—æ˜¾ç¤º
```

**ã€è¯„å§”è€ƒå¯Ÿç‚¹ã€‘**

Q: ä¸ºä»€ä¹ˆéœ€è¦11æ­¥ï¼Ÿèƒ½ä¸èƒ½ç®€åŒ–ï¼Ÿ
- A: æ¯ä¸€æ­¥éƒ½æœ‰æ˜ç¡®ç›®çš„ï¼Œç”Ÿäº§ç¯å¢ƒå¿…é¡»è€ƒè™‘ï¼šå®‰å…¨ã€ç¨³å®šã€å¯è§‚æµ‹ã€‚å¯ä»¥ç®€åŒ–ä½†ä¼šç‰ºç‰²æŸäº›ç‰¹æ€§

Q: ç†”æ–­å™¨å’Œé™æµçš„åŒºåˆ«ï¼Ÿ
- A: é™æµæ˜¯é¢„é˜²ï¼ˆæ§åˆ¶é€Ÿç‡ï¼‰ï¼Œç†”æ–­æ˜¯æ²»ç–—ï¼ˆç³»ç»Ÿå·²è¿‡è½½ï¼Œåœæ­¢æœåŠ¡ä¿æŠ¤ï¼‰

Q: åˆ†å¸ƒå¼é”å¦‚æœè¶…æ—¶äº†æ€ä¹ˆåŠï¼Ÿ
- A: 1. è®¾ç½®åˆç†çš„è¶…æ—¶æ—¶é—´ 2. é”ç»­æœŸæœºåˆ¶ï¼ˆwatchdogï¼‰3. ä¸šåŠ¡å¹‚ç­‰æ€§ä¿è¯

Q: finally ä¸ºä»€ä¹ˆèƒ½ä¿è¯æ‰§è¡Œï¼Ÿ
- A: Python çš„ try-finally è¯­ä¹‰ï¼Œæ— è®º try ä¸­ returnã€breakã€continue è¿˜æ˜¯å¼‚å¸¸ï¼Œfinally éƒ½ä¼šæ‰§è¡Œ

---

### 3.3 ä¸Šä¸‹æ–‡ä¿®å‰ªå™¨ (ContextPruner)

```python
# backend/app/orchestration/context_pruner.py

class ContextPruner:
    """
    æ™ºèƒ½ä¸Šä¸‹æ–‡ä¿®å‰ªå™¨

    ã€è§£å†³çš„é—®é¢˜ã€‘
    é•¿å¯¹è¯å¯¼è‡´ï¼š
    1. Token è¶…é™ï¼ˆLLM ä¸Šä¸‹æ–‡çª—å£é™åˆ¶ï¼‰
    2. æ€§èƒ½ä¸‹é™ï¼ˆå¤„ç†æ—¶é—´å¢åŠ ï¼‰
    3. æˆæœ¬å¢åŠ ï¼ˆToken è®¡è´¹ï¼‰

    ã€è§£å†³æ–¹æ¡ˆã€‘
    1. æ»‘åŠ¨çª—å£ï¼šä¿ç•™æœ€è¿‘ N æ¡æ¶ˆæ¯
    2. å¼‚æ­¥æ€»ç»“ï¼šé•¿å†å²ç”Ÿæˆæ‘˜è¦
    3. ç¼“å­˜æœºåˆ¶ï¼šé¿å…é‡å¤æ€»ç»“
    """

    def __init__(self, redis_client, max_history_messages=10, summary_threshold=20):
        self.redis = redis_client
        self.max_history_messages = max_history_messages  # æ»‘åŠ¨çª—å£å¤§å°
        self.summary_threshold = summary_threshold        # è§¦å‘æ€»ç»“çš„é˜ˆå€¼
        self.summary_cache_ttl = 3600  # 1å°æ—¶ç¼“å­˜

    async def get_pruned_history(self, session_id: str, user_id: str,
                                 force_summary=False) -> dict:
        """
        è·å–ä¿®å‰ªåçš„èŠå¤©å†å²

        ã€è¿”å›æ ¼å¼ã€‘
        {
            "messages": [...],        # ä¿ç•™çš„æ¶ˆæ¯ï¼ˆæœ€å¤š10æ¡ï¼‰
            "summary": "...",         # å†å²æ€»ç»“ï¼ˆå¦‚æœæœ‰ï¼‰
            "original_count": 50,     # åŸå§‹æ¶ˆæ¯æ•°
            "pruned_count": 8,        # ä¿®å‰ªåæ•°é‡
            "summary_used": True      # æ˜¯å¦ä½¿ç”¨äº†æ€»ç»“
        }

        ã€å¤„ç†é€»è¾‘ã€‘
        1. å°‘äº10æ¡ â†’ ç›´æ¥è¿”å›
        2. 10-20æ¡ â†’ æ»‘åŠ¨çª—å£ï¼ˆæœ€è¿‘10æ¡ï¼‰
        3. 20æ¡ä»¥ä¸Š â†’ è§¦å‘æ€»ç»“ï¼ˆå¼‚æ­¥ï¼‰
        """
        # ã€æ­¥éª¤1ã€‘ä» Redis åŠ è½½å®Œæ•´å†å²
        # ç¼–ç¨‹æ€æƒ³ï¼šRedis ä½œä¸ºé«˜é€Ÿç¼“å­˜ï¼Œå­˜å‚¨ä¼šè¯å†å²
        history = await self._load_chat_history(session_id)

        # ç©ºå†å²ç›´æ¥è¿”å›
        if not history:
            return self._empty_result()

        original_count = len(history)

        # ã€æ­¥éª¤2ã€‘å°å†å²ç›´æ¥è¿”å›ï¼ˆä¼˜åŒ–è·¯å¾„ï¼‰
        # ç¼–ç¨‹æ€æƒ³ï¼šå¿«é€Ÿè·¯å¾„ï¼Œé¿å…ä¸å¿…è¦çš„å¤„ç†
        if original_count <= self.max_history_messages:
            return {
                "messages": history,
                "summary": None,
                "original_count": original_count,
                "pruned_count": original_count,
                "summary_used": False
            }

        # ã€æ­¥éª¤3ã€‘åˆ¤æ–­æ˜¯å¦éœ€è¦æ€»ç»“
        # ç¼–ç¨‹æ€æƒ³ï¼šé˜ˆå€¼åˆ¤æ–­ï¼Œå¹³è¡¡æ€§èƒ½å’Œæ•ˆæœ
        need_summary = force_summary or original_count > self.summary_threshold

        if need_summary:
            # ã€æ­¥éª¤4ã€‘è·å–å¸¦æ€»ç»“çš„å†å²
            return await self._get_summarized_history(session_id, history, user_id)
        else:
            # ã€æ­¥éª¤5ã€‘ä½¿ç”¨æ»‘åŠ¨çª—å£
            # ç¼–ç¨‹æ€æƒ³ï¼šåªä¿ç•™æœ€è¿‘ N æ¡ï¼Œä¸¢å¼ƒæ—§æ¶ˆæ¯
            pruned_messages = history[-self.max_history_messages:]
            return {
                "messages": pruned_messages,
                "summary": None,
                "original_count": original_count,
                "pruned_count": len(pruned_messages),
                "summary_used": False
            }

    async def _get_summarized_history(self, session_id: str, history: list,
                                     user_id: str) -> dict:
        """è·å–å¸¦æ€»ç»“çš„å†å²"""
        # ã€æ­¥éª¤1ã€‘æ£€æŸ¥ç¼“å­˜
        # ç¼–ç¨‹æ€æƒ³ï¼šç¼“å­˜æ¨¡å¼ï¼Œé¿å…é‡å¤ç”Ÿæˆ
        cache_key = f"summary:{session_id}"
        cached_summary = await self.redis.get(cache_key)

        if cached_summary:
            # ç¼“å­˜å‘½ä¸­ï¼šè¿”å›æœ€è¿‘5æ¡ + ç¼“å­˜çš„æ€»ç»“
            return {
                "messages": history[-5:],
                "summary": cached_summary.decode("utf-8"),
                "original_count": len(history),
                "pruned_count": 6,
                "summary_used": True
            }

        # ã€æ­¥éª¤2ã€‘è§¦å‘å¼‚æ­¥æ€»ç»“ä»»åŠ¡
        # ç¼–ç¨‹æ€æƒ³ï¼šå¼‚æ­¥å¤„ç†ï¼Œä¸é˜»å¡ä¸»æµç¨‹
        await self._trigger_summary(session_id, history, user_id)

        # ã€æ­¥éª¤3ã€‘Fallbackï¼šè¿”å›æœ€è¿‘5æ¡
        # ç¼–ç¨‹æ€æƒ³ï¼šä¼˜é›…é™çº§ï¼Œå³ä½¿æ€»ç»“å¤±è´¥ä¹Ÿèƒ½ç»§ç»­
        return {
            "messages": history[-5:],
            "summary": None,
            "original_count": len(history),
            "pruned_count": 5,
            "summary_used": False,
            "summary_pending": True  # æ ‡è®°æ€»ç»“å¼‚æ­¥è¿›è¡Œä¸­
        }

    async def _trigger_summary(self, session_id: str, history: list, user_id: str):
        """å¼‚æ­¥è§¦å‘æ€»ç»“ä»»åŠ¡"""
        # ã€æ­¥éª¤1ã€‘åªæ€»ç»“é™¤æœ€è¿‘5æ¡å¤–çš„å†å²
        # ç¼–ç¨‹æ€æƒ³ï¼šä¿ç•™æœ€æ–°ä¸Šä¸‹æ–‡ï¼Œæ€»ç»“æ—§å†…å®¹
        history_to_summarize = history[:-5] if len(history) > 5 else history

        # ã€æ­¥éª¤2ã€‘æ„å»ºä»»åŠ¡
        task = {
            "session_id": session_id,
            "history": history_to_summarize,
            "user_id": user_id,
            "timestamp": time.time(),
            "priority": "high"
        }

        # ã€æ­¥éª¤3ã€‘æ¨é€åˆ° Redis é˜Ÿåˆ—
        # ç¼–ç¨‹æ€æƒ³ï¼šæ¶ˆæ¯é˜Ÿåˆ—ï¼Œè§£è€¦ç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…
        await self.redis.rpush("queue:summarization", json.dumps(task))

        # ã€æ­¥éª¤4ã€‘è®¾ç½®é˜Ÿåˆ— TTLï¼Œé˜²æ­¢ç§¯å‹
        # ç¼–ç¨‹æ€æƒ³ï¼šè¿‡æœŸç­–ç•¥ï¼Œé¿å…æ— é™å¢é•¿
        await self.redis.expire("queue:summarization", 86400)
```

**ã€ç¼–ç¨‹æ€æƒ³è¯¦è§£ã€‘**

1. **ç¼“å­˜æ¨¡å¼ï¼ˆCache-Asideï¼‰**
   ```
   è¯»å–æµç¨‹ï¼š
   1. å…ˆè¯»ç¼“å­˜
   2. ç¼“å­˜å‘½ä¸­ â†’ ç›´æ¥è¿”å›
   3. ç¼“å­˜æœªå‘½ä¸­ â†’ æŸ¥è¯¢æ•°æ®åº“ â†’ å†™å…¥ç¼“å­˜ â†’ è¿”å›

   å†™å…¥æµç¨‹ï¼š
   1. æ›´æ–°æ•°æ®åº“
   2. åˆ é™¤ç¼“å­˜ï¼ˆæˆ–æ›´æ–°ç¼“å­˜ï¼‰
   ```

2. **å¼‚æ­¥å¤„ç†æ¨¡å¼**
   ```
   ä¸»æµç¨‹ï¼š
   - è§¦å‘ä»»åŠ¡
   - ç«‹å³è¿”å›ï¼ˆä¸ç­‰å¾…ï¼‰
   - åå°å·¥ä½œå™¨å¤„ç†
   - ç»“æœå­˜å…¥ç¼“å­˜

   ä¼˜ç‚¹ï¼šå“åº”å¿«ï¼Œç”¨æˆ·ä½“éªŒå¥½
   ```

3. **ä¼˜é›…é™çº§**
   ```
   ç†æƒ³æƒ…å†µï¼šæ€»ç»“ + æœ€è¿‘5æ¡
   é™çº§æƒ…å†µï¼šåªè¿”å›æœ€è¿‘5æ¡ï¼ˆæ— æ€»ç»“ï¼‰
   æœ€å·®æƒ…å†µï¼šè¿”å›å…¨éƒ¨æ¶ˆæ¯ï¼ˆæ— ä¿®å‰ªï¼‰

   ç›®æ ‡ï¼šç³»ç»Ÿå§‹ç»ˆå¯ç”¨ï¼Œåªæ˜¯ä½“éªŒä¸åŒ
   ```

4. **æ»‘åŠ¨çª—å£**
   ```
   å†å²ï¼š[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]
   çª—å£å¤§å°ï¼š10

   ç»“æœï¼š[6,7,8,9,10,11,12,13,14,15]

   å®ç°ï¼šhistory[-10:]
   ```

**ã€æ•°æ®æµå›¾ã€‘**
```
è¯·æ±‚åˆ°è¾¾
    â†“
æ£€æŸ¥å†å²é•¿åº¦
    â†“
â”Œâ”€â”€â”€â”´â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  <10   â”‚   10-20      â”‚   >20
â”‚        â”‚              â”‚
ç›´æ¥è¿”å›  æ»‘åŠ¨çª—å£      æ£€æŸ¥ç¼“å­˜
          â†“            â†“
        è¿”å›æœ€è¿‘10æ¡  å‘½ä¸­ï¼Ÿâ†’ è¿”å›ç¼“å­˜
                    â†“
                  æœªå‘½ä¸­ï¼Ÿâ†’ å¼‚æ­¥æ€»ç»“
                         â†“
                       è¿”å›æœ€è¿‘5æ¡
```

**ã€è¯„å§”è€ƒå¯Ÿç‚¹ã€‘**

Q: ä¸ºä»€ä¹ˆä¿ç•™æœ€è¿‘5æ¡è€Œä¸æ˜¯10æ¡ï¼Ÿ
- A: 1. èŠ‚çœ Token 2. ä¿ç•™æœ€æ–°ä¸Šä¸‹æ–‡ 3. æ€»ç»“å·²åŒ…å«æ—§ä¿¡æ¯

Q: å¼‚æ­¥æ€»ç»“å¦‚æœå¤±è´¥äº†æ€ä¹ˆåŠï¼Ÿ
- A: 1. ä»»åŠ¡ä¼šé‡è¯• 2. ä¸‹æ¬¡è¯·æ±‚ä¼šé‡æ–°è§¦å‘ 3. ä¸å½±å“å½“å‰è¯·æ±‚

Q: Redis é˜Ÿåˆ—ç§¯å‹äº†æ€ä¹ˆå¤„ç†ï¼Ÿ
- A: 1. è®¾ç½® TTL è‡ªåŠ¨æ¸…ç† 2. ç›‘æ§é˜Ÿåˆ—é•¿åº¦ 3. å¢åŠ å·¥ä½œå™¨æ•°é‡

Q: æ»‘åŠ¨çª—å£å’Œæ€»ç»“å“ªä¸ªæ›´å¥½ï¼Ÿ
- A: å„æœ‰ä¼˜åŠ£ï¼šæ»‘åŠ¨çª—å£ç®€å•ä½†å¯èƒ½ä¸¢å¤±ä¿¡æ¯ï¼Œæ€»ç»“ä¿¡æ¯å¯†é›†ä½†éœ€è¦ LLM è®¡ç®—

---

### 3.4 åŠ¨æ€å·¥å…·ç³»ç»Ÿ

```python
# backend/app/orchestration/dynamic_tool_registry.py

class DynamicToolRegistry:
    """
    åŠ¨æ€å·¥å…·æ³¨å†Œè¡¨

    ã€æ ¸å¿ƒæ€æƒ³ã€‘
    ä¼ ç»Ÿæ–¹å¼ï¼šç¡¬ç¼–ç å·¥å…·åˆ—è¡¨
    åŠ¨æ€æ–¹å¼ï¼šè‡ªåŠ¨å‘ç°ã€è‡ªåŠ¨æ³¨å†Œ

    ã€ä¼˜åŠ¿ã€‘
    1. æ‰©å±•æ€§ï¼šæ–°å¢å·¥å…·æ— éœ€ä¿®æ”¹æ³¨å†Œä»£ç 
    2. æ¨¡å—åŒ–ï¼šå·¥å…·ç‹¬ç«‹å¼€å‘ã€æµ‹è¯•
    3. çµæ´»æ€§ï¼šè¿è¡Œæ—¶åŠ¨æ€åŠ è½½
    """

    _instance = None  # å•ä¾‹æ¨¡å¼
    _tools: Dict[str, BaseTool] = {}  # å·¥å…·å­—å…¸

    def __new__(cls):
        # ã€æ­¥éª¤1ã€‘å•ä¾‹æ¨¡å¼å®ç°
        # ç¼–ç¨‹æ€æƒ³ï¼šç¡®ä¿å…¨å±€åªæœ‰ä¸€ä¸ªæ³¨å†Œè¡¨å®ä¾‹
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

    def register_from_package(self, package_path: str, recursive: bool = True) -> int:
        """
        ä» Python åŒ…è‡ªåŠ¨å‘ç°å¹¶æ³¨å†Œæ‰€æœ‰å·¥å…·

        ã€å‚æ•°ã€‘
        package_path: åŒ…è·¯å¾„ï¼Œå¦‚ "app.tools"
        recursive: æ˜¯å¦é€’å½’æ‰«æå­åŒ…

        ã€è¿”å›ã€‘
        int: æ³¨å†Œçš„å·¥å…·æ•°é‡

        ã€ç¼–ç¨‹æ€æƒ³ã€‘
        - åå°„æœºåˆ¶ï¼šåŠ¨æ€å¯¼å…¥æ¨¡å—
        - è‡ªåŠ¨å‘ç°ï¼šæ‰«æåŒ…å†…æ‰€æœ‰æ¨¡å—
        """
        import pkgutil
        import importlib

        # ã€æ­¥éª¤2ã€‘å¯¼å…¥åŒ…
        package = importlib.import_module(package_path)
        total_registered = 0

        # ã€æ­¥éª¤3ã€‘éå†åŒ…å†…æ‰€æœ‰æ¨¡å—
        for importer, modname, ispkg in pkgutil.iter_modules(package.__path__):
            full_module_path = f"{package_path}.{modname}"

            if ispkg and recursive:
                # é€’å½’å¤„ç†å­åŒ…
                total_registered += self.register_from_package(full_module_path, recursive)
            else:
                # æ³¨å†Œæ¨¡å—ä¸­çš„å·¥å…·
                if self.register_from_module(full_module_path):
                    # ç»Ÿè®¡æ³¨å†Œæ•°é‡
                    module_tools = [
                        t for t in self._tools.values()
                        if t.__module__ == full_module_path
                    ]
                    total_registered += len(module_tools)

        logger.info(f"Auto-discovered {total_registered} tools from {package_path}")
        return total_registered

    def register_from_module(self, module_path: str) -> bool:
        """
        ä»å•ä¸ªæ¨¡å—æ³¨å†Œå·¥å…·

        ã€ç¼–ç¨‹æ€æƒ³ã€‘
        - åå°„ï¼šdir() è·å–æ¨¡å—æ‰€æœ‰å±æ€§
        - ç±»å‹æ£€æŸ¥ï¼šåˆ¤æ–­æ˜¯å¦ä¸º BaseTool å­ç±»
        - å®ä¾‹åŒ–ï¼šåˆ›å»ºå·¥å…·å®ä¾‹
        """
        try:
            # ã€æ­¥éª¤1ã€‘åŠ¨æ€å¯¼å…¥æ¨¡å—
            module = importlib.import_module(module_path)

            # ã€æ­¥éª¤2ã€‘æ‰«ææ¨¡å—æ‰€æœ‰å±æ€§
            for attr_name in dir(module):
                attr = getattr(module, attr_name)

                # ã€æ­¥éª¤3ã€‘æ£€æŸ¥æ˜¯å¦ä¸ºå·¥å…·ç±»
                if (isinstance(attr, type) and
                    issubclass(attr, BaseTool) and
                    attr != BaseTool):  # æ’é™¤åŸºç±»æœ¬èº«

                    # ã€æ­¥éª¤4ã€‘å®ä¾‹åŒ–å¹¶æ³¨å†Œ
                    tool_instance = attr()
                    self._tools[tool_instance.name] = tool_instance

            return True
        except Exception as e:
            logger.error(f"Failed to register tools from {module_path}: {e}")
            return False

    def get_openai_tools_schema(self) -> List[dict]:
        """
        è½¬æ¢ä¸º OpenAI Function Calling æ ¼å¼

        ã€OpenAI æ ¼å¼ã€‘
        {
            "name": "get_weather",
            "description": "è·å–å¤©æ°”ä¿¡æ¯",
            "parameters": {
                "type": "object",
                "properties": {
                    "city": {"type": "string", "description": "åŸå¸‚å"}
                },
                "required": ["city"]
            }
        }

        ã€ç¼–ç¨‹æ€æƒ³ã€‘
        - é€‚é…å™¨æ¨¡å¼ï¼šè½¬æ¢ä¸åŒæ ¼å¼
        - æ¥å£ç»Ÿä¸€ï¼šLLM åªè®¤è¯†ä¸€ç§æ ¼å¼
        """
        return [tool.to_openai_schema() for tool in self._tools.values()]

    def get_tools_description(self, category: Optional[str] = None) -> str:
        """
        ç”Ÿæˆå·¥å…·æè¿°æ–‡æœ¬ï¼ˆç”¨äº System Promptï¼‰

        ã€ç”¨é€”ã€‘
        å‘Šè¯‰ LLM æœ‰å“ªäº›å·¥å…·å¯ç”¨ï¼Œå¦‚ä½•ä½¿ç”¨

        ã€è¿”å›ç¤ºä¾‹ã€‘
        ä½ å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å·¥å…·æ¥å¸®åŠ©ç”¨æˆ·ï¼š
        - **get_knowledge_node**: è·å–çŸ¥è¯†ç‚¹è¯¦ç»†ä¿¡æ¯
          å‚æ•°: {"node_id": {"type": "string", "description": "çŸ¥è¯†ç‚¹ID"}}
        - **create_task**: åˆ›å»ºå­¦ä¹ ä»»åŠ¡
          å‚æ•°: {"title": {"type": "string"}, "type": {"type": "string"}}
        """
        tools = self._tools.values()
        if category:
            tools = [t for t in tools if t.category == category]

        lines = ["ä½ å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å·¥å…·æ¥å¸®åŠ©ç”¨æˆ·ï¼š\n"]
        for tool in tools:
            lines.append(f"- **{tool.name}**: {tool.description}")
            if tool.parameters_schema:
                lines.append(f"  å‚æ•°: {json.dumps(tool.parameters_schema, indent=2)}")

        return "\n".join(lines)

    def get_tool(self, name: str) -> Optional[BaseTool]:
        """è·å–ç‰¹å®šå·¥å…·"""
        return self._tools.get(name)
```

**ã€ç¼–ç¨‹æ€æƒ³è¯¦è§£ã€‘**

1. **å•ä¾‹æ¨¡å¼ï¼ˆSingletonï¼‰**
   ```
   ç›®çš„ï¼šå…¨å±€å”¯ä¸€ï¼Œé¿å…é‡å¤æ³¨å†Œ

   å®ç°æ–¹å¼ï¼š
   - __new__ æ–¹æ³•æ§åˆ¶å®ä¾‹åˆ›å»º
   - ç±»å˜é‡å­˜å‚¨å®ä¾‹
   - æ¯æ¬¡è°ƒç”¨è¿”å›åŒä¸€å®ä¾‹

   ä¼˜ç‚¹ï¼šèŠ‚çœèµ„æºï¼Œä¿è¯ä¸€è‡´æ€§
   ```

2. **åå°„æœºåˆ¶ï¼ˆReflectionï¼‰**
   ```
   ä¼ ç»Ÿï¼šimport module; from module import Tool
   åå°„ï¼šåŠ¨æ€å¯¼å…¥ï¼Œæ— éœ€ç¡¬ç¼–ç 

   æ­¥éª¤ï¼š
   1. importlib.import_module("path")
   2. dir(module) è·å–æ‰€æœ‰å±æ€§
   3. getattr(module, name) è·å–å±æ€§
   4. isinstance() åˆ¤æ–­ç±»å‹
   ```

3. **é€‚é…å™¨æ¨¡å¼ï¼ˆAdapterï¼‰**
   ```
   å·¥å…·å†…éƒ¨æ ¼å¼ â†’ OpenAI æ ¼å¼

   ç›®çš„ï¼šå…¼å®¹ä¸åŒ LLM çš„å·¥å…·è°ƒç”¨æ ¼å¼
   - OpenAI: Function Calling
   - Anthropic: Tool Use
   - è‡ªç ”æ¨¡å‹: è‡ªå®šä¹‰æ ¼å¼
   ```

4. **æ¨¡å—åŒ–è®¾è®¡**
   ```
   app/tools/
   â”œâ”€â”€ knowledge_tools.py    # çŸ¥è¯†ç›¸å…³å·¥å…·
   â”œâ”€â”€ task_tools.py         # ä»»åŠ¡ç›¸å…³å·¥å…·
   â””â”€â”€ user_tools.py         # ç”¨æˆ·ç›¸å…³å·¥å…·

   æ¯ä¸ªæ¨¡å—ç‹¬ç«‹å¼€å‘ã€æµ‹è¯•
   æ³¨å†Œè¡¨è‡ªåŠ¨å‘ç°ï¼Œæ— éœ€ä¿®æ”¹æ ¸å¿ƒä»£ç 
   ```

**ã€å·¥å…·æ‰§è¡Œæµç¨‹ã€‘**
```
1. LLM å†³å®šè°ƒç”¨å·¥å…·
   â†“
2. è¿”å›å·¥å…·è°ƒç”¨è¯·æ±‚
   â†“
3. æ³¨å†Œè¡¨æŸ¥æ‰¾å·¥å…·
   â†“
4. æ‰§è¡Œå·¥å…·
   â†“
5. è¿”å›ç»“æœç»™ LLM
   â†“
6. LLM ç”Ÿæˆæœ€ç»ˆå›ç­”
```

**ã€è¯„å§”è€ƒå¯Ÿç‚¹ã€‘**

Q: ä¸ºä»€ä¹ˆç”¨åŠ¨æ€æ³¨å†Œè€Œä¸æ˜¯ç¡¬ç¼–ç ï¼Ÿ
- A: 1. æ‰©å±•æ€§å¥½ 2. æ¨¡å—åŒ– 3. æ— éœ€é‡å¯æœåŠ¡

Q: å¦‚æœå·¥å…·ç±»åå†²çªæ€ä¹ˆåŠï¼Ÿ
- A: 1. ä½¿ç”¨ä¸åŒæ¨¡å— 2. å·¥å…·åç§°å”¯ä¸€ 3. æ³¨å†Œæ—¶æ£€æŸ¥å†²çª

Q: åå°„æ€§èƒ½å¦‚ä½•ï¼Ÿ
- A: 1. åªåœ¨å¯åŠ¨æ—¶æ‰§è¡Œä¸€æ¬¡ 2. æ³¨å†Œåç¼“å­˜ 3. è¿è¡Œæ—¶æ— æ€§èƒ½å½±å“

Q: å¦‚ä½•ä¿è¯å·¥å…·çš„å®‰å…¨æ€§ï¼Ÿ
- A: 1. å·¥å…·æƒé™æ§åˆ¶ 2. å‚æ•°éªŒè¯ 3. æ²™ç®±æ‰§è¡Œ

---

### 3.5 LLM æœåŠ¡é›†æˆ

```python
# backend/app/services/llm_service.py

class LLMService:
    """
    LLM æœåŠ¡ - å¤šæ¨¡å‹æ”¯æŒ

    ã€è®¾è®¡æ€æƒ³ã€‘
    - ç­–ç•¥æ¨¡å¼ï¼šä¸åŒæ¨¡å‹ç”¨ä¸åŒ Provider
    - å·¥å‚æ¨¡å¼ï¼šæ ¹æ®é…ç½®åˆ›å»º Provider
    - ç»Ÿä¸€æ¥å£ï¼šæ‰€æœ‰ Provider å®ç°ç›¸åŒæ¥å£
    """

    def __init__(self, config):
        # ã€æ­¥éª¤1ã€‘å·¥å‚æ¨¡å¼åˆ›å»º Provider
        # ç¼–ç¨‹æ€æƒ³ï¼šæ ¹æ®é…ç½®åŠ¨æ€é€‰æ‹©å®ç°
        self.providers = {
            "qwen": QwenProvider(api_key=config.QWEN_API_KEY),
            "deepseek": DeepSeekProvider(api_key=config.DEEPSEEK_API_KEY),
            "openai": OpenAIProvider(api_key=config.OPENAI_API_KEY)
        }
        self.default_provider = config.DEFAULT_LLM_PROVIDER

    async def chat_stream_with_tools(
        self,
        messages: List[Dict],
        tools: List[Dict],
        user_id: str,
        model: Optional[str] = None
    ) -> AsyncIterator[LLMResponse]:
        """
        æµå¼èŠå¤© + å·¥å…·è°ƒç”¨ï¼ˆæ ¸å¿ƒæ–¹æ³•ï¼‰

        ã€æµç¨‹ã€‘
        1. ç¬¬ä¸€æ¬¡è°ƒç”¨ LLM
        2. LLM å¯èƒ½è¿”å›å·¥å…·è°ƒç”¨
        3. æ‰§è¡Œå·¥å…·
        4. ç¬¬äºŒæ¬¡è°ƒç”¨ LLMï¼ˆå¸¦å·¥å…·ç»“æœï¼‰
        5. LLM ç”Ÿæˆæœ€ç»ˆå›ç­”

        ã€ç¼–ç¨‹æ€æƒ³ã€‘
        - é€’å½’è°ƒç”¨ï¼šå¯èƒ½å¤šæ¬¡è°ƒç”¨ LLM
        - æµå¼å¤„ç†ï¼šé€å—è¿”å›
        - å·¥å…·ç¼–æ’ï¼šè‡ªåŠ¨æ‰§è¡Œå·¥å…·é“¾
        """
        provider = self.providers.get(model or self.default_provider)

        # ã€æ­¥éª¤1ã€‘é¦–æ¬¡è°ƒç”¨ï¼ˆå¯èƒ½è¿”å›å·¥å…·è°ƒç”¨ï¼‰
        response = await provider.chat_complete(
            messages=messages,
            tools=tools,
            stream=True  # æµå¼æ¨¡å¼
        )

        # ã€æ­¥éª¤2ã€‘æµå¼å¤„ç†å“åº”
        tool_calls = []
        async for chunk in response:
            if chunk.type == "text":
                # ç›´æ¥è¿”å›æ–‡æœ¬
                yield chunk

            elif chunk.type == "tool_call":
                # æ”¶é›†å·¥å…·è°ƒç”¨
                tool_calls.append(chunk.tool_call)

                # ã€æ­¥éª¤3ã€‘å·¥å…·è°ƒç”¨å®Œæˆï¼Œæ‰§è¡Œå·¥å…·
                if chunk.tool_call.finish_reason == "stop":
                    # æ‰§è¡Œæ‰€æœ‰å·¥å…·
                    tool_results = await self._execute_tools(tool_calls)

                    # ã€æ­¥éª¤4ã€‘å°†å·¥å…·ç»“æœåŠ å…¥ä¸Šä¸‹æ–‡
                    messages.extend([
                        {"role": "assistant", "tool_calls": tool_calls},
                        {"role": "tool", "content": json.dumps(tool_results)}
                    ])

                    # ã€æ­¥éª¤5ã€‘ç¬¬äºŒæ¬¡è°ƒç”¨ï¼ˆç”Ÿæˆæœ€ç»ˆå›ç­”ï¼‰
                    final_response = await provider.chat_complete(
                        messages=messages,
                        stream=True
                    )

                    # è¿”å›æœ€ç»ˆå›ç­”
                    async for final_chunk in final_response:
                        yield final_chunk

                    break  # é€€å‡ºå¾ªç¯

    async def _execute_tools(self, tool_calls: List[Dict]) -> List[Dict]:
        """æ‰§è¡Œå·¥å…·è°ƒç”¨"""
        results = []
        for call in tool_calls:
            # æŸ¥æ‰¾å·¥å…·
            tool = tool_registry.get_tool(call["name"])
            if tool:
                # æ‰§è¡Œå·¥å…·
                result = await tool.execute(**call["arguments"])
                results.append({
                    "tool_call_id": call["id"],
                    "result": result
                })
        return results
```

**ã€å·¥å…·è°ƒç”¨æµç¨‹å›¾ã€‘**
```
ç”¨æˆ·: "æŸ¥è¯¢æ˜å¤©åŒ—äº¬çš„å¤©æ°”"
    â†“
LLM: åˆ†ææ„å›¾ â†’ éœ€è¦è°ƒç”¨ get_weather å·¥å…·
    â†“
LLM: è¿”å›å·¥å…·è°ƒç”¨
    {
        "name": "get_weather",
        "arguments": {"city": "åŒ—äº¬", "date": "2025-12-28"}
    }
    â†“
ç³»ç»Ÿ: æ‰§è¡Œå·¥å…·
    â†“
å·¥å…·: è°ƒç”¨å¤©æ°” API â†’ è¿”å›ç»“æœ
    â†“
ç³»ç»Ÿ: å°†ç»“æœåŠ å…¥ä¸Šä¸‹æ–‡
    â†“
LLM: åŸºäºå·¥å…·ç»“æœç”Ÿæˆå›ç­”
    â†“
LLM: "æ˜å¤©åŒ—äº¬æ™´ï¼Œæ¸©åº¦ -2Â°C åˆ° 5Â°C"
```

**ã€ç¼–ç¨‹æ€æƒ³è¯¦è§£ã€‘**

1. **æµå¼å¤„ç†ï¼ˆStreamingï¼‰**
   ```
   ä¼ ç»Ÿï¼šç­‰å¾…å®Œæ•´å›ç­” â†’ ä¸€æ¬¡æ€§è¿”å›
   æµå¼ï¼šé€å­—/é€å—è¿”å›

   ä¼˜ç‚¹ï¼š
   - å“åº”å¿«ï¼ˆç”¨æˆ·ç«‹å³çœ‹åˆ°å†…å®¹ï¼‰
   - ä½“éªŒå¥½ï¼ˆæ‰“å­—æœºæ•ˆæœï¼‰
   - èŠ‚çœå†…å­˜ï¼ˆä¸éœ€è¦ç¼“å­˜å®Œæ•´ç»“æœï¼‰

   å®ç°ï¼šasync for + yield
   ```

2. **å·¥å…·ç¼–æ’ï¼ˆTool Orchestrationï¼‰**
   ```
   LLM â†’ å·¥å…·è°ƒç”¨ â†’ æ‰§è¡Œ â†’ ç»“æœ â†’ LLM â†’ æœ€ç»ˆå›ç­”

   è¿™æ˜¯ä¸€ä¸ªå¾ªç¯ï¼Œå¯èƒ½å¤šæ¬¡æ‰§è¡Œï¼š
   - å•å·¥å…·ï¼šä¸€æ¬¡è°ƒç”¨
   - å¤šå·¥å…·ï¼šé“¾å¼è°ƒç”¨
   - æ¡ä»¶å·¥å…·ï¼šæ ¹æ®ç»“æœå†³å®šä¸‹ä¸€æ­¥
   ```

3. **ä¸Šä¸‹æ–‡ç®¡ç†**
   ```
   messages åˆ—è¡¨æ¼”å˜ï¼š

   åˆå§‹: [
       {"role": "system", "content": "..."},
       {"role": "user", "content": "æŸ¥è¯¢å¤©æ°”"}
   ]

   LLM è¿”å›å·¥å…·è°ƒç”¨å: [
       ...,
       {"role": "assistant", "tool_calls": [...]},
       {"role": "tool", "content": "..."}
   ]

   ç¬¬äºŒæ¬¡è°ƒç”¨: LLM åŸºäºå®Œæ•´ä¸Šä¸‹æ–‡ç”Ÿæˆå›ç­”
   ```

**ã€è¯„å§”è€ƒå¯Ÿç‚¹ã€‘**

Q: ä¸ºä»€ä¹ˆéœ€è¦ä¸¤æ¬¡è°ƒç”¨ LLMï¼Ÿ
- A: ç¬¬ä¸€æ¬¡å†³å®šæ˜¯å¦ç”¨å·¥å…·ï¼Œç¬¬äºŒæ¬¡åŸºäºå·¥å…·ç»“æœç”Ÿæˆå›ç­”

Q: å¦‚æœå·¥å…·æ‰§è¡Œå¤±è´¥æ€ä¹ˆåŠï¼Ÿ
- A: 1. æ•è·å¼‚å¸¸ 2. è¿”å›é”™è¯¯ä¿¡æ¯ 3. LLM å¯ä»¥é‡è¯•æˆ–è°ƒæ•´ç­–ç•¥

Q: æµå¼å’Œéæµå¼çš„åŒºåˆ«ï¼Ÿ
- A: æµå¼ç”¨æˆ·ä½“éªŒå¥½ï¼Œä½†å®ç°å¤æ‚ï¼›éæµå¼ç®€å•ï¼Œä½†ç­‰å¾…æ—¶é—´é•¿

Q: å¦‚ä½•é˜²æ­¢å·¥å…·æ— é™å¾ªç¯ï¼Ÿ
- A: 1. è®¾ç½®æœ€å¤§è°ƒç”¨æ¬¡æ•° 2. å·¥å…·ç±»å‹é™åˆ¶ 3. LLM è‡ªæˆ‘çº¦æŸ

---

## 4. Flutter Mobile - è·¨å¹³å°ç§»åŠ¨ç«¯

### 4.1 WebSocket æœåŠ¡ v2

```dart
// mobile/lib/core/services/websocket_chat_service_v2.dart

class WebSocketChatServiceV2 {
  // ã€å•ä¾‹æ¨¡å¼ã€‘
  static final WebSocketChatServiceV2 _instance =
      WebSocketChatServiceV2._internal();
  factory WebSocketChatServiceV2() => _instance;

  // ã€çŠ¶æ€ç®¡ç†ã€‘
  WebSocketChannel? _channel;                    // WebSocket è¿æ¥é€šé“
  StreamController<ChatStreamEvent>? _messageStreamController; // æµæ§åˆ¶å™¨
  WsConnectionState _connectionState = WsConnectionState.disconnected; // è¿æ¥çŠ¶æ€
  Timer? _reconnectTimer;                        // é‡è¿å®šæ—¶å™¨
  Timer? _heartbeatTimer;                        // å¿ƒè·³å®šæ—¶å™¨
  int _reconnectAttempts = 0;                    // é‡è¿å°è¯•æ¬¡æ•°

  // ã€æ¶ˆæ¯é˜Ÿåˆ—ã€‘
  final List<Map<String, dynamic>> _pendingMessages = []; // å¾…å‘é€æ¶ˆæ¯

  // ã€ä¼šè¯ä¿¡æ¯ã€‘
  String? _currentUserId;
  String? _currentSessionId;

  WebSocketChatServiceV2._internal(); // ç§æœ‰æ„é€ å‡½æ•°

  // ä¸»æ–¹æ³•ï¼šå‘é€æ¶ˆæ¯
  Stream<ChatStreamEvent> sendMessage({
    required String message,
    required String userId,
    String? sessionId,
  }) {
    // ã€æ­¥éª¤1ã€‘åˆå§‹åŒ–æµæ§åˆ¶å™¨ï¼ˆå•ä¾‹æ¨¡å¼ï¼‰
    _messageStreamController ??= StreamController<ChatStreamEvent>.broadcast();

    // ã€æ­¥éª¤2ã€‘ä¿å­˜ä¸Šä¸‹æ–‡
    _currentUserId = userId;
    _currentSessionId = sessionId ?? _generateSessionId();

    // ã€æ­¥éª¤3ã€‘å»ºç«‹è¿æ¥ï¼ˆå¦‚æœéœ€è¦ï¼‰
    if (_shouldConnect(userId)) {
      _establishConnection(userId);
    }

    // ã€æ­¥éª¤4ã€‘æ„å»ºæ¶ˆæ¯è´Ÿè½½
    final payload = {
      'message': message,
      'session_id': _currentSessionId,
      'user_id': userId,
    };

    // ã€æ­¥éª¤5ã€‘å‘é€æˆ–æ’é˜Ÿ
    if (isConnected) {
      _sendMessage(payload);
    } else {
      _pendingMessages.add(payload); // è¿æ¥æœªå»ºç«‹ï¼ŒåŠ å…¥é˜Ÿåˆ—
      _tryReconnect(); // å°è¯•é‡è¿
    }

    // ã€æ­¥éª¤6ã€‘è¿”å›æµï¼ˆç›‘å¬å“åº”ï¼‰
    return _messageStreamController!.stream;
  }

  bool get isConnected => _connectionState == WsConnectionState.connected;

  // åˆ¤æ–­æ˜¯å¦éœ€è¦å»ºç«‹æ–°è¿æ¥
  bool _shouldConnect(String userId) {
    return _channel == null ||
           _connectionState == WsConnectionState.disconnected ||
           _currentUserId != userId;
  }

  // å»ºç«‹è¿æ¥
  void _establishConnection(String userId) {
    try {
      final wsUrl = '${ApiConstants.wsUrl}/ws/chat';
      _channel = WebSocketChannel.connect(Uri.parse(wsUrl));

      _connectionState = WsConnectionState.connecting;

      // ã€æ­¥éª¤1ã€‘ç›‘å¬æ¶ˆæ¯æµ
      _channel!.stream.listen(
        _handleMessage,      // æ¶ˆæ¯å¤„ç†
        onError: _handleError, // é”™è¯¯å¤„ç†
        onDone: _handleDisconnect, // è¿æ¥å…³é—­
        cancelOnError: false, // å‡ºé”™ä¸å–æ¶ˆç›‘å¬
      );

      // ã€æ­¥éª¤2ã€‘å‘é€è®¤è¯æ¶ˆæ¯
      _channel!.sink.add(json.encode({
        'type': 'auth',
        'token': getAuthToken(),
        'user_id': userId,
      }));

      _connectionState = WsConnectionState.connected;
      _reconnectAttempts = 0;

      // ã€æ­¥éª¤3ã€‘å¯åŠ¨å¿ƒè·³
      _startHeartbeat();

      // ã€æ­¥éª¤4ã€‘å‘é€å¾…å¤„ç†æ¶ˆæ¯
      _flushPendingMessages();

    } catch (e) {
      _handleError(e);
    }
  }

  // å‘é€æ¶ˆæ¯
  void _sendMessage(Map<String, dynamic> payload) {
    if (_channel != null && isConnected) {
      _channel!.sink.add(json.encode(payload));
    }
  }

  // å¤„ç†æ¥æ”¶åˆ°çš„æ¶ˆæ¯
  void _handleMessage(dynamic data) {
    try {
      final message = json.decode(data);
      final event = _parseEvent(message);

      if (event != null && !_messageStreamController!.isClosed) {
        _messageStreamController!.add(event);
      }
    } catch (e) {
      _handleError(e);
    }
  }

  // è§£æäº‹ä»¶ç±»å‹
  ChatStreamEvent? _parseEvent(Map<String, dynamic> message) {
    final type = message['type'];

    switch (type) {
      case 'text':
        return TextEvent(content: message['content']);

      case 'status':
        return StatusUpdateEvent(
          state: AgentState.fromString(message['state']),
          details: message['details'],
        );

      case 'tool_start':
        return ToolStartEvent(toolName: message['tool_name']);

      case 'tool_result':
        return ToolResultEvent(
          toolName: message['tool_name'],
          result: message['result'],
        );

      case 'error':
        return ErrorEvent(
          code: message['code'],
          message: message['message'],
        );

      case 'done':
        return DoneEvent();

      default:
        return null;
    }
  }

  // é‡è¿æœºåˆ¶ï¼ˆæŒ‡æ•°é€€é¿ï¼‰
  void _handleDisconnect() {
    _connectionState = WsConnectionState.disconnected;
    _cancelHeartbeat();

    if (_reconnectAttempts < 5) {
      _triggerReconnect();
    } else {
      _messageStreamController?.add(
        ErrorEvent(code: 'MAX_RETRIES', message: 'æ— æ³•è¿æ¥åˆ°æœåŠ¡å™¨')
      );
    }
  }

  void _triggerReconnect() {
    _reconnectAttempts++;

    // æŒ‡æ•°é€€é¿ï¼š2^1, 2^2, 2^3, 2^4, 2^5 ç§’
    final delaySeconds = math.min(math.pow(2, _reconnectAttempts).toInt(), 32);

    _reconnectTimer = Timer(Duration(seconds: delaySeconds), () {
      if (_currentUserId != null) {
        _establishConnection(_currentUserId!);
      }
    });
  }

  // å¿ƒè·³ä¿æ´»
  void _startHeartbeat() {
    _cancelHeartbeat();

    _heartbeatTimer = Timer.periodic(Duration(seconds: 30), (timer) {
      if (isConnected && _channel != null) {
        _channel!.sink.add(json.encode({'type': 'ping'}));
      }
    });
  }

  void _cancelHeartbeat() {
    _heartbeatTimer?.cancel();
    _heartbeatTimer = null;
  }

  // å‘é€å¾…å¤„ç†æ¶ˆæ¯
  void _flushPendingMessages() {
    if (_pendingMessages.isNotEmpty && isConnected) {
      for (var message in _pendingMessages) {
        _sendMessage(message);
      }
      _pendingMessages.clear();
    }
  }
}
```

**ã€ç¼–ç¨‹æ€æƒ³è¯¦è§£ã€‘**

1. **å•ä¾‹æ¨¡å¼ï¼ˆSingletonï¼‰**
   ```dart
   // ç§æœ‰æ„é€ å‡½æ•°
   WebSocketChatServiceV2._internal();

   // é™æ€å®ä¾‹
   static final _instance = WebSocketChatServiceV2._internal();

   // å·¥å‚æ„é€ å‡½æ•°
   factory WebSocketChatServiceV2() => _instance;

   // ä½¿ç”¨ï¼šWebSocketChatServiceV2() æ€»æ˜¯è¿”å›åŒä¸€å®ä¾‹
   ```

   **ç›®çš„**ï¼šå…¨å±€å”¯ä¸€ï¼Œé¿å…é‡å¤è¿æ¥

2. **æµå¼ç¼–ç¨‹ï¼ˆStreamï¼‰**
   ```dart
   StreamController<ChatStreamEvent> controller =
       StreamController<ChatStreamEvent>.broadcast();

   // å‘é€ç«¯
   controller.add(event);

   // æ¥æ”¶ç«¯
   controller.stream.listen((event) { ... });
   ```

   **ä¼˜ç‚¹**ï¼šå¼‚æ­¥ã€äº‹ä»¶é©±åŠ¨ã€å¯ç»„åˆ

3. **çŠ¶æ€æœºï¼ˆState Machineï¼‰**
   ```
   disconnected â†’ connecting â†’ connected â†’ disconnected
                     â†“              â†“
                     error          disconnect
   ```

   **ç›®çš„**ï¼šæ¸…æ™°ç®¡ç†è¿æ¥ç”Ÿå‘½å‘¨æœŸ

4. **æŒ‡æ•°é€€é¿ï¼ˆExponential Backoffï¼‰**
   ```
   é‡è¿æ¬¡æ•°: 1   2   3   4   5
   ç­‰å¾…æ—¶é—´: 2   4   8   16  32 ç§’

   ç›®çš„ï¼šé¿å…æœåŠ¡å™¨å‹åŠ›ï¼Œç»™æ¢å¤æ—¶é—´
   ```

**ã€å‰åç«¯äº¤äº’ã€‘**
```
Flutter: sendMessage()
    â†“
WebSocket: å»ºç«‹è¿æ¥
    â†“
Go: HandleWebSocket()
    â†“
Python: å¤„ç†è¯·æ±‚
    â†“
Flutter: _handleMessage() â†’ _parseEvent()
    â†“
UI: æ ¹æ®äº‹ä»¶ç±»å‹æ›´æ–°ç•Œé¢
```

**ã€è¯„å§”è€ƒå¯Ÿç‚¹ã€‘**

Q: ä¸ºä»€ä¹ˆç”¨å•ä¾‹æ¨¡å¼ï¼Ÿ
- A: 1. é¿å…é‡å¤è¿æ¥ 2. å…¨å±€å…±äº«çŠ¶æ€ 3. èŠ‚çœèµ„æº

Q: StreamController ä¸ºä»€ä¹ˆè¦ broadcastï¼Ÿ
- A: broadcast å…è®¸å¤šä¸ªç›‘å¬å™¨ï¼Œé broadcast åªèƒ½æœ‰ä¸€ä¸ª

Q: æŒ‡æ•°é€€é¿çš„æœ€å¤§å€¼ä¸ºä»€ä¹ˆæ˜¯ 32 ç§’ï¼Ÿ
- A: 1. é¿å…ç­‰å¾…è¿‡é•¿ 2. ç»™ç”¨æˆ·åé¦ˆ 3. å¹³è¡¡ç”¨æˆ·ä½“éªŒå’ŒæœåŠ¡å™¨å‹åŠ›

Q: å¾…å¤„ç†æ¶ˆæ¯é˜Ÿåˆ—çš„ä½œç”¨ï¼Ÿ
- A: è¿æ¥æ–­å¼€æ—¶æš‚å­˜æ¶ˆæ¯ï¼Œé‡è¿åè‡ªåŠ¨å‘é€ï¼Œé˜²æ­¢æ¶ˆæ¯ä¸¢å¤±

---

### 4.2 Riverpod çŠ¶æ€ç®¡ç†

```dart
// mobile/lib/presentation/providers/chat_provider.dart

// ã€æ­¥éª¤1ã€‘WebSocket æœåŠ¡ Provider
// ç¼–ç¨‹æ€æƒ³ï¼šä¾èµ–æ³¨å…¥ï¼Œå…¨å±€å•ä¾‹
final webSocketServiceProvider = Provider<WebSocketChatServiceV2>((ref) {
  return WebSocketChatServiceV2();
});

// ã€æ­¥éª¤2ã€‘èŠå¤©çŠ¶æ€ Notifier
// ç¼–ç¨‹æ€æƒ³ï¼šçŠ¶æ€ç®¡ç†ï¼Œåˆ†ç¦» UI å’Œä¸šåŠ¡é€»è¾‘
final chatProvider = StateNotifierProvider<ChatNotifier, ChatState>((ref) {
  return ChatNotifier(ref.watch(webSocketServiceProvider));
});

// ã€æ­¥éª¤3ã€‘èŠå¤©çŠ¶æ€æ•°æ®ç±»
// ç¼–ç¨‹æ€æƒ³ï¼šä¸å¯å˜æ•°æ®ï¼Œä½¿ç”¨ freezed ç”Ÿæˆ
@freezed
class ChatState with _$ChatState {
  const factory ChatState({
    @Default([]) List<ChatMessage> messages,      // æ¶ˆæ¯åˆ—è¡¨
    @Default(false) bool isLoading,               // åŠ è½½çŠ¶æ€
    @Default('') String response,                 // AI å“åº”ï¼ˆæµå¼ï¼‰
    @Default('') String error,                    // é”™è¯¯ä¿¡æ¯
    @Default(null) AgentState? agentStatus,       // ä»£ç†çŠ¶æ€
    @Default(null) String? toolCalling,           // æ­£åœ¨è°ƒç”¨çš„å·¥å…·
    @Default(false) bool isTyping,                // æ‰“å­—çŠ¶æ€
  }) = _ChatState;
}

// ã€æ­¥éª¤4ã€‘èŠå¤© Notifierï¼ˆä¸šåŠ¡é€»è¾‘ï¼‰
class ChatNotifier extends StateNotifier<ChatState> {
  final WebSocketChatServiceV2 _wsService;
  StreamSubscription? _subscription; // æµè®¢é˜…

  ChatNotifier(this._wsService) : super(ChatState());

  // å‘é€æ¶ˆæ¯ï¼ˆæ ¸å¿ƒæ–¹æ³•ï¼‰
  Future<void> sendMessage(String message) async {
    // ã€æ­¥éª¤1ã€‘æ›´æ–°æœ¬åœ°çŠ¶æ€ï¼ˆç«‹å³åé¦ˆï¼‰
    state = state.copyWith(
      messages: [
        ...state.messages,
        ChatMessage(role: 'user', content: message, timestamp: DateTime.now()),
      ],
      isLoading: true,  // æ˜¾ç¤ºåŠ è½½åŠ¨ç”»
      error: '',        // æ¸…ç©ºé”™è¯¯
      response: '',     // æ¸…ç©ºå“åº”
    );

    // ã€æ­¥éª¤2ã€‘å‘é€æ¶ˆæ¯å¹¶ç›‘å¬å“åº”
    final stream = _wsService.sendMessage(
      message: message,
      userId: _getUserId(),
      sessionId: _getSessionId(),
    );

    // ã€æ­¥éª¤3ã€‘å–æ¶ˆä¹‹å‰çš„è®¢é˜…ï¼ˆé˜²æ­¢å†…å­˜æ³„æ¼ï¼‰
    await _subscription?.cancel();

    // ã€æ­¥éª¤4ã€‘è®¢é˜…æ–°æµï¼ˆç›‘å¬å“åº”ï¼‰
    _subscription = stream.listen(
      (event) => _handleStreamEvent(event),
      onError: _handleError,
      onDone: _handleDone,
    );
  }

  // å¤„ç†æµå¼äº‹ä»¶
  void _handleStreamEvent(ChatStreamEvent event) {
    event.when(
      // æ–‡æœ¬äº‹ä»¶ï¼šé€æ­¥æ›´æ–°å“åº”
      text: (content) {
        state = state.copyWith(
          response: state.response + content,
          isTyping: true,
        );
      },

      // çŠ¶æ€æ›´æ–°ï¼šæ˜¾ç¤º AI æ€è€ƒè¿‡ç¨‹
      statusUpdate: (agentState, details) {
        state = state.copyWith(
          agentStatus: agentState,
          isTyping: agentState != AgentState.done,
        );

        if (details != null) {
          _showStatusNotification(details);
        }
      },

      // å·¥å…·è°ƒç”¨å¼€å§‹
      toolStart: (toolName) {
        state = state.copyWith(toolCalling: toolName);
      },

      // å·¥å…·è°ƒç”¨ç»“æœ
      toolResult: (toolName, result) {
        _showToolResult(toolName, result);
      },

      // é”™è¯¯å¤„ç†
      error: (code, message) {
        state = state.copyWith(
          error: message,
          isLoading: false,
          isTyping: false,
        );
      },

      // å®Œæˆäº‹ä»¶
      done: () {
        _handleDone();
      },
    );
  }

  // å¤„ç†å®Œæˆ
  void _handleDone() {
    if (state.response.isNotEmpty) {
      // æ·»åŠ  AI æ¶ˆæ¯åˆ°åˆ—è¡¨
      state = state.copyWith(
        messages: [
          ...state.messages,
          ChatMessage(
            role: 'assistant',
            content: state.response,
            timestamp: DateTime.now(),
          ),
        ],
        isLoading: false,
        isTyping: false,
        agentStatus: null,
        toolCalling: null,
      );
    }
  }

  // é”™è¯¯å¤„ç†
  void _handleError(dynamic error) {
    state = state.copyWith(
      error: error.toString(),
      isLoading: false,
      isTyping: false,
    );
  }

  @override
  void dispose() {
    // æ¸…ç†èµ„æº
    _subscription?.cancel();
    super.dispose();
  }
}
```

**ã€ç¼–ç¨‹æ€æƒ³è¯¦è§£ã€‘**

1. **Provider æ¨¡å¼ï¼ˆä¾èµ–æ³¨å…¥ï¼‰**
   ```
   Provider: æä¾›ä¾èµ–
   Consumer: æ¶ˆè´¹ä¾èµ–

   ä¼˜ç‚¹ï¼š
   - æµ‹è¯•å‹å¥½ï¼ˆå¯ mockï¼‰
   - ä»£ç è§£è€¦
   - ç”Ÿå‘½å‘¨æœŸç®¡ç†
   ```

2. **çŠ¶æ€ç®¡ç†ï¼ˆState Managementï¼‰**
   ```
   StateNotifier: çŠ¶æ€å®¹å™¨
   State: ä¸å¯å˜æ•°æ®
   Notifier: ä¿®æ”¹çŠ¶æ€çš„é€»è¾‘

   æµç¨‹ï¼š
   UI â†’ Notifier â†’ ä¿®æ”¹ State â†’ UI é‡å»º
   ```

3. **å“åº”å¼ç¼–ç¨‹ï¼ˆReactiveï¼‰**
   ```
   Stream.listen((event) => æ›´æ–°çŠ¶æ€)

   ç‰¹ç‚¹ï¼š
   - äº‹ä»¶é©±åŠ¨
   - å¼‚æ­¥å¤„ç†
   - æ•°æ®æµ
   ```

4. **ä¸å¯å˜æ•°æ®ï¼ˆImmutableï¼‰**
   ```dart
   // ä½¿ç”¨ freezed ç”Ÿæˆ
   @freezed
   class ChatState with _$ChatState {
     const factory ChatState({
       @Default([]) List<ChatMessage> messages,
     }) = _ChatState;
   }

   // ä¿®æ”¹æ—¶åˆ›å»ºæ–°å¯¹è±¡
   state = state.copyWith(messages: [...state.messages, newMessage]);
   ```

   **ä¼˜ç‚¹**ï¼šå¯é¢„æµ‹ã€æ˜“è°ƒè¯•ã€çº¿ç¨‹å®‰å…¨

**ã€çŠ¶æ€æµè½¬ã€‘**
```
åˆå§‹çŠ¶æ€: ChatState(messages: [], isLoading: false)

ç”¨æˆ·å‘é€æ¶ˆæ¯:
  â†’ state = state.copyWith(isLoading: true, messages: [...])

æ¥æ”¶æµå¼å“åº”:
  â†’ state = state.copyWith(response: "æœºå™¨å­¦ä¹ ", isTyping: true)

å®Œæˆ:
  â†’ state = state.copyWith(
       messages: [..., AIæ¶ˆæ¯],
       isLoading: false,
       isTyping: false
     )
```

**ã€è¯„å§”è€ƒå¯Ÿç‚¹ã€‘**

Q: ä¸ºä»€ä¹ˆç”¨ Riverpod è€Œä¸æ˜¯ setStateï¼Ÿ
- A: 1. çŠ¶æ€å…±äº« 2. ä»£ç ç»„ç»‡ 3. æ€§èƒ½ä¼˜åŒ– 4. æµ‹è¯•å‹å¥½

Q: StateNotifier å’Œ ChangeNotifier çš„åŒºåˆ«ï¼Ÿ
- A: StateNotifier ä¸å¯å˜ï¼ŒChangeNotifier å¯å˜ã€‚StateNotifier æ›´å®‰å…¨

Q: ä¸ºä»€ä¹ˆç”¨ freezedï¼Ÿ
- A: 1. ä¸å¯å˜æ•°æ® 2. è‡ªåŠ¨ç”Ÿæˆä»£ç  3. æ¨¡å¼åŒ¹é… 4. å‡å°‘æ ·æ¿ä»£ç 

Q: StreamSubscription ä¸ºä»€ä¹ˆè¦å–æ¶ˆï¼Ÿ
- A: é˜²æ­¢å†…å­˜æ³„æ¼ï¼Œä¸ä½¿ç”¨çš„æµåº”è¯¥åŠæ—¶é‡Šæ”¾

---

## 5. æ•°æ®åº“æ¶æ„æ·±åº¦è§£æ

### 5.1 çŸ¥è¯†ç³»ç»Ÿæ ¸å¿ƒè¡¨

```sql
-- ============================================
-- çŸ¥è¯†èŠ‚ç‚¹è¡¨ (Knowledge Nodes)
-- å­˜å‚¨çŸ¥è¯†ç‚¹åŠå…¶å‘é‡åµŒå…¥
-- ç¼–ç¨‹æ€æƒ³ï¼šå…³ç³»å‹æ•°æ® + å‘é‡æ•°æ®ä¸€ä½“åŒ–
-- ============================================
CREATE TABLE knowledge_nodes (
    -- ä¸»é”®ï¼šUUIDï¼Œå…¨å±€å”¯ä¸€
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

    -- çŸ¥è¯†ç‚¹åç§°
    name VARCHAR(255) NOT NULL,

    -- è¯¦ç»†æè¿°
    description TEXT,

    -- å‘é‡åµŒå…¥ï¼š1536 ç»´ï¼ˆOpenAI ada-002 æ¨¡å‹ï¼‰
    -- ç¼–ç¨‹æ€æƒ³ï¼šå‘é‡æœç´¢ï¼Œè¯­ä¹‰ç›¸ä¼¼åº¦
    embedding VECTOR(1536),

    -- çˆ¶èŠ‚ç‚¹IDï¼šæ ‘å½¢ç»“æ„
    -- ç¼–ç¨‹æ€æƒ³ï¼šå±‚çº§å…³ç³»ï¼Œæ”¯æŒçŸ¥è¯†ä½“ç³»
    parent_id UUID REFERENCES knowledge_nodes(id),

    -- å­¦ç§‘IDï¼šåˆ†ç±»
    subject_id INTEGER REFERENCES subjects(id),

    -- é‡è¦åº¦ï¼š1-5çº§
    -- ç¼–ç¨‹æ€æƒ³ï¼šæƒé‡ï¼Œå½±å“æ¨èå’Œè¡°å‡
    importance_level INTEGER NOT NULL DEFAULT 1,

    -- ç§å­èŠ‚ç‚¹ï¼šæ˜¯å¦ä¸ºåˆå§‹çŸ¥è¯†ç‚¹
    is_seed BOOLEAN DEFAULT FALSE,

    -- å…³é”®è¯ï¼šJSON æ ¼å¼ï¼Œæ”¯æŒå¤šå…³é”®è¯
    keywords JSONB,

    -- åˆ›å»ºæ—¶é—´
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),

    -- æ›´æ–°æ—¶é—´
    updated_at TIMESTAMP NOT NULL DEFAULT NOW(),

    -- çº¦æŸï¼šé‡è¦åº¦èŒƒå›´
    CONSTRAINT chk_importance CHECK (importance_level BETWEEN 1 AND 5)
);

-- ã€ç´¢å¼•ä¼˜åŒ–ã€‘

-- HNSW ç´¢å¼•ï¼šé«˜æ€§èƒ½å‘é‡æœç´¢
-- ç¼–ç¨‹æ€æƒ³ï¼šè¿‘ä¼¼æœ€è¿‘é‚»æœç´¢ï¼Œå¹³è¡¡ç²¾åº¦å’Œé€Ÿåº¦
CREATE INDEX idx_knowledge_nodes_embedding_hnsw
ON knowledge_nodes
USING hnsw (embedding vector_cosine_ops)
WITH (
    m = 16,              -- æ¯ä¸ªèŠ‚ç‚¹çš„é‚»å±…æ•°
    ef_construction = 64, -- æ„å»ºæ—¶çš„æœç´¢èŒƒå›´
    ef_search = 40       -- æŸ¥è¯¢æ—¶çš„æœç´¢èŒƒå›´
);

-- B-Tree ç´¢å¼•ï¼šç²¾ç¡®æŸ¥è¯¢
CREATE INDEX idx_knowledge_nodes_parent ON knowledge_nodes(parent_id);
CREATE INDEX idx_knowledge_nodes_subject ON knowledge_nodes(subject_id);

-- ============================================
-- ç”¨æˆ·èŠ‚ç‚¹çŠ¶æ€è¡¨ (User Node Status)
-- è®°å½•ç”¨æˆ·å¯¹æ¯ä¸ªçŸ¥è¯†ç‚¹çš„æŒæ¡åº¦
-- ç¼–ç¨‹æ€æƒ³ï¼šç”¨æˆ·æ•°æ®ä¸çŸ¥è¯†æ•°æ®åˆ†ç¦»
-- ============================================
CREATE TABLE user_node_status (
    user_id UUID NOT NULL,
    node_id UUID NOT NULL,

    -- æŒæ¡åº¦ï¼š0-100
    mastery_score DOUBLE PRECISION NOT NULL DEFAULT 0,

    -- æ€»å­¦ä¹ æ—¶é•¿ï¼ˆåˆ†é’Ÿï¼‰
    total_study_minutes INTEGER NOT NULL DEFAULT 0,

    -- å­¦ä¹ æ¬¡æ•°
    study_count INTEGER DEFAULT 0,

    -- æ˜¯å¦è§£é”
    is_unlocked BOOLEAN NOT NULL DEFAULT FALSE,

    -- æ˜¯å¦æŠ˜å ï¼ˆUI å±•ç¤ºï¼‰
    is_collapsed BOOLEAN DEFAULT FALSE,

    -- æ˜¯å¦æ”¶è—
    is_favorite BOOLEAN DEFAULT FALSE,

    -- æœ€åå­¦ä¹ æ—¶é—´
    last_study_at TIMESTAMP,

    -- ä¸‹æ¬¡å¤ä¹ æ—¶é—´ï¼ˆè‰¾å®¾æµ©æ–¯ï¼‰
    next_review_at TIMESTAMP,

    -- æ˜¯å¦æš‚åœè¡°å‡
    decay_paused BOOLEAN DEFAULT FALSE,

    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW(),

    PRIMARY KEY (user_id, node_id),
    CONSTRAINT chk_mastery CHECK (mastery_score BETWEEN 0 AND 100)
);

-- ã€ç´¢å¼•ä¼˜åŒ–ã€‘

-- å¤åˆç´¢å¼•ï¼šæŸ¥è¯¢ç”¨æˆ·è¿›åº¦
CREATE INDEX idx_user_node_status_unlocked
ON user_node_status(user_id, is_unlocked)
WHERE is_unlocked = TRUE;  -- éƒ¨åˆ†ç´¢å¼•ï¼Œåªç´¢å¼•è§£é”çš„

-- å¤åˆç´¢å¼•ï¼šæŸ¥è¯¢å¾…å¤ä¹ 
CREATE INDEX idx_user_node_status_review
ON user_node_status(user_id, next_review_at)
WHERE next_review_at IS NOT NULL;

-- ============================================
-- èŠ‚ç‚¹å…³ç³»è¡¨ (Node Relations)
-- çŸ¥è¯†å›¾è°±è¾¹ï¼Œå­˜å‚¨èŠ‚ç‚¹é—´å…³ç³»
-- ç¼–ç¨‹æ€æƒ³ï¼šå›¾æ•°æ®åº“æ€æƒ³åœ¨å…³ç³»æ•°æ®åº“ä¸­çš„å®ç°
-- ============================================
CREATE TABLE node_relations (
    source_node_id UUID NOT NULL REFERENCES knowledge_nodes(id),
    target_node_id UUID NOT NULL REFERENCES knowledge_nodes(id),

    -- å…³ç³»ç±»å‹
    relation_type VARCHAR(30) NOT NULL,

    -- å…³ç³»å¼ºåº¦ï¼š0-1
    strength DOUBLE PRECISION DEFAULT 1.0,

    -- åˆ›å»ºè€…ï¼šsystem æˆ– user
    created_by VARCHAR(20) DEFAULT 'system',

    created_at TIMESTAMP NOT NULL DEFAULT NOW(),

    PRIMARY KEY (source_node_id, target_node_id),

    -- çº¦æŸï¼šå…³ç³»ç±»å‹æšä¸¾
    CONSTRAINT chk_relation_type CHECK (relation_type IN (
        'prerequisite',  -- å‰ç½®çŸ¥è¯†
        'related',       -- ç›¸å…³çŸ¥è¯†
        'parent',        -- çˆ¶èŠ‚ç‚¹
        'child',         -- å­èŠ‚ç‚¹
        'similar'        -- ç›¸ä¼¼çŸ¥è¯†
    ))
);

-- ã€ç´¢å¼•ä¼˜åŒ–ã€‘

-- å›¾éå†ç´¢å¼•
CREATE INDEX idx_node_relations_source ON node_relations(source_node_id);
CREATE INDEX idx_node_relations_target ON node_relations(target_node_id);

-- ============================================
-- å­¦ä¹ è®°å½•è¡¨ (Study Records)
-- è¯¦ç»†è®°å½•æ¯æ¬¡å­¦ä¹ è¡Œä¸º
-- ç¼–ç¨‹æ€æƒ³ï¼šå®¡è®¡æ—¥å¿—ï¼Œç”¨äºåˆ†æå’Œç»Ÿè®¡
-- ============================================
CREATE TABLE study_records (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL,
    node_id UUID NOT NULL,

    -- å­¦ä¹ æ—¶é•¿
    study_minutes INTEGER NOT NULL,

    -- æŒæ¡åº¦å˜åŒ–
    mastery_delta DOUBLE PRECISION NOT NULL,

    -- å­¦ä¹ æ–¹æ³•
    study_method VARCHAR(50),

    -- å®Œæˆæ—¶é—´
    completed_at TIMESTAMP NOT NULL DEFAULT NOW(),

    CONSTRAINT chk_minutes CHECK (study_minutes > 0)
);

-- ã€åˆ†åŒºè¡¨ä¼˜åŒ–ã€‘

-- æŒ‰æ—¶é—´åˆ†åŒºï¼ˆPostgreSQL 10+ï¼‰
CREATE TABLE study_records_2025_12 PARTITION OF study_records
    FOR VALUES FROM ('2025-12-01') TO ('2026-01-01');

-- BRIN ç´¢å¼•ï¼šæ—¶é—´åºåˆ—ä¼˜åŒ–
CREATE INDEX idx_study_records_brin
ON study_records USING BRIN (completed_at)
WITH (pages_per_range = 128);

-- ============================================
-- èŠ‚ç‚¹æ‹“å±•é˜Ÿåˆ— (Node Expansion Queue)
-- LLM è‡ªåŠ¨æ‹“å±•çŸ¥è¯†ç‚¹
-- ç¼–ç¨‹æ€æƒ³ï¼šå¼‚æ­¥ä»»åŠ¡é˜Ÿåˆ—
-- ============================================
CREATE TABLE node_expansion_queue (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    node_id UUID NOT NULL REFERENCES knowledge_nodes(id),

    -- çŠ¶æ€ï¼šå¾…å¤„ç†ã€å¤„ç†ä¸­ã€å·²å®Œæˆã€å¤±è´¥
    status VARCHAR(20) NOT NULL DEFAULT 'pending',

    -- ä¼˜å…ˆçº§ï¼š1-10
    priority INTEGER NOT NULL DEFAULT 5,

    -- æ‹“å±•ç»“æœ
    result JSONB,

    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    processed_at TIMESTAMP,

    CONSTRAINT chk_status CHECK (status IN ('pending', 'processing', 'completed', 'failed'))
);

-- ã€ç´¢å¼•ä¼˜åŒ–ã€‘

-- åªç´¢å¼•å¾…å¤„ç†ä»»åŠ¡
CREATE INDEX idx_expansion_queue_status
ON node_expansion_queue(status, priority)
WHERE status = 'pending';
```

**ã€æ•°æ®åº“è®¾è®¡æ€æƒ³ã€‘**

1. **å…³ç³»å‹ + å‘é‡å‹æ··åˆ**
   ```
   ä¼ ç»Ÿå…³ç³»å‹ï¼šç²¾ç¡®æŸ¥è¯¢ã€äº‹åŠ¡ã€ä¸€è‡´æ€§
   å‘é‡æ•°æ®åº“ï¼šè¯­ä¹‰æœç´¢ã€ç›¸ä¼¼åº¦

   PostgreSQL + pgvector = ä¸€ä½“åŒ–è§£å†³æ–¹æ¡ˆ
   ```

2. **ç”¨æˆ·æ•°æ®åˆ†ç¦»**
   ```
   knowledge_nodes: å…¬å…±çŸ¥è¯†ï¼ˆåªè¯»ï¼‰
   user_node_status: ç”¨æˆ·ä¸ªæ€§åŒ–æ•°æ®ï¼ˆè¯»å†™ï¼‰

   ä¼˜ç‚¹ï¼š
   - æ•°æ®å¤ç”¨
   - å‡å°‘å†—ä½™
   - æ˜“äºç»´æŠ¤
   ```

3. **å›¾æ•°æ®åº“æ€æƒ³**
   ```
   èŠ‚ç‚¹ï¼šknowledge_nodes
   è¾¹ï¼šnode_relations

   å¯ä»¥å®ç°ï¼š
   - æœ€çŸ­è·¯å¾„ï¼ˆæ¨èè·¯å¾„ï¼‰
   - å­å›¾æŸ¥è¯¢ï¼ˆçŸ¥è¯†ä½“ç³»ï¼‰
   - ç›¸ä¼¼åº¦æœç´¢ï¼ˆç›¸å…³æ¨èï¼‰
   ```

4. **åˆ†åŒºè¡¨ä¼˜åŒ–**
   ```
   å¤§è¡¨æŒ‰æ—¶é—´åˆ†åŒºï¼š
   - æŸ¥è¯¢æ€§èƒ½æå‡ï¼ˆåªæ‰«æç›¸å…³åˆ†åŒºï¼‰
   - æ˜“äºå½’æ¡£ï¼ˆåˆ é™¤æ—§åˆ†åŒºï¼‰
   - ç»´æŠ¤æ–¹ä¾¿ï¼ˆåˆ†åŒºç´¢å¼•ï¼‰
   ```

**ã€è¯„å§”è€ƒå¯Ÿç‚¹ã€‘**

Q: ä¸ºä»€ä¹ˆç”¨ UUID è€Œä¸æ˜¯è‡ªå¢ IDï¼Ÿ
- A: 1. åˆ†å¸ƒå¼å‹å¥½ 2. å®‰å…¨ï¼ˆä¸å¯é¢„æµ‹ï¼‰3. åˆå¹¶æ•°æ®æ–¹ä¾¿

Q: JSONB å’Œ JSON çš„åŒºåˆ«ï¼Ÿ
- A: JSONB äºŒè¿›åˆ¶å­˜å‚¨ï¼Œæ”¯æŒç´¢å¼•ï¼ŒæŸ¥è¯¢æ›´å¿«ï¼›JSON æ–‡æœ¬å­˜å‚¨

Q: éƒ¨åˆ†ç´¢å¼•çš„ä¼˜åŠ¿ï¼Ÿ
- A: 1. èŠ‚çœç©ºé—´ï¼ˆåªç´¢å¼•éœ€è¦çš„æ•°æ®ï¼‰2. æå‡æŸ¥è¯¢é€Ÿåº¦

Q: ä¸ºä»€ä¹ˆéœ€è¦å­¦ä¹ è®°å½•è¡¨ï¼Ÿ
- A: 1. å®¡è®¡è¿½è¸ª 2. æ•°æ®åˆ†æ 3. ç”¨æˆ·è¡Œä¸ºåˆ†æ

---

## 6. æ ¸å¿ƒåŠŸèƒ½å®ç°è¯¦è§£

### 6.1 çŸ¥è¯†æ˜Ÿå›¾ (Knowledge Galaxy)

```python
# backend/app/services/galaxy_service.py

class GalaxyService:
    """
    çŸ¥è¯†æ˜Ÿå›¾æ ¸å¿ƒæœåŠ¡

    ã€æ ¸å¿ƒåŠŸèƒ½ã€‘
    1. ç‚¹äº®çŸ¥è¯†ç‚¹ï¼šå­¦ä¹ åæ›´æ–°æŒæ¡åº¦
    2. æŒæ¡åº¦è®¡ç®—ï¼šåŸºäºå­¦ä¹ æ—¶é•¿ã€æ¬¡æ•°ã€é‡è¦åº¦
    3. é—å¿˜æ›²çº¿ï¼šè‰¾å®¾æµ©æ–¯ç®—æ³•
    4. æ··åˆæœç´¢ï¼šRAG v2.0
    """

    # å¸¸é‡é…ç½®
    BASE_MASTERY_POINTS = 5.0      # åŸºç¡€æŒæ¡åº¦ï¼ˆæ¯åˆ†é’Ÿï¼‰
    MAX_MASTERY = 100.0            # æœ€å¤§æŒæ¡åº¦
    MEMORY_HALF_LIFE_DAYS = 7.0    # è®°å¿†åŠè¡°æœŸï¼ˆå¤©ï¼‰
    DECAY_THRESHOLD = 10.0         # è¡°å‡é˜ˆå€¼ï¼ˆä¸ä½äº10ï¼‰

    async def spark_node(self, user_id: str, node_id: str,
                        study_minutes: int) -> SparkResult:
        """
        ç‚¹äº®çŸ¥è¯†ç‚¹ - æ ¸å¿ƒå­¦ä¹ æµç¨‹

        ã€æµç¨‹ã€‘
        1. è·å–/åˆ›å»ºç”¨æˆ·çŠ¶æ€
        2. è®¡ç®—æŒæ¡åº¦å¢é‡
        3. æ›´æ–°çŠ¶æ€
        4. è®°å½•å†å²
        5. è§¦å‘æ‹“å±•

        ã€ç¼–ç¨‹æ€æƒ³ã€‘
        - äº‹åŠ¡æ€§ï¼šå¤šä¸ªæ“ä½œè¦ä¹ˆå…¨æˆåŠŸï¼Œè¦ä¹ˆå…¨å¤±è´¥
        - å¹‚ç­‰æ€§ï¼šé‡å¤è°ƒç”¨ç»“æœä¸€è‡´
        """
        # ã€æ­¥éª¤1ã€‘è·å–æˆ–åˆ›å»ºç”¨æˆ·èŠ‚ç‚¹çŠ¶æ€
        # ç¼–ç¨‹æ€æƒ³ï¼šRepository æ¨¡å¼ï¼Œæ•°æ®è®¿é—®å±‚
        status = await self._get_or_create_status(user_id, node_id)

        # ã€æ­¥éª¤2ã€‘è®¡ç®—æŒæ¡åº¦å¢é‡
        # ç¼–ç¨‹æ€æƒ³ï¼šç®—æ³•å°è£…ï¼Œå¯é…ç½®ã€å¯æµ‹è¯•
        node = await self._get_node(node_id)
        mastery_delta = self._calculate_mastery_delta(
            study_minutes,
            node.importance_level,
            status.study_count
        )

        # ã€æ­¥éª¤3ã€‘æ›´æ–°çŠ¶æ€ï¼ˆäº‹åŠ¡ï¼‰
        # ç¼–ç¨‹æ€æƒ³ï¼šåŸå­æ“ä½œï¼Œä¿è¯ä¸€è‡´æ€§
        new_mastery = min(status.mastery_score + mastery_delta, 100)
        status.mastery_score = new_mastery
        status.total_study_minutes += study_minutes
        status.study_count += 1
        status.last_study_at = datetime.utcnow()
        status.is_unlocked = True

        # ã€æ­¥éª¤4ã€‘è®¡ç®—ä¸‹æ¬¡å¤ä¹ æ—¶é—´ï¼ˆè‰¾å®¾æµ©æ–¯ï¼‰
        if new_mastery >= 60:
            status.next_review_at = self._calculate_next_review(
                status.study_count,
                new_mastery
            )

        # ã€æ­¥éª¤5ã€‘è®°å½•å­¦ä¹ å†å²
        record = StudyRecord(
            user_id=user_id,
            node_id=node_id,
            study_minutes=study_minutes,
            mastery_delta=mastery_delta
        )
        self.db.add(record)

        # ã€æ­¥éª¤6ã€‘è§¦å‘ LLM æ‹“å±•ï¼ˆå­¦ä¹ 2æ¬¡åï¼‰
        if status.study_count >= 2:
            await self._queue_expansion(node_id)

        # ã€æ­¥éª¤7ã€‘æ›´æ–° Redis ç¼“å­˜
        await self._update_user_cache(user_id, node_id, status)

        return SparkResult(
            mastery_delta=mastery_delta,
            new_mastery=new_mastery,
            next_review_at=status.next_review_at,
            expansion_queued=(status.study_count >= 2)
        )

    def _calculate_mastery_delta(self, study_minutes: int,
                                importance: int, study_count: int) -> float:
        """
        æŒæ¡åº¦å¢é‡è®¡ç®—

        ã€å…¬å¼ã€‘
        å¢é‡ = åŸºç¡€åˆ† Ã— é‡è¦åº¦ç³»æ•° Ã— æ¬¡æ•°è¡°å‡ Ã— æ—¶é—´ç³»æ•°

        ã€å‚æ•°ã€‘
        study_minutes: å­¦ä¹ æ—¶é•¿ï¼ˆåˆ†é’Ÿï¼‰
        importance: é‡è¦åº¦ï¼ˆ1-5ï¼‰
        study_count: å·²å­¦ä¹ æ¬¡æ•°

        ã€è¿”å›ã€‘
        float: æŒæ¡åº¦å¢é‡ï¼ˆ0-20ï¼‰

        ã€ç¼–ç¨‹æ€æƒ³ã€‘
        - çº¯å‡½æ•°ï¼šç›¸åŒè¾“å…¥æ€»æ˜¯ç›¸åŒè¾“å‡º
        - å¯æµ‹è¯•ï¼šæ— å‰¯ä½œç”¨
        - å¯é…ç½®ï¼šå¸¸é‡å¯è°ƒæ•´
        """
        # åŸºç¡€åˆ†ï¼šæ¯åˆ†é’Ÿå­¦ä¹ å¢åŠ  5 ç‚¹
        base = study_minutes * self.BASE_MASTERY_POINTS

        # é‡è¦åº¦ç³»æ•°ï¼š1-5 çº§ï¼Œæœ€é«˜ 2.0 å€
        importance_factor = 1 + (importance - 1) * 0.25

        # æ¬¡æ•°è¡°å‡ï¼šå­¦ä¹ æ¬¡æ•°è¶Šå¤šï¼Œå¢é‡è¶Šå°
        # å…¬å¼ï¼š1 / (1 + n * 0.3)
        count_factor = 1.0 / (1 + study_count * 0.3)

        # æ—¶é—´ç³»æ•°ï¼šå­¦ä¹ æ—¶é—´è¶Šé•¿ï¼Œæ•ˆç‡è¶Šé«˜ï¼ˆå¯¹æ•°å¢é•¿ï¼‰
        # å…¬å¼ï¼š1 + log10(åˆ†é’Ÿ+1) * 0.2
        time_factor = 1 + math.log10(study_minutes + 1) * 0.2

        delta = base * importance_factor * count_factor * time_factor

        # å•æ¬¡ä¸Šé™ 20 ç‚¹ï¼Œé˜²æ­¢åˆ·åˆ†
        return min(delta, 20.0)

    def _calculate_next_review(self, study_count: int, mastery: float) -> datetime:
        """
        è‰¾å®¾æµ©æ–¯é—å¿˜æ›²çº¿è®¡ç®—å¤ä¹ æ—¶é—´

        ã€è‰¾å®¾æµ©æ–¯å…¬å¼ã€‘
        è®°å¿†ä¿ç•™ç‡ = 2^(-t / T_half)

        å…¶ä¸­ï¼š
        - t: ç»è¿‡æ—¶é—´ï¼ˆå¤©ï¼‰
        - T_half: åŠè¡°æœŸï¼ˆ7å¤©ï¼‰

        ã€ç­–ç•¥ã€‘
        æ ¹æ®å­¦ä¹ æ¬¡æ•°å’ŒæŒæ¡åº¦ï¼ŒåŠ¨æ€è°ƒæ•´å¤ä¹ é—´éš”

        ã€ç¼–ç¨‹æ€æƒ³ã€‘
        - ç®—æ³•å°è£…ï¼šç‹¬ç«‹å‡½æ•°ï¼Œæ˜“äºè°ƒæ•´
        - éšæœºå› å­ï¼šé¿å…æ‰€æœ‰ç”¨æˆ·åŒæ—¶å¤ä¹ 
        """
        # åŸºç¡€é—´éš”ï¼ˆå¤©ï¼‰
        if study_count <= 2:
            base_days = 1
        elif study_count <= 4:
            base_days = 3
        elif study_count <= 6:
            base_days = 7
        else:
            base_days = 14

        # æŒæ¡åº¦å½±å“ï¼šæŒæ¡åº¦è¶Šé«˜ï¼Œé—´éš”è¶Šé•¿
        mastery_factor = mastery / 50.0  # 0-2 å€

        # éšæœºå› å­ï¼šé¿å…æ‰€æœ‰ç”¨æˆ·åŒæ—¶å¤ä¹ ï¼ˆ0.8-1.2ï¼‰
        random_factor = random.uniform(0.8, 1.2)

        days = base_days * mastery_factor * random_factor

        return datetime.utcnow() + timedelta(days=days)

    async def hybrid_search(self, user_id: str, query: str,
                           vector_query: Optional[str] = None,
                           limit: int = 10) -> List[KnowledgeNode]:
        """
        RAG v2.0 æ··åˆæœç´¢

        ã€æµç¨‹ã€‘
        1. å‘é‡æœç´¢ï¼ˆè¯­ä¹‰ï¼‰
        2. å…³é”®è¯æœç´¢ï¼ˆç²¾ç¡®ï¼‰
        3. RRF èåˆ
        4. é‡æ’åº
        5. ç”¨æˆ·çŠ¶æ€è¿‡æ»¤

        ã€ç¼–ç¨‹æ€æƒ³ã€‘
        - å¹¶è¡Œæ‰§è¡Œï¼šasyncio.gather
        - èåˆç®—æ³•ï¼šRRFï¼ˆå€’æ•°æ’åèåˆï¼‰
        - å¤šé˜¶æ®µï¼šåˆ†å±‚ä¼˜åŒ–
        """
        # ã€æ­¥éª¤1ã€‘å‡†å¤‡æŸ¥è¯¢å‘é‡
        query_embedding = await self.llm.get_embedding(
            vector_query if vector_query else query
        )

        # ã€æ­¥éª¤2ã€‘å¹¶è¡Œæ‰§è¡Œå‘é‡æœç´¢å’Œå…³é”®è¯æœç´¢
        vector_task = self._vector_search(query_embedding, limit * 10)
        keyword_task = self._keyword_search(query, limit * 10)

        vector_results, keyword_results = await asyncio.gather(
            vector_task, keyword_task
        )

        # ã€æ­¥éª¤3ã€‘RRF (Reciprocal Rank Fusion) èåˆ
        fused = self._reciprocal_rank_fusion(
            vector_results,
            keyword_results,
            weight_vector=0.7,    # å‘é‡æƒé‡
            weight_keyword=0.3    # å…³é”®è¯æƒé‡
        )

        # ã€æ­¥éª¤4ã€‘é‡æ’åºï¼ˆRe-rankingï¼‰
        reranked = await self._rerank(query, fused, limit)

        # ã€æ­¥éª¤5ã€‘è·å–å®Œæ•´èŠ‚ç‚¹å¹¶è¿‡æ»¤ç”¨æˆ·çŠ¶æ€
        nodes = await self._get_nodes_by_ids([r.node_id for r in reranked])
        filtered = await self._filter_by_user_status(user_id, nodes)

        return filtered

    def _reciprocal_rank_fusion(self, vector_results, keyword_results,
                               weight_vector=0.7, weight_keyword=0.3):
        """
        RRF èåˆç®—æ³•

        ã€å…¬å¼ã€‘
        score = w1 * (1 / (rank1 + 60)) + w2 * (1 / (rank2 + 60))

        ã€ç‰¹ç‚¹ã€‘
        - ä¸ä¾èµ–ç»å¯¹åˆ†æ•°
        - åªçœ‹æ’å
        - å¯åŠ æƒèåˆ

        ã€ç¼–ç¨‹æ€æƒ³ã€‘
        - æ•°å­¦å…¬å¼å®ç°
        - å­—å…¸èšåˆ
        - æ’åº
        """
        scores = {}

        # å‘é‡ç»“æœï¼šæƒé‡ 0.7
        for rank, result in enumerate(vector_results, 1):
            scores[result.node_id] = weight_vector * (1 / (rank + 60))

        # å…³é”®è¯ç»“æœï¼šæƒé‡ 0.3
        for rank, result in enumerate(keyword_results, 1):
            if result.node_id in scores:
                scores[result.node_id] += weight_keyword * (1 / (rank + 60))
            else:
                scores[result.node_id] = weight_keyword * (1 / (rank + 60))

        # æŒ‰åˆ†æ•°æ’åº
        sorted_results = sorted(scores.items(), key=lambda x: x[1], reverse=True)
        return [FusedResult(node_id=k, score=v) for k, v in sorted_results]
```

**ã€ç¼–ç¨‹æ€æƒ³è¯¦è§£ã€‘**

1. **ç®—æ³•å°è£…**
   ```
   å°†å¤æ‚è®¡ç®—å°è£…ä¸ºç‹¬ç«‹å‡½æ•°ï¼š
   - _calculate_mastery_deltaï¼šæŒæ¡åº¦è®¡ç®—
   - _calculate_next_reviewï¼šå¤ä¹ æ—¶é—´è®¡ç®—
   - _reciprocal_rank_fusionï¼šèåˆç®—æ³•

   ä¼˜ç‚¹ï¼šå¯æµ‹è¯•ã€å¯å¤ç”¨ã€å¯è°ƒæ•´
   ```

2. **å¹¶è¡Œæ‰§è¡Œ**
   ```python
   # ä¸²è¡Œï¼ˆæ…¢ï¼‰
   vector = await vector_search()
   keyword = await keyword_search()

   # å¹¶è¡Œï¼ˆå¿«ï¼‰
   vector_task = vector_search()
   keyword_task = keyword_search()
   vector, keyword = await asyncio.gather(vector_task, keyword_task)
   ```

3. **å¤šé˜¶æ®µå¤„ç†**
   ```
   é˜¶æ®µ1ï¼šå¬å›ï¼ˆæ‰©å¤§èŒƒå›´ï¼‰
   é˜¶æ®µ2ï¼šèåˆï¼ˆåˆå¹¶ç»“æœï¼‰
   é˜¶æ®µ3ï¼šç²¾æ’ï¼ˆç²¾é€‰topï¼‰
   é˜¶æ®µ4ï¼šè¿‡æ»¤ï¼ˆä¸ªæ€§åŒ–ï¼‰
   ```

4. **æƒé‡é…ç½®**
   ```
   å‘é‡æƒé‡ 0.7ï¼šè¯­ä¹‰åŒ¹é…ä¸ºä¸»
   å…³é”®è¯æƒé‡ 0.3ï¼šç²¾ç¡®åŒ¹é…ä¸ºè¾…

   å¯æ ¹æ®åœºæ™¯è°ƒæ•´ï¼š
   - æ¨¡ç³ŠæŸ¥è¯¢ï¼šå‘é‡æƒé‡æ›´é«˜
   - ç²¾ç¡®æŸ¥è¯¢ï¼šå…³é”®è¯æƒé‡æ›´é«˜
   ```

**ã€è¯„å§”è€ƒå¯Ÿç‚¹ã€‘**

Q: ä¸ºä»€ä¹ˆéœ€è¦æ··åˆæœç´¢ï¼Ÿ
- A: å•ä¸€æœç´¢æœ‰å±€é™ï¼šå‘é‡å¯èƒ½ä¸ç²¾ç¡®ï¼Œå…³é”®è¯å¯èƒ½ä¸å…¨é¢

Q: RRF ç®—æ³•çš„ä¼˜åŠ¿ï¼Ÿ
- A: 1. æ— éœ€è°ƒå‚ 2. å¯èåˆå¤šä¸ªæ¥æº 3. åªçœ‹æ’åï¼Œä¸ä¾èµ–åˆ†æ•°èŒƒå›´

Q: æŒæ¡åº¦è®¡ç®—å…¬å¼å¦‚ä½•è®¾è®¡ï¼Ÿ
- A: åŸºäºå­¦ä¹ ç†è®ºï¼šæ—¶é•¿ Ã— æ•ˆç‡ Ã— è¡°å‡ï¼Œå¯å®éªŒè°ƒæ•´

Q: è‰¾å®¾æµ©æ–¯ç®—æ³•çš„å®é™…æ•ˆæœï¼Ÿ
- A: åŸºäºè®°å¿†æ›²çº¿ï¼Œç§‘å­¦å®‰æ’å¤ä¹ æ—¶é—´ï¼Œæé«˜è®°å¿†ä¿ç•™ç‡

---

### 6.2 æ™ºèƒ½æ¨é€ç³»ç»Ÿ

```python
# backend/app/services/push_service.py

class PushService:
    """
    æ™ºèƒ½æ¨é€æœåŠ¡

    ã€ç­–ç•¥ä¼˜å…ˆçº§ã€‘
    1. Sprintï¼ˆå†²åˆºï¼‰ï¼šè®¡åˆ’å³å°†åˆ°æœŸ
    2. Curiosityï¼ˆå¥½å¥‡ï¼‰ï¼šæ–°çŸ¥è¯†ç‚¹æ¨è
    3. Memoryï¼ˆè®°å¿†ï¼‰ï¼šå¤ä¹ æé†’
    4. Inactivityï¼ˆæ´»è·ƒï¼‰ï¼šé˜²æ­¢æµå¤±

    ã€ç¼–ç¨‹æ€æƒ³ã€‘
    - ç­–ç•¥æ¨¡å¼ï¼šä¸åŒç­–ç•¥ç‹¬ç«‹å®ç°
    - ä¼˜å…ˆçº§é˜Ÿåˆ—ï¼šæŒ‰é‡è¦æ€§æ’åº
    - é¢‘ç‡æ§åˆ¶ï¼šé¿å…éªšæ‰°
    """

    def __init__(self, db, redis, llm_service):
        self.db = db
        self.redis = redis
        self.llm = llm_service

        # ç­–ç•¥å®ä¾‹
        self.sprint_strategy = SprintStrategy(db, redis)
        self.memory_strategy = MemoryStrategy(db, redis)
        self.inactivity_strategy = InactivityStrategy(db, redis)
        self.curiosity_strategy = CuriosityStrategy(db, redis)

    async def process_user_push(self, user: User) -> bool:
        """
        å¤„ç†å•ä¸ªç”¨æˆ·çš„æ¨é€é€»è¾‘

        ã€æµç¨‹ã€‘
        1. æ£€æŸ¥æ—¶åŒºå’Œæ´»è·ƒæ—¶æ®µ
        2. æ£€æŸ¥é¢‘ç‡é™åˆ¶
        3. è¯„ä¼°ç­–ç•¥ï¼ˆä¼˜å…ˆçº§ï¼‰
        4. ç”Ÿæˆå†…å®¹
        5. å‘é€æ¨é€
        6. è®°å½•å†å²

        ã€è¿”å›ã€‘
        bool: æ˜¯å¦æˆåŠŸæ¨é€

        ã€ç¼–ç¨‹æ€æƒ³ã€‘
        - ç®¡é“æ¨¡å¼ï¼šå¤šä¸ªæ£€æŸ¥æ­¥éª¤
        - çŸ­è·¯è¿”å›ï¼šä»»ä¸€æ£€æŸ¥å¤±è´¥ç«‹å³è¿”å›
        """
        # ã€æ­¥éª¤1ã€‘è·å–ç”¨æˆ·åå¥½
        pref = await self._get_push_preferences(user.id)

        # ã€æ­¥éª¤2ã€‘æ£€æŸ¥æ—¶åŒºå’Œæ´»è·ƒæ—¶æ®µ
        if not self._is_active_time(pref):
            return False

        # ã€æ­¥éª¤3ã€‘æ£€æŸ¥æ¯æ—¥ä¸Šé™
        if await self._check_daily_cap(user.id, pref.daily_cap):
            return False

        # ã€æ­¥éª¤4ã€‘æ£€æŸ¥å†·å´æœŸï¼ˆé¿å…é¢‘ç¹æ‰“æ‰°ï¼‰
        if await self._check_cooldown(user.id):
            return False

        # ã€æ­¥éª¤5ã€‘ç­–ç•¥è¯„ä¼°ï¼ˆä¼˜å…ˆçº§æ’åºï¼‰
        trigger_strategy, trigger_data = await self._evaluate_strategies(
            user, pref
        )

        if not trigger_strategy:
            return False

        # ã€æ­¥éª¤6ã€‘ç”Ÿæˆæ¨é€å†…å®¹
        content = await self._generate_push_content(
            user, trigger_strategy, trigger_data
        )

        # ã€æ­¥éª¤7ã€‘å‘é€æ¨é€
        success = await self._send_push(user, content)

        if success:
            # ã€æ­¥éª¤8ã€‘è®°å½•å†å²
            await self._record_push_history(
                user.id,
                trigger_strategy.name,
                content
            )

            # ã€æ­¥éª¤9ã€‘é‡ç½®å¿½ç•¥è®¡æ•°
            await self._reset_ignore_count(user.id)

        return success

    async def _evaluate_strategies(self, user: User, pref: PushPreferences):
        """
        ç­–ç•¥è¯„ä¼°ï¼ˆä¼˜å…ˆçº§ï¼šSprint > Curiosity > Memory > Inactivityï¼‰

        ã€ç¼–ç¨‹æ€æƒ³ã€‘
        - è´£ä»»é“¾ï¼šä¾æ¬¡è¯„ä¼°ï¼Œè¿”å›ç¬¬ä¸€ä¸ªæ»¡è¶³çš„
        - çŸ­è·¯ä¼˜åŒ–ï¼šæ‰¾åˆ°å³è¿”å›
        """
        # 1. å†²åˆºç­–ç•¥ï¼ˆæœ€é«˜ä¼˜å…ˆçº§ï¼‰
        if await self.sprint_strategy.should_trigger(user, pref):
            data = await self.sprint_strategy.get_trigger_data(user)
            return self.sprint_strategy, data

        # 2. å¥½å¥‡å¿ƒç­–ç•¥
        if pref.enable_curiosity and await self.curiosity_strategy.should_trigger(user, pref):
            data = await self.curiosity_strategy.get_trigger_data(user)
            return self.curiosity_strategy, data

        # 3. è®°å¿†ç­–ç•¥
        if await self.memory_strategy.should_trigger(user, pref):
            data = await self.memory_strategy.get_trigger_data(user)
            return self.memory_strategy, data

        # 4. æ´»è·ƒåº¦ç­–ç•¥
        if await self.inactivity_strategy.should_trigger(user, pref):
            data = await self.inactivity_strategy.get_trigger_data(user)
            return self.inactivity_strategy, data

        return None, None

    async def _generate_push_content(self, user: User, strategy, trigger_data: dict) -> dict:
        """
        ä½¿ç”¨ LLM ç”Ÿæˆä¸ªæ€§åŒ–æ¨é€å†…å®¹

        ã€ç¼–ç¨‹æ€æƒ³ã€‘
        - AI ç”Ÿæˆï¼šä¸ªæ€§åŒ–ã€è‡ªç„¶è¯­è¨€
        - æ¨¡æ¿åŒ–ï¼šç»“æ„åŒ–è¾“å‡º
        """
        prompt = f"""
        ä¸ºç”¨æˆ·ç”Ÿæˆä¸ªæ€§åŒ–æ¨é€å†…å®¹ï¼š

        ç”¨æˆ·ï¼š{user.nickname}
        ç­–ç•¥ï¼š{strategy.name}
        è§¦å‘æ•°æ®ï¼š{json.dumps(trigger_data, ensure_ascii=False)}

        è¦æ±‚ï¼š
        1. è¯­æ°”äº²åˆ‡ã€æ¿€åŠ±æ€§
        2. å†…å®¹å…·ä½“ã€æœ‰ä»·å€¼
        3. é•¿åº¦é€‚ä¸­ï¼ˆ50-100å­—ï¼‰
        4. åŒ…å«è¡ŒåŠ¨å·å¬

        è¿”å›æ ¼å¼ï¼š
        {{
            "title": "...",
            "body": "...",
            "data": {{"action": "...", "params": {{...}}}}
        }}
        """

        response = await self.llm.generate(
            messages=[{"role": "user", "content": prompt}],
            max_tokens=200,
            temperature=0.8
        )

        return json.loads(response.content)
```

**ã€ç­–ç•¥å®ç°ç¤ºä¾‹ã€‘**

```python
# backend/app/services/strategies/sprint.py

class SprintStrategy:
    """å†²åˆºç­–ç•¥ï¼šæ£€æµ‹æœªå®Œæˆçš„å†²åˆºè®¡åˆ’"""

    name = "sprint"

    async def should_trigger(self, user: User, pref: PushPreferences) -> bool:
        """æ£€æŸ¥æ˜¯å¦åº”è¯¥è§¦å‘"""
        # 1. è·å–æ´»è·ƒå†²åˆº
        sprint = await self._get_active_sprint(user.id)
        if not sprint:
            return False

        # 2. æ£€æŸ¥å‰©ä½™æ—¶é—´ï¼ˆ< 24 å°æ—¶ï¼‰
        time_left = sprint.end_date - datetime.utcnow().date()
        if time_left.days > 1:
            return False

        # 3. æ£€æŸ¥å®Œæˆåº¦ï¼ˆ< 80%ï¼‰
        progress = self._calculate_sprint_progress(sprint)
        if progress >= 80:
            return False

        # 4. æ£€æŸ¥ä»Šæ—¥æ˜¯å¦å·²æ¨é€
        if await self._has_today_sprint_push(user.id):
            return False

        return True

    async def get_trigger_data(self, user: User) -> dict:
        """è·å–è§¦å‘æ•°æ®"""
        sprint = await self._get_active_sprint(user.id)
        progress = self._calculate_sprint_progress(sprint)
        remaining_tasks = await self._get_remaining_tasks(user.id, sprint.id)

        return {
            "sprint_title": sprint.title,
            "progress": progress,
            "remaining_tasks": len(remaining_tasks),
            "due_date": sprint.end_date.isoformat(),
            "motivation_score": self._calculate_motivation(progress)
        }
```

**ã€ç¼–ç¨‹æ€æƒ³è¯¦è§£ã€‘**

1. **ç­–ç•¥æ¨¡å¼ï¼ˆStrategy Patternï¼‰**
   ```
   å®šä¹‰æ¥å£ï¼šshould_trigger(), get_trigger_data()
   å¤šä¸ªå®ç°ï¼šSprintStrategy, MemoryStrategy...

   ä¼˜ç‚¹ï¼š
   - æ˜“æ‰©å±•ï¼ˆæ–°å¢ç­–ç•¥ä¸å½±å“æ—§ä»£ç ï¼‰
   - æ˜“æµ‹è¯•ï¼ˆæ¯ä¸ªç­–ç•¥ç‹¬ç«‹æµ‹è¯•ï¼‰
   - æ˜“é…ç½®ï¼ˆè¿è¡Œæ—¶é€‰æ‹©ç­–ç•¥ï¼‰
   ```

2. **è´£ä»»é“¾æ¨¡å¼ï¼ˆChain of Responsibilityï¼‰**
   ```
   ç­–ç•¥1 â†’ ä¸æ»¡è¶³ï¼Ÿâ†’ ç­–ç•¥2 â†’ ä¸æ»¡è¶³ï¼Ÿâ†’ ç­–ç•¥3...

   ä¼˜ç‚¹ï¼š
   - ä¼˜å…ˆçº§æ¸…æ™°
   - çŸ­è·¯ä¼˜åŒ–
   - çµæ´»è°ƒæ•´
   ```

3. **AI ç”Ÿæˆå†…å®¹**
   ```
   ä¼ ç»Ÿï¼šå›ºå®šæ¨¡æ¿
   AIï¼šåŠ¨æ€ç”Ÿæˆ

   ä¼˜ç‚¹ï¼š
   - ä¸ªæ€§åŒ–
   - è‡ªç„¶è¯­è¨€
   - ä¸Šä¸‹æ–‡æ„ŸçŸ¥
   ```

**ã€è¯„å§”è€ƒå¯Ÿç‚¹ã€‘**

Q: ä¸ºä»€ä¹ˆç­–ç•¥æœ‰ä¼˜å…ˆçº§ï¼Ÿ
- A: ä¸åŒç­–ç•¥é‡è¦æ€§ä¸åŒï¼Œå†²åˆºè®¡åˆ’æ¯”æ™®é€šå¤ä¹ æ›´é‡è¦

Q: å¦‚ä½•é¿å…æ¨é€éªšæ‰°ï¼Ÿ
- A: 1. é¢‘ç‡é™åˆ¶ 2. å†·å´æœŸ 3. ç”¨æˆ·åå¥½ 4. æ—¶åŒºæ„ŸçŸ¥

Q: AI ç”Ÿæˆå†…å®¹çš„æˆæœ¬ï¼Ÿ
- A: 1. åªåœ¨è§¦å‘æ—¶ç”Ÿæˆ 2. ç¼“å­˜ç»“æœ 3. å¼‚æ­¥å¤„ç†

---

## 7. ç”Ÿäº§çº§ç‰¹æ€§ä¸å¢å¼º

### 7.1 ç†”æ–­å™¨ï¼ˆCircuit Breakerï¼‰

```python
# backend/app/orchestration/circuit_breaker.py

class CircuitBreaker:
    """
    ç†”æ–­å™¨æ¨¡å¼å®ç°

    ã€çŠ¶æ€æœºã€‘
    CLOSED (æ­£å¸¸) â†’ å¤±è´¥æ¬¡æ•° â‰¥ é˜ˆå€¼ â†’ OPEN (ç†”æ–­)
    OPEN (ç†”æ–­) â†’ è¶…æ—¶ â†’ HALF_OPEN (åŠå¼€)
    HALF_OPEN (åŠå¼€) â†’ æˆåŠŸ â†’ CLOSED (æ¢å¤)
    HALF_OPEN (åŠå¼€) â†’ å¤±è´¥ â†’ OPEN (å†æ¬¡ç†”æ–­)

    ã€ç¼–ç¨‹æ€æƒ³ã€‘
    - çŠ¶æ€æ¨¡å¼ï¼šä¸‰ç§çŠ¶æ€ï¼Œä¸åŒè¡Œä¸º
    - æœ‰é™çŠ¶æ€æœºï¼šçŠ¶æ€è½¬æ¢æœ‰æ˜ç¡®è§„åˆ™
    - é˜²å¾¡æ€§ç¼–ç¨‹ï¼šé˜²æ­¢çº§è”æ•…éšœ
    """

    def __init__(self, failure_threshold=5, recovery_timeout=60):
        self.failure_threshold = failure_threshold  # å¤±è´¥é˜ˆå€¼
        self.recovery_timeout = recovery_timeout    # æ¢å¤è¶…æ—¶ï¼ˆç§’ï¼‰

        self.failure_count = 0          # å¤±è´¥è®¡æ•°
        self.last_failure_time = 0      # æœ€åå¤±è´¥æ—¶é—´
        self.state = "CLOSED"           # å½“å‰çŠ¶æ€

        # Redis ç”¨äºåˆ†å¸ƒå¼çŠ¶æ€
        self.redis_key = "circuit_breaker:state"

    async def can_execute(self) -> bool:
        """
        æ£€æŸ¥æ˜¯å¦å¯ä»¥æ‰§è¡Œ

        ã€çŠ¶æ€è½¬æ¢é€»è¾‘ã€‘
        - CLOSED: ç›´æ¥è¿”å› True
        - OPEN: æ£€æŸ¥è¶…æ—¶ï¼Œè¶…æ—¶åˆ™è½¬ HALF_OPEN
        - HALF_OPEN: è¿”å› Trueï¼ˆå…è®¸æµ‹è¯•è¯·æ±‚ï¼‰
        """
        # ä» Redis è·å–å½“å‰çŠ¶æ€ï¼ˆåˆ†å¸ƒå¼ï¼‰
        state = await self._get_state_from_redis()

        if state == "OPEN":
            # æ£€æŸ¥æ˜¯å¦è¶…æ—¶
            if time.time() - self.last_failure_time > self.recovery_timeout:
                # è¿›å…¥åŠå¼€çŠ¶æ€ï¼Œå…è®¸ä¸€ä¸ªè¯·æ±‚æµ‹è¯•
                await self._set_state("HALF_OPEN")
                return True
            return False  # ä»åœ¨ç†”æ–­ä¸­

        if state == "HALF_OPEN":
            # å…è®¸ä¸€ä¸ªè¯·æ±‚é€šè¿‡
            return True

        return True  # CLOSED

    async def record_success(self):
        """è®°å½•æˆåŠŸ"""
        if self.state == "HALF_OPEN":
            # æ¢å¤æ­£å¸¸
            await self._set_state("CLOSED")
            self.failure_count = 0

    async def record_failure(self):
        """è®°å½•å¤±è´¥"""
        self.failure_count += 1
        self.last_failure_time = time.time()

        if self.failure_count >= self.failure_threshold:
            await self._set_state("OPEN")
            # å‘é€å‘Šè­¦
            await self._send_alert("Circuit breaker opened")

    async def _get_state_from_redis(self) -> str:
        """ä» Redis è·å–çŠ¶æ€"""
        state = await self.redis.get(self.redis_key)
        return state.decode("utf-8") if state else "CLOSED"

    async def _set_state(self, state: str):
        """è®¾ç½®çŠ¶æ€åˆ° Redis"""
        self.state = state
        await self.redis.setex(
            self.redis_key,
            3600,  # 1å°æ—¶TTL
            state
        )
```

**ã€çŠ¶æ€è½¬æ¢å›¾ã€‘**
```
CLOSED (æ­£å¸¸)
    â†“ å¤±è´¥æ¬¡æ•° â‰¥ 5
OPEN (ç†”æ–­) â†â”€â”€â”€â”€â”€â”€â”
    â†“ è¶…æ—¶60ç§’     â”‚
HALF_OPEN (åŠå¼€)   â”‚
    â†“ æˆåŠŸ         â”‚
CLOSED (æ¢å¤) â”€â”€â”€â”€â”€â”˜
    â†“ å¤±è´¥
    â””â”€â”€â”€â”€â”€â”€â†’ OPEN
```

**ã€è¯„å§”è€ƒå¯Ÿç‚¹ã€‘**

Q: ç†”æ–­å™¨å’Œé™æµçš„åŒºåˆ«ï¼Ÿ
- A: é™æµæ˜¯é¢„é˜²ï¼ˆæ§åˆ¶é€Ÿç‡ï¼‰ï¼Œç†”æ–­æ˜¯æ²»ç–—ï¼ˆç³»ç»Ÿå·²è¿‡è½½ï¼‰

Q: ä¸ºä»€ä¹ˆéœ€è¦åŠå¼€çŠ¶æ€ï¼Ÿ
- A: æµ‹è¯•ç³»ç»Ÿæ˜¯å¦æ¢å¤ï¼Œé¿å…ç«‹å³å†æ¬¡ç†”æ–­

Q: åˆ†å¸ƒå¼ç†”æ–­å™¨å¦‚ä½•å®ç°ï¼Ÿ
- A: Redis å­˜å‚¨çŠ¶æ€ï¼Œæ‰€æœ‰å®ä¾‹å…±äº«

---

### 7.2 æ¶ˆæ¯å»é‡

```python
# backend/app/orchestration/message_tracker.py

class MessageTracker:
    """
    æ¶ˆæ¯å»é‡è¿½è¸ªå™¨

    ã€é—®é¢˜ã€‘
    ç½‘ç»œä¸ç¨³å®šå¯¼è‡´å®¢æˆ·ç«¯é‡å‘ï¼Œå¯èƒ½é‡å¤å¤„ç†

    ã€è§£å†³æ–¹æ¡ˆã€‘
    è®°å½•å·²å¤„ç†çš„è¯·æ±‚IDï¼Œé‡å¤åˆ™ç›´æ¥è¿”å›

    ã€ç¼–ç¨‹æ€æƒ³ã€‘
    - å¹‚ç­‰æ€§ï¼šé‡å¤è¯·æ±‚ç»“æœä¸€è‡´
    - ç¼“å­˜ï¼šRedis å­˜å‚¨
    - TTLï¼šè‡ªåŠ¨è¿‡æœŸ
    """

    def __init__(self, redis_client):
        self.redis = redis_client
        self.ttl = 3600  # 1å°æ—¶

    async def is_processed(self, request_id: str) -> bool:
        """æ£€æŸ¥è¯·æ±‚æ˜¯å¦å·²å¤„ç†"""
        key = f"processed:{request_id}"
        result = await self.redis.get(key)
        return result is not None

    async def mark_processed(self, request_id: str):
        """æ ‡è®°ä¸ºå·²å¤„ç†"""
        key = f"processed:{request_id}"
        await self.redis.setex(key, self.ttl, "1")
```

**ã€å¹‚ç­‰æ€§ä¿è¯ã€‘**
```
å®¢æˆ·ç«¯å‘é€ï¼šreq_123
æœåŠ¡ç«¯å¤„ç†å‰ï¼šæ£€æŸ¥æ˜¯å¦å·²å¤„ç†
    â†“
æœªå¤„ç† â†’ æ‰§è¡Œä¸šåŠ¡ â†’ æ ‡è®°å·²å¤„ç† â†’ è¿”å›ç»“æœ
å·²å¤„ç† â†’ ç›´æ¥è¿”å›ç¼“å­˜ç»“æœ
```

---

### 7.3 åˆ†å¸ƒå¼é”

```python
# backend/app/orchestration/distributed_lock.py

class DistributedLock:
    """
    åŸºäº Redis çš„åˆ†å¸ƒå¼é”

    ã€é—®é¢˜ã€‘
    å¤šè¿›ç¨‹/å¤šæœåŠ¡å™¨ç¯å¢ƒä¸‹ï¼Œå¦‚ä½•ä¿è¯äº’æ–¥è®¿é—®ï¼Ÿ

    ã€è§£å†³æ–¹æ¡ˆã€‘
    Redis SETNX åŸå­æ“ä½œ

    ã€ç¼–ç¨‹æ€æƒ³ã€‘
    - äº’æ–¥é”ï¼šåŒä¸€æ—¶é—´åªæœ‰ä¸€ä¸ªè¿›ç¨‹æŒæœ‰
    - è¶…æ—¶æœºåˆ¶ï¼šé˜²æ­¢æ­»é”
    - åŸå­æ“ä½œï¼šä¿è¯ä¸€è‡´æ€§
    """

    def __init__(self, redis_client):
        self.redis = redis_client

    async def acquire(self, lock_key: str, timeout: int = 10) -> bool:
        """
        è·å–é”

        ã€Lua è„šæœ¬ä¿è¯åŸå­æ€§ã€‘
        1. æ£€æŸ¥é”æ˜¯å¦å­˜åœ¨
        2. ä¸å­˜åœ¨åˆ™è®¾ç½®
        3. è®¾ç½®è¿‡æœŸæ—¶é—´
        """
        key = f"lock:{lock_key}"
        value = str(time.time())

        # SET NX EXï¼šåŸå­æ“ä½œ
        acquired = await self.redis.set(
            key,
            value,
            nx=True,  # åªåœ¨ä¸å­˜åœ¨æ—¶è®¾ç½®
            ex=timeout
        )

        return acquired is True

    async def release(self, lock_key: str):
        """é‡Šæ”¾é”"""
        key = f"lock:{lock_key}"
        await self.redis.delete(key)
```

**ã€é”çš„ç”Ÿå‘½å‘¨æœŸã€‘**
```
è·å–é” â†’ æ‰§è¡Œä¸šåŠ¡ â†’ é‡Šæ”¾é”
    â†“
è¶…æ—¶è‡ªåŠ¨é‡Šæ”¾ï¼ˆé˜²æ­¢æ­»é”ï¼‰
```

---

## 8. å®Œæ•´è¯·æ±‚æµç¨‹è¿½è¸ª

### 8.1 ç«¯åˆ°ç«¯æµç¨‹è¯¦è§£

```
ç”¨æˆ·è¾“å…¥: "ä»€ä¹ˆæ˜¯æœºå™¨å­¦ä¹ ï¼Ÿ"
```

#### é˜¶æ®µ 1: Flutter ç§»åŠ¨ç«¯

```dart
// 1. ç”¨æˆ·åœ¨ ChatScreen è¾“å…¥æ¶ˆæ¯
ChatScreen.onSubmitted("ä»€ä¹ˆæ˜¯æœºå™¨å­¦ä¹ ï¼Ÿ")

// 2. Riverpod Notifier å¤„ç†
ChatNotifier.sendMessage("ä»€ä¹ˆæ˜¯æœºå™¨å­¦ä¹ ï¼Ÿ")
  â†’ æ›´æ–°çŠ¶æ€: state = state.copyWith(isLoading: true)
  â†’ UI æ˜¾ç¤ºåŠ è½½åŠ¨ç”»

// 3. WebSocket æœåŠ¡å‘é€
WebSocketChatServiceV2.sendMessage(
  message: "ä»€ä¹ˆæ˜¯æœºå™¨å­¦ä¹ ï¼Ÿ",
  userId: "user_123",
  sessionId: "sess_456"
)
  â†’ æ„å»º payload: {"message": "...", "session_id": "...", "user_id": "..."}
  â†’ WebSocketChannel å‘é€ JSON
  â†’ ç›‘å¬å“åº”æµ
```

**ã€Flutter ç«¯ç¼–ç¨‹æ€æƒ³ã€‘**
- **çŠ¶æ€é©±åŠ¨**: UI æ ¹æ® state è‡ªåŠ¨é‡å»º
- **å¼‚æ­¥æµ**: async for å¤„ç†æµå¼å“åº”
- **äº‹ä»¶é©±åŠ¨**: WebSocket æ¶ˆæ¯è§¦å‘ UI æ›´æ–°

---

#### é˜¶æ®µ 2: Go Gateway ç½‘å…³å±‚

```go
// 4. Go æ¥æ”¶ WebSocket è¿æ¥
func (h *ChatHandler) HandleWebSocket(conn *websocket.Conn, userID string) {
    // è®¤è¯ï¼ˆJWT Middlewareï¼‰
    if !h.authMiddleware(conn) {
        conn.Close(4001, "Auth failed")
        return
    }

    // åˆ›å»ºä¼šè¯
    sessionID := h.sessionMgr.CreateSession(userID)
    h.sessionMgr.Register(sessionID, conn)
    defer h.sessionMgr.Unregister(sessionID)

    // å¯åŠ¨å¿ƒè·³
    go h.heartbeat(conn, sessionID)

    // æ¶ˆæ¯å¾ªç¯
    for {
        var msg ChatMessage
        if err := conn.ReadJSON(&msg); err != nil {
            break  // è¿æ¥æ–­å¼€
        }

        // é…é¢æ£€æŸ¥
        if !h.quotaService.CheckQuota(userID) {
            conn.WriteJSON(QuotaExceededResponse)
            break
        }

        // è½¬å‘åˆ° gRPC
        response, err := h.grpcClient.StreamChat(ctx, &pb.ChatRequest{
            UserId:    userID,
            SessionId: sessionID,
            Message:   msg.Message,
        })

        // æµå¼è¿”å›
        for _, chunk := range response {
            conn.WriteJSON(chunk)
        }
    }
}
```

**ã€Go ç«¯ç¼–ç¨‹æ€æƒ³ã€‘**
- **å¹¶å‘æ¨¡å‹**: goroutine + channel
- **èµ„æºç®¡ç†**: defer ç¡®ä¿æ¸…ç†
- **åè®®å¤„ç†**: WebSocket åè®®å°è£…
- **ç½‘å…³æ¨¡å¼**: åªåšè·¯ç”±ï¼Œä¸å¤„ç†ä¸šåŠ¡

---

#### é˜¶æ®µ 3: Python Agent Engine

```python
# 5. gRPC æœåŠ¡æ¥æ”¶
class AgentServiceImpl(pb2_grpc.AgentServiceServicer):
    async def StreamChat(self, request, context):
        orchestrator = ProductionChatOrchestrator()

        # 11æ­¥å¤„ç†é“¾
        async for event in orchestrator.process_stream(request):
            yield pb2.StreamResponse(
                type=event.type,
                content=event.content
            )

# 6. ç”Ÿäº§çº§ç¼–æ’å™¨
async def process_stream(self, request):
    # ç¬¬1æ­¥ï¼šæ¶ˆæ¯å»é‡
    if await self.message_tracker.is_processed(request_id):
        yield ErrorEvent("DUPLICATE_REQUEST")
        return

    # ç¬¬2æ­¥ï¼šç†”æ–­æ£€æŸ¥
    if not await self.circuit_breaker.can_execute():
        yield ErrorEvent("CIRCUIT_BREAKER_OPEN")
        return

    # ç¬¬3æ­¥ï¼šå¹¶å‘æ§åˆ¶
    if not await self._track_session(session_id, add=True):
        yield ErrorEvent("RATE_LIMIT")
        return

    try:
        # ç¬¬4æ­¥ï¼šè¯·æ±‚éªŒè¯
        validation = await self.validator.validate_chat_request(request)
        if not validation.is_valid:
            yield ErrorEvent("VALIDATION_FAILED")
            return

        # ç¬¬5æ­¥ï¼šå¹‚ç­‰æ£€æŸ¥
        cached = await self._check_idempotency(session_id, request_id)
        if cached:
            yield cached
            return

        # ç¬¬6æ­¥ï¼šåˆ†å¸ƒå¼é”
        if not await self._acquire_session_lock(session_id, request_id):
            yield ErrorEvent("LOCK_FAILED")
            return

        # ç¬¬7æ­¥ï¼šæ„å»ºä¸Šä¸‹æ–‡
        user_context = await self._build_user_context(user_id)
        conversation_context = await self.context_pruner.get_pruned_history(
            session_id, user_id
        )

        # ç¬¬8æ­¥ï¼šçŸ¥è¯†æ£€ç´¢
        knowledge_context = await self._retrieve_knowledge(
            user_id, request.message, conversation_context
        )

        # ç¬¬9æ­¥ï¼šLLM è°ƒç”¨
        async for chunk in self._call_llm_with_tools(
            request, user_context, conversation_context, knowledge_context
        ):
            yield chunk

        # ç¬¬10æ­¥ï¼šç¼“å­˜ä¸æŒ‡æ ‡
        await self._cache_response(session_id, request_id, request.message)
        await self._record_metrics(request, user_context)

    finally:
        # ç¬¬11æ­¥ï¼šæ¸…ç†
        await self._release_session_lock(session_id, request_id)
        await self._track_session(session_id, add=False)
```

**ã€Python ç«¯ç¼–ç¨‹æ€æƒ³ã€‘**
- **è´£ä»»é“¾**: 11æ­¥ä¾æ¬¡æ‰§è¡Œ
- **å¼‚æ­¥æµ**: async for + yield
- **é”™è¯¯å¤„ç†**: try-finally ä¿è¯æ¸…ç†
- **çŠ¶æ€ç®¡ç†**: åˆ†å¸ƒå¼é” + ä¼šè¯è¿½è¸ª

---

#### é˜¶æ®µ 4: LLM æœåŠ¡æ‰§è¡Œ

```python
# 7. LLM æœåŠ¡
async def chat_stream_with_tools(self, messages, tools, user_id):
    provider = self.providers["qwen"]

    # ç¬¬ä¸€æ¬¡è°ƒç”¨
    response = await provider.chat_complete(
        messages=messages,
        tools=tools,
        stream=True
    )

    tool_calls = []
    async for chunk in response:
        if chunk.type == "text":
            yield chunk  # ç›´æ¥è¿”å›æ–‡æœ¬

        elif chunk.type == "tool_call":
            tool_calls.append(chunk.tool_call)

            if chunk.tool_call.finish_reason == "stop":
                # æ‰§è¡Œå·¥å…·
                tool_results = await self._execute_tools(tool_calls)

                # åŠ å…¥ä¸Šä¸‹æ–‡
                messages.extend([
                    {"role": "assistant", "tool_calls": tool_calls},
                    {"role": "tool", "content": json.dumps(tool_results)}
                ])

                # ç¬¬äºŒæ¬¡è°ƒç”¨
                final_response = await provider.chat_complete(
                    messages=messages,
                    stream=True
                )

                async for final_chunk in final_response:
                    yield final_chunk

                break
```

**ã€å·¥å…·è°ƒç”¨æµç¨‹ã€‘**
```
LLM: "éœ€è¦è°ƒç”¨ get_knowledge_node å·¥å…·"
    â†“
ç³»ç»Ÿ: æ‰§è¡Œå·¥å…· â†’ æŸ¥è¯¢æ•°æ®åº“
    â†“
ç³»ç»Ÿ: è¿”å›ç»“æœç»™ LLM
    â†“
LLM: "æœºå™¨å­¦ä¹ æ˜¯..."
```

---

#### é˜¶æ®µ 5: æ•°æ®åº“æ“ä½œ

```python
# 8. æ•°æ®åº“æ“ä½œç¤ºä¾‹

# çŸ¥è¯†æ£€ç´¢
async def _retrieve_knowledge(self, user_id, query, context):
    # ç”ŸæˆæŸ¥è¯¢å‘é‡
    query_embedding = await self.llm.get_embedding(query)

    # å¹¶è¡Œæœç´¢
    vector_task = self._vector_search(query_embedding, 20)
    keyword_task = self._keyword_search(query, 20)

    vector_results, keyword_results = await asyncio.gather(
        vector_task, keyword_task
    )

    # RRF èåˆ
    fused = self._reciprocal_rank_fusion(vector_results, keyword_results)

    # é‡æ’åº
    reranked = await self._rerank(query, fused, 10)

    # è·å–èŠ‚ç‚¹
    nodes = await self._get_nodes_by_ids([r.node_id for r in reranked])

    # è¿‡æ»¤ç”¨æˆ·çŠ¶æ€
    filtered = await self._filter_by_user_status(user_id, nodes)

    return filtered

# æ›´æ–°æŒæ¡åº¦
async def spark_node(self, user_id, node_id, study_minutes):
    # äº‹åŠ¡æ“ä½œ
    async with self.db.begin():
        # æŸ¥è¯¢çŠ¶æ€
        status = await self.db.execute(
            select(UserNodeStatus).where(
                UserNodeStatus.user_id == user_id,
                UserNodeStatus.node_id == node_id
            )
        )

        # è®¡ç®—å¢é‡
        delta = self._calculate_mastery_delta(...)

        # æ›´æ–°çŠ¶æ€
        status.mastery_score += delta
        status.study_count += 1
        status.last_study_at = datetime.utcnow()

        # è®°å½•å†å²
        record = StudyRecord(...)
        self.db.add(record)

        # æäº¤äº‹åŠ¡
        await self.db.commit()
```

**ã€æ•°æ®åº“ç¼–ç¨‹æ€æƒ³ã€‘**
- **äº‹åŠ¡**: ä¿è¯åŸå­æ€§
- **å¼‚æ­¥**: ä¸é˜»å¡
- **è¿æ¥æ± **: å¤ç”¨è¿æ¥
- **ç´¢å¼•ä¼˜åŒ–**: æå‡æŸ¥è¯¢é€Ÿåº¦

---

#### é˜¶æ®µ 6: Redis ç¼“å­˜/é˜Ÿåˆ—

```python
# 9. Redis æ“ä½œ

# ç¼“å­˜å¯¹è¯å†å²
await redis.rpush("chat_history:sess_456", json.dumps({
    "role": "user",
    "content": "ä»€ä¹ˆæ˜¯æœºå™¨å­¦ä¹ ï¼Ÿ"
}))
await redis.expire("chat_history:sess_456", 3600)

# å¼‚æ­¥æ€»ç»“é˜Ÿåˆ—
await redis.rpush("queue:summarization", json.dumps({
    "session_id": "sess_456",
    "history": [...],
    "user_id": "user_123"
}))

# ä¼šè¯çŠ¶æ€
await redis.setex("session:sess_456:active", 60, "1")

# å»é‡è®°å½•
await redis.setex("processed:req_789", 3600, "1")
```

**ã€Redis ç¼–ç¨‹æ€æƒ³ã€‘**
- **é«˜é€Ÿç¼“å­˜**: æ¯«ç§’çº§å“åº”
- **æ•°æ®ç»“æ„**: List, String, Hash ç­‰
- **TTL**: è‡ªåŠ¨è¿‡æœŸ
- **åŸå­æ“ä½œ**: Lua è„šæœ¬

---

#### é˜¶æ®µ 7: è¿”å› Flutter

```dart
// 10. Flutter æ¥æ”¶æµå¼å“åº”

WebSocketChatServiceV2._handleMessage(data)
  â†’ è§£æä¸º TextEvent("æœºå™¨å­¦ä¹ æ˜¯...")
  â†’ StreamController.add(event)

ChatNotifier._handleStreamEvent(event)
  â†’ event.when(
      text: (content) {
        // é€æ­¥æ›´æ–°å“åº”
        state = state.copyWith(
          response: state.response + content,
          isTyping: true
        );
      },
      done: () {
        // å®Œæˆï¼Œæ·»åŠ åˆ°æ¶ˆæ¯åˆ—è¡¨
        state = state.copyWith(
          messages: [
            ...state.messages,
            ChatMessage(
              role: 'assistant',
              content: state.response
            )
          ],
          isLoading: false,
          isTyping: false
        );
      }
    )

// 11. UI è‡ªåŠ¨é‡å»º
ChatScreen.builder()
  â†’ æ˜¾ç¤ºæ¶ˆæ¯æ°”æ³¡
  â†’ æ‰“å­—åŠ¨ç”»æ•ˆæœ
  â†’ å®ŒæˆçŠ¶æ€
```

**ã€Flutter ç«¯ç¼–ç¨‹æ€æƒ³ã€‘**
- **å“åº”å¼**: çŠ¶æ€å˜åŒ–è‡ªåŠ¨æ›´æ–° UI
- **æµå¼å¤„ç†**: é€å—æ˜¾ç¤º
- **çŠ¶æ€ä¸å¯å˜**: ä¿è¯ä¸€è‡´æ€§

---

### 8.2 å®Œæ•´æ—¶åºå›¾

```
æ—¶é—´è½´: 0ms â”€â”€â”€> 100ms â”€â”€â”€> 200ms â”€â”€â”€> 300ms â”€â”€â”€> 400ms â”€â”€â”€> 500ms

Flutter: [å‘é€] â”€â”€> [ç­‰å¾…] â”€â”€> [æ¥æ”¶"æœºå™¨"] â”€â”€> [æ¥æ”¶"å­¦ä¹ "] â”€â”€> [å®Œæˆ]
           â”‚          â”‚            â”‚              â”‚            â”‚
Go:       â”‚          â””â”€> [æ¥æ”¶] â”€â”€> [éªŒè¯] â”€â”€> [gRPC] â”€â”€> [æµå¼è¿”å›]
           â”‚                     â”‚            â”‚            â”‚
Python:   â”‚                     â””â”€> [11æ­¥] â”€â”€> [LLM] â”€â”€> [å·¥å…·]
           â”‚                              â”‚            â”‚
DB/Redis: â”‚                              â”œâ”€> [æŸ¥è¯¢] â”€â”€> [æ›´æ–°]
           â”‚                              â”‚
LLM:      â”‚                              â””â”€> [ç”Ÿæˆ] â”€â”€> [æµå¼]
```

**ã€å…³é”®æ—¶é—´ç‚¹ã€‘**
- 0ms: Flutter å‘é€
- 50ms: Go æ¥æ”¶å¹¶éªŒè¯
- 100ms: Python å¼€å§‹å¤„ç†
- 150ms: æ•°æ®åº“æŸ¥è¯¢å®Œæˆ
- 200ms: LLM å¼€å§‹è¿”å›
- 300ms: Flutter æ¥æ”¶ç¬¬ä¸€ä¸ªå­—
- 500ms: å®Œæ•´å›ç­”æ˜¾ç¤º

---

## 9. æ€§èƒ½ä¼˜åŒ–ä¸æœ€ä½³å®è·µ

### 9.1 æ•°æ®åº“ä¼˜åŒ–

```sql
-- 1. å‘é‡ç´¢å¼•ä¼˜åŒ–
-- HNSWï¼šé«˜æ€§èƒ½ï¼Œé€‚åˆç”Ÿäº§
CREATE INDEX idx_embedding_hnsw
ON knowledge_nodes USING hnsw (embedding vector_cosine_ops)
WITH (m = 16, ef_construction = 64, ef_search = 40);

-- 2. éƒ¨åˆ†ç´¢å¼•ï¼šåªç´¢å¼•æ´»è·ƒæ•°æ®
CREATE INDEX idx_active_nodes
ON user_node_status(user_id, mastery_score)
WHERE mastery_score < 100;

-- 3. è¦†ç›–ç´¢å¼•ï¼šé¿å…å›è¡¨
CREATE INDEX idx_study_covering
ON study_records(user_id, completed_at DESC)
INCLUDE (node_id, mastery_delta);

-- 4. BRIN ç´¢å¼•ï¼šæ—¶é—´åºåˆ—
CREATE INDEX idx_time_brin
ON study_records USING BRIN (completed_at);
```

**ã€ç´¢å¼•é€‰æ‹©åŸåˆ™ã€‘**
- **ç­‰å€¼æŸ¥è¯¢**: B-Tree
- **èŒƒå›´æŸ¥è¯¢**: B-Tree
- **å…¨æ–‡æœç´¢**: GIN
- **å‘é‡æœç´¢**: HNSW/IVFFlat
- **æ—¶é—´åºåˆ—**: BRIN

---

### 9.2 å¹¶å‘æ§åˆ¶

```python
# 1. å¼‚æ­¥å¹¶å‘
async def batch_process(self, items):
    # é™åˆ¶å¹¶å‘æ•°
    semaphore = asyncio.Semaphore(10)

    async def process_one(item):
        async with semaphore:
            return await self.process(item)

    tasks = [process_one(item) for item in items]
    return await asyncio.gather(*tasks)

# 2. è¿æ¥æ± 
engine = create_async_engine(
    DATABASE_URL,
    pool_size=20,        # è¿æ¥æ± å¤§å°
    max_overflow=50,     # æœ€å¤§æº¢å‡º
    pool_timeout=30,     # è·å–è¿æ¥è¶…æ—¶
    pool_recycle=3600    # è¿æ¥å›æ”¶
)

# 3. Redis è¿æ¥æ± 
redis_pool = redis.ConnectionPool(
    host='localhost',
    port=6379,
    max_connections=50,
    socket_timeout=5
)
```

---

### 9.3 ç¼“å­˜ç­–ç•¥

```python
# å¤šçº§ç¼“å­˜
class MultiLevelCache:
    def __init__(self):
        self.memory = {}  # L1: è¿›ç¨‹å†…
        self.redis = redis.from_url("redis://localhost:6379")  # L2

    async def get(self, key, ttl=300):
        # L1 æŸ¥è¯¢
        if key in self.memory:
            value, expiry = self.memory[key]
            if time.time() < expiry:
                return value

        # L2 æŸ¥è¯¢
        value = await self.redis.get(key)
        if value:
            self.memory[key] = (value, time.time() + ttl)
            return value

        return None

    async def set(self, key, value, ttl=300):
        await self.redis.setex(key, ttl, value)
        self.memory[key] = (value, time.time() + ttl)
```

---

### 9.4 é”™è¯¯å¤„ç†ä¸é™çº§

```python
async def get_knowledge_with_fallback(user_id, query):
    try:
        # ä¸»æµç¨‹
        results = await galaxy_service.hybrid_search(user_id, query)
        if results:
            return {"source": "graphrag", "data": results}
    except Exception as e:
        logger.warning(f"GraphRAG failed: {e}")

    try:
        # é™çº§1ï¼šå‘é‡æœç´¢
        results = await vector_service.search(query)
        if results:
            return {"source": "vector", "data": results}
    except Exception as e:
        logger.warning(f"Vector search failed: {e}")

    try:
        # é™çº§2ï¼šå…³é”®è¯æœç´¢
        results = await keyword_service.search(query)
        if results:
            return {"source": "keyword", "data": results}
    except Exception as e:
        logger.warning(f"Keyword search failed: {e}")

    # æœ€ç»ˆé™çº§
    return {"source": "fallback", "data": []}
```

---

## 10. é¢è¯•å¸¸è§é—®é¢˜è§£ç­”

### Q1: ä¸ºä»€ä¹ˆé€‰æ‹© Go + Python æ··åˆæ¶æ„ï¼Ÿ

**å›ç­”è¦ç‚¹**:
1. **Go çš„ä¼˜åŠ¿**:
   - é«˜æ€§èƒ½ WebSocket å¤„ç†ï¼ˆC10K é—®é¢˜ï¼‰
   - ç¼–è¯‘å‹è¯­è¨€ï¼Œå†…å­˜å®‰å…¨
   - å¹¶å‘æ¨¡å‹ï¼ˆgoroutineï¼‰é€‚åˆç½‘ç»œå±‚

2. **Python çš„ä¼˜åŠ¿**:
   - AI ç”Ÿæ€ä¸°å¯Œï¼ˆLangChain, OpenAI SDKï¼‰
   - LLM é›†æˆæˆç†Ÿ
   - å¿«é€Ÿè¿­ä»£

3. **gRPC çš„ä¼˜åŠ¿**:
   - é«˜æ•ˆäºŒè¿›åˆ¶åè®®
   - æµå¼æ”¯æŒ
   - å¼ºç±»å‹æ¥å£

**è¯„å§”è€ƒå¯Ÿ**: äº†è§£æŠ€æœ¯é€‰å‹èƒŒåçš„æƒè¡¡

---

### Q2: ContextPruner å¦‚ä½•è§£å†³é•¿å¯¹è¯é—®é¢˜ï¼Ÿ

**å›ç­”è¦ç‚¹**:
1. **é—®é¢˜**: Token é™åˆ¶ã€æ€§èƒ½ä¸‹é™ã€æˆæœ¬å¢åŠ 
2. **æ–¹æ¡ˆ**:
   - æ»‘åŠ¨çª—å£ï¼šä¿ç•™æœ€è¿‘ 10 æ¡
   - å¼‚æ­¥æ€»ç»“ï¼šè¶…è¿‡ 20 æ¡è§¦å‘
   - ç¼“å­˜æœºåˆ¶ï¼š1 å°æ—¶ TTL
3. **ç”Ÿäº§ç‰¹æ€§**: JSON åºåˆ—åŒ–ã€ç†”æ–­å™¨ã€ç›‘æ§

**è¯„å§”è€ƒå¯Ÿ**: å¯¹å®é™…é—®é¢˜çš„è§£å†³æ–¹æ¡ˆ

---

### Q3: çŸ¥è¯†æ˜Ÿå›¾çš„ RAG v2.0 å¦‚ä½•å·¥ä½œï¼Ÿ

**å›ç­”è¦ç‚¹**:
1. **æ··åˆæœç´¢**: å‘é‡ + å…³é”®è¯
2. **RRF èåˆ**: å€’æ•°æ’åèåˆ
3. **é‡æ’åº**: LLM äºŒæ¬¡æ’åº
4. **ç”¨æˆ·è¿‡æ»¤**: æ’é™¤å·²æŒæ¡

**è¯„å§”è€ƒå¯Ÿ**: RAG æŠ€æœ¯æ·±åº¦

---

### Q4: æ™ºèƒ½æ¨é€çš„ç­–ç•¥ä¼˜å…ˆçº§ï¼Ÿ

**å›ç­”è¦ç‚¹**:
1. **Sprint**: å†²åˆºè®¡åˆ’ï¼ˆæœ€é«˜ï¼‰
2. **Curiosity**: æ–°çŸ¥è¯†ç‚¹
3. **Memory**: å¤ä¹ æé†’
4. **Inactivity**: é˜²æµå¤±

**è¯„å§”è€ƒå¯Ÿ**: ä¸šåŠ¡ç†è§£èƒ½åŠ›

---

### Q5: ç†”æ–­å™¨å¦‚ä½•é˜²æ­¢çº§è”æ•…éšœï¼Ÿ

**å›ç­”è¦ç‚¹**:
1. **çŠ¶æ€æœº**: CLOSED â†’ OPEN â†’ HALF_OPEN
2. **é˜ˆå€¼**: 5 æ¬¡å¤±è´¥
3. **è¶…æ—¶**: 60 ç§’æ¢å¤
4. **åˆ†å¸ƒå¼**: Redis å­˜å‚¨çŠ¶æ€

**è¯„å§”è€ƒå¯Ÿ**: ç³»ç»Ÿç¨³å®šæ€§è®¾è®¡

---

### Q6: æ•°æ®åº“ç´¢å¼•ä¼˜åŒ–ç­–ç•¥ï¼Ÿ

**å›ç­”è¦ç‚¹**:
1. **HNSW**: å‘é‡æœç´¢
2. **éƒ¨åˆ†ç´¢å¼•**: åªç´¢å¼•æ´»è·ƒæ•°æ®
3. **è¦†ç›–ç´¢å¼•**: é¿å…å›è¡¨
4. **BRIN**: æ—¶é—´åºåˆ—

**è¯„å§”è€ƒå¯Ÿ**: æ•°æ®åº“æ€§èƒ½ä¼˜åŒ–

---

### Q7: WebSocket é‡è¿æœºåˆ¶ï¼Ÿ

**å›ç­”è¦ç‚¹**:
1. **æŒ‡æ•°é€€é¿**: 2, 4, 8, 16, 32 ç§’
2. **æ¶ˆæ¯é˜Ÿåˆ—**: æ–­è¿æ—¶æš‚å­˜
3. **å¿ƒè·³ä¿æ´»**: 30 ç§’ Ping
4. **çŠ¶æ€ç®¡ç†**: è¿æ¥çŠ¶æ€æœº

**è¯„å§”è€ƒå¯Ÿ**: ç½‘ç»œç¼–ç¨‹ç»éªŒ

---

### Q8: ç”Ÿäº§ç¯å¢ƒéƒ¨ç½²è¦ç‚¹ï¼Ÿ

**å›ç­”è¦ç‚¹**:
1. **åŸºç¡€è®¾æ–½**: Docker + Kubernetes
2. **ç›‘æ§**: Prometheus + Grafana
3. **é«˜å¯ç”¨**: ä¸»ä»æ•°æ®åº“ + Redis é›†ç¾¤
4. **å®‰å…¨**: JWT + é€Ÿç‡é™åˆ¶

**è¯„å§”è€ƒå¯Ÿ**: è¿ç»´å’Œéƒ¨ç½²èƒ½åŠ›

---

### Q9: å¦‚ä½•ä¿è¯æ•°æ®ä¸€è‡´æ€§ï¼Ÿ

**å›ç­”è¦ç‚¹**:
1. **æ•°æ®åº“äº‹åŠ¡**: ACID
2. **åˆ†å¸ƒå¼é”**: Redis SETNX
3. **å¹‚ç­‰æ€§**: è¯·æ±‚ ID å»é‡
4. **æœ€ç»ˆä¸€è‡´æ€§**: å¼‚æ­¥è¡¥å¿

**è¯„å§”è€ƒå¯Ÿ**: åˆ†å¸ƒå¼ç³»ç»Ÿè®¾è®¡

---

### Q10: æ€§èƒ½ä¼˜åŒ–çš„å…³é”®æŒ‡æ ‡ï¼Ÿ

**å›ç­”è¦ç‚¹**:
1. **å»¶è¿Ÿ**: P95 < 2s
2. **ååé‡**: QPS > 1000
3. **ç¼“å­˜å‘½ä¸­ç‡**: > 80%
4. **é”™è¯¯ç‡**: < 1%

**è¯„å§”è€ƒå¯Ÿ**: æ€§èƒ½æ„è¯†

---

## æ€»ç»“

### æ ¸å¿ƒç¼–ç¨‹æ€æƒ³

1. **åˆ†å±‚æ¶æ„**: èŒè´£åˆ†ç¦»ï¼Œå„å¸å…¶èŒ
2. **å¼‚æ­¥ç¼–ç¨‹**: éé˜»å¡ï¼Œé«˜å¹¶å‘
3. **çŠ¶æ€ç®¡ç†**: ä¸å¯å˜æ•°æ®ï¼Œå“åº”å¼
4. **é”™è¯¯å¤„ç†**: ä¼˜é›…é™çº§ï¼Œç†”æ–­ä¿æŠ¤
5. **ç¼“å­˜ç­–ç•¥**: å¤šçº§ç¼“å­˜ï¼Œæ€§èƒ½ä¼˜åŒ–
6. **ç›‘æ§åŸ‹ç‚¹**: å¯è§‚æµ‹æ€§ï¼Œå¿«é€Ÿå®šä½

### å­¦ä¹ è·¯å¾„å»ºè®®

1. **åŸºç¡€**: ç†è§£æ¯æ®µä»£ç çš„æ³¨é‡Š
2. **è¿›é˜¶**: æŒæ¡ç¼–ç¨‹æ€æƒ³
3. **æ·±å…¥**: ç†è§£å‰åç«¯äº¤äº’
4. **ç²¾é€š**: èƒ½å›ç­”è¯„å§”é—®é¢˜

### è¯„å§”å…³æ³¨ç‚¹

- **ä»£ç è´¨é‡**: æ³¨é‡Šã€å‘½åã€ç»“æ„
- **è®¾è®¡æ¨¡å¼**: è´£ä»»é“¾ã€ç­–ç•¥ã€å·¥å‚
- **ç³»ç»Ÿæ€ç»´**: åˆ†å±‚ã€è§£è€¦ã€æ‰©å±•
- **ç”Ÿäº§ç»éªŒ**: é”™è¯¯å¤„ç†ã€ç›‘æ§ã€é™çº§
- **æ€§èƒ½æ„è¯†**: ç´¢å¼•ã€ç¼“å­˜ã€å¹¶å‘

---

**æ–‡æ¡£ç»“æŸ**
*è¿™ä»½æ–‡æ¡£ä»ä»£ç æ³¨é‡Šåˆ°ç¼–ç¨‹æ€æƒ³ï¼Œä»å‰åç«¯äº¤äº’åˆ°è¯„å§”è€ƒå¯Ÿç‚¹ï¼Œæä¾›äº†å®Œæ•´çš„å­¦ä¹ è·¯å¾„ã€‚å»ºè®®é€è¡Œé˜…è¯»ä»£ç ï¼Œç†è§£æ¯éƒ¨åˆ†çš„è®¾è®¡æ„å›¾ã€‚*