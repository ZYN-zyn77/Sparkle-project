# 架构决策记录 (ADR)

## ADR-001: 采用混合微服务架构 (Go + Python)

### 背景
项目初期使用 Python 单体 (FastAPI) 处理所有请求。随着实时聊天功能的引入，WebSocket 连接数预期增加，Python 的并发处理能力成为瓶颈。同时，AI 逻辑依然高度依赖 Python 生态。

### 决策
采用 **Go Gateway + Python Engine** 的混合架构。
- **Go Gateway**: 处理 WebSocket 连接、鉴权、路由。
- **Python Engine**: 专注 AI 推理、向量计算、复杂业务。
- **通信**: 内部使用 gRPC (Protobuf) 进行高效通信。

### 结果
- ✅ **正向**: Go 轻松处理数万并发连接；Python 专注于 CPU 密集型任务。
- ⚠️ **负向**: 增加了系统复杂度，需要维护两套技术栈和通信协议。

---

## ADR-002: Flutter 状态管理采用 Riverpod

### 背景
Flutter 生态中有 Provider, Bloc, GetX 等多种选择。我们需要一个类型安全、无 context 依赖且易于测试的方案。

### 决策
选择 **Riverpod 2.0 (Generator)**。
- 使用 `Notifier` 和 `AsyncNotifier` 代替旧的 `StateNotifier`。
- 使用 `freezed` 生成不可变状态类。

### 结果
- ✅ **正向**: 编译时安全，无 `BuildContext` 依赖，极大地简化了全局状态访问。
- ⚠️ **负向**: 学习曲线较陡峭，代码生成增加了构建时间。

---

## ADR-003: 数据库使用 PostgreSQL + pgvector

### 背景
项目需要存储关系型数据（用户、任务）和向量数据（知识点 Embedding）。

### 选项
1.  PostgreSQL + 独立向量库 (Milvus/Qdrant)。
2.  PostgreSQL + pgvector 插件。

### 决策
选择 **PostgreSQL + pgvector**。

### 理由
- **单一即真理**: 保持技术栈精简，避免维护额外的数据库。
- **关联查询**: 可以直接在 SQL 中做向量搜索 + 关系过滤 (`WHERE user_id = ...`)，无需应用层 Join。
- **事务支持**: 向量更新和元数据更新在同一事务中，保证一致性。

---

## ADR-004: 异步任务处理采用 Celery

### 背景
AI 推理和外部 API 调用耗时较长，不能阻塞 HTTP/gRPC 请求线程。

### 决策
使用 **Celery + Redis**。

### 结果
- ✅ **正向**: 成熟稳定，支持定时任务 (Beat)，易于横向扩展 Worker。
- ⚠️ **负向**: 引入了 Redis 依赖（虽然 Redis 本来就要用作缓存）。

---

## ADR-005: 设计系统 (DS) V2 的实现

### 背景
旧版设计系统直接使用硬编码颜色和原生 Widget，导致主题切换困难，视觉风格不统一。

### 决策
构建 **基于语义化 Token 的 Design System V2**。
- 引入 `SparkleMaterial` 概念，封装光效和材质。
- 实现 `PerformanceService`，根据设备性能动态降级材质渲染。

### 结果
- ✅ **正向**: 实现了 Luminous Cognition 高级视觉风格，同时保证了低端机流畅度。
- ⚠️ **负向**: 开发 UI 组件时需要查阅 Token 文档，不能随意写死数值。
