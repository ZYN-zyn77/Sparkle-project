# 聊天系统实现细节 (Chat System Deep Dive)

## 1. 概述 (Overview)

Sparkle 的聊天系统是用户与 AI 智能体交互的核心界面。从 V2 版本开始，我们全面重构了底层的通信机制，从短轮询/REST API 转向了 **WebSocket + gRPC 双向流** 架构，以支持实时打字机效果、AI 思考状态可视化和复杂的工具调用交互。

---

## 2. 架构设计 (Architecture)

```mermaid
graph LR
    subgraph Mobile [Flutter Client]
        UI[Chat Screen]
        State[ChatNotifier (Riverpod)]
        Repo[ChatRepository]
        WS[WebSocketService]
    end

    subgraph Gateway [Go Gateway]
        WSServer[WebSocket Handler]
        Orchestrator[Chat Orchestrator]
    end

    subgraph Engine [Python AI Engine]
        gRPC[gRPC Service]
        LangChain[LangChain Agent]
    end

    UI --> State
    State --> Repo
    Repo --> WS
    WS <-->|WebSocket| WSServer
    WSServer --> Orchestrator
    Orchestrator <-->|gRPC Stream| gRPC
    gRPC --> LangChain
```

### 2.1 核心组件职责

-   **ChatNotifier (Mobile)**: 管理聊天 UI 状态，处理流式消息的拼接、去抖 (Debounce) 和状态转换。
-   **WebSocketService (Mobile)**: 负责建立持久连接，处理自动重连 (Exponential Backoff) 和心跳保活。
-   **ChatOrchestrator (Gateway)**: 网关层的核心协调器，负责将 WebSocket 消息转换为 gRPC 请求，并将 gRPC 响应流转发回客户端。
-   **AgentService (Engine)**: Python 端的 gRPC 服务，负责运行 LangChain Agent，并将 Token、思考步骤和工具调用实时推送到流中。

---

## 3. 通信协议 (Protocol)

### 3.1 消息类型 (Message Types)

系统定义了多种事件类型，用于描述 AI 的不同状态：

| 事件类型 | 对应类 (Mobile) | 描述 | UI 表现 |
| :--- | :--- | :--- | :--- |
| `delta` | `TextEvent` | 文本增量 | 打字机效果追加文本 |
| `status_update` | `StatusUpdateEvent` | 状态变更 | 顶部状态栏显示 (如 "正在思考...") |
| `reasoning_step` | `ReasoningStepEvent` | 推理步骤 | 显示思维链 (CoT) 折叠卡片 |
| `tool_start` | `ToolStartEvent` | 工具调用开始 | 显示 "正在调用知识星图..." |
| `tool_result` | `ToolResultEvent` | 工具结果 | 渲染 UI 组件 (TaskCard, PlanCard) |
| `full_text` | `FullTextEvent` | 完整文本 | 替换当前累积文本 (用于纠错) |
| `error` | `ErrorEvent` | 错误 | 显示红色错误提示，支持重试 |

### 3.2 数据流示例

1.  **用户发送**: `{"type": "message", "content": "帮我制定计划"}`
2.  **Gateway 转发**: 调用 gRPC `StreamChat`。
3.  **Engine 响应**:
    -   `status_update`: `{"state": "THINKING"}` -> UI 显示 "正在思考..."
    -   `reasoning_step`: `{"step": "分析用户意图..."}` -> UI 更新思维链
    -   `tool_start`: `{"tool": "create_plan"}` -> UI 显示 "正在生成计划..."
    -   `tool_result`: `{"widget_type": "plan_card", "data": {...}}` -> UI 渲染计划卡片
    -   `delta`: `{"delta": "好的，"}` -> UI 显示 "好的，"
    -   `delta`: `{"delta": "计划已生成"}` -> UI 显示 "好的，计划已生成"
    -   `done` -> 结束。

---

## 4. 关键技术实现

### 4.1 流式状态管理 (Stream State Management)

在 `ChatNotifier` 中，我们使用了一个累积器模式来处理流式数据：

```dart
// 累积变量
var accumulatedContent = '';
List<ReasoningStep> accumulatedReasoningSteps = [];

// 流监听
await for (final event in chatStream) {
  if (event is TextEvent) {
    accumulatedContent += event.content;
    // 使用 Debouncer 限制 UI 刷新频率 (50ms)
    flushPending(); 
  } else if (event is ReasoningStepEvent) {
    accumulatedReasoningSteps.add(event.step);
    // 实时更新思维链 UI
    flushPending();
  }
  // ...
}
```

### 4.2 自动重连 (Auto Reconnection)

`WebSocketService` 实现了指数退避重连机制：

-   **最大尝试次数**: 10 次
-   **基础延迟**: 1000ms
-   **策略**: `delay = base * 2^attempts`
-   **手动断开**: 用户退出聊天页面时调用 `disconnect()`，此时不触发重连。

### 4.3 动作反馈 (Action Feedback)

对于 AI 生成的交互式卡片（如计划卡片），用户点击"确认"或"取消"后，前端会发送反馈消息：

```dart
void confirmAction(WidgetPayload action) {
  _chatRepository.sendActionFeedback(
    action: 'confirm',
    toolResultId: action.data['tool_result_id'],
    widgetType: action.type,
  );
}
```

后端收到反馈后，可以触发后续逻辑（如将临时计划写入数据库），并通过 WebSocket 推送 `ActionStatusEvent` 更新 UI 状态（如将卡片标记为"已添加"）。

---

## 5. 错误处理 (Error Handling)

错误分为两类：

1.  **连接错误**: WebSocket 断开。
    -   **表现**: 顶部显示 "连接已断开，正在重连..."。
    -   **处理**: 自动重连，重连成功后自动恢复。
2.  **业务错误**: AI 服务报错 (如 Token 超限)。
    -   **表现**: 聊天气泡显示红色错误信息。
    -   **处理**: `ChatNotifier` 捕获 `ErrorEvent`，通过 `ErrorMessages` 类映射为友好的中文提示，并提供重试按钮。

---

## 6. 未来优化 (Future Optimizations)

-   **本地缓存**: 将聊天记录持久化到 SQLite (Isar/Hive)，支持离线查看。
-   **消息同步**: 实现增量同步机制 (Sync Protocol)，确保多端消息一致。
-   **二进制协议**: 考虑使用 Protobuf 替换 JSON 作为 WebSocket 载体，进一步压缩流量。

---

*文档维护者: Chat System Team*
*最后更新: 2026-01-10*
