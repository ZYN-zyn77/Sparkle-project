from typing import List, Dict, Optional, Type
from langchain_core.tools import BaseTool
from pydantic import BaseModel, Field
from datetime import datetime, timedelta, date

from app.db.session import AsyncSessionLocal
from app.models.plan import Plan, PlanType
from app.models.task import Task, TaskType, TaskStatus
from app.models.user import User
from sqlalchemy import select

# --- Input Models ---

class TaskItem(BaseModel):
    title: str = Field(..., description="Title of the task.")
    content: str = Field(..., description="The generated content (Flashcard MD or Question JSON).")
    type: str = Field("LEARNING", description="Task type: LEARNING (Flashcards) or TRAINING (Questions).")
    estimated_minutes: int = Field(15, description="Estimated duration.")
    knowledge_concept: str = Field(None, description="Name of the related concept.")

class CreatePlanInput(BaseModel):
    user_id: str = Field(..., description="User ID.")
    subject: str = Field(..., description="Subject name.")
    plan_name: str = Field(..., description="Name of the plan (e.g. 'Calculus Sprint').")
    target_date_str: str = Field(..., description="Exam date (YYYY-MM-DD).")
    tasks: List[TaskItem] = Field(..., description="List of tasks to create.")

# --- Tool ---

class StudyPlanCreatorTool(BaseTool):
    name: str = "create_study_plan"
    description: str = "Creates a structural Study Plan with detailed Tasks in TimeTutor."
    args_schema: Type[BaseModel] = CreatePlanInput

    def _run(self, user_id: str, subject: str, plan_name: str, target_date_str: str, tasks: List[TaskItem]) -> str:
        # Sync wrapper not implemented for DB operations
        raise NotImplementedError("Use async _arun")

    async def _arun(self, user_id: str, subject: str, plan_name: str, target_date_str: str, tasks: List[TaskItem]) -> str:
        async with AsyncSessionLocal() as db:
            try:
                # 0. Check for duplicate active plan and handle naming collision
                base_name = plan_name
                counter = 1
                
                while True:
                    # Check if plan_name already exists
                    existing_plan_stmt = select(Plan).where(
                        Plan.user_id == user_id,
                        Plan.name == plan_name,
                        Plan.is_active == True
                    )
                    result = await db.execute(existing_plan_stmt)
                    if not result.scalar_one_or_none():
                        break # No collision, safe to use this name
                    
                    # Collision found, try next version
                    counter += 1
                    plan_name = f"{base_name} (v{counter})"
                    
                    # Safety break to prevent infinite loops
                    if counter > 20: 
                        return f"Error: Too many active plans with base name '{base_name}'. Please clear some old plans."

                # 1. Parse Date
                target_date = datetime.strptime(target_date_str, "%Y-%m-%d").date()
                
                # 2. Create Plan
                # Check if active plan exists for this subject to avoid duplicates?
                # For now, we assume Agent Logic handles duplication checks or we create a new sprint.
                
                new_plan = Plan(
                    user_id=user_id,
                    name=plan_name,
                    type=PlanType.SPRINT,
                    subject=subject,
                    target_date=target_date,
                    description=f"Generated by Exam Savior for {subject}",
                    total_estimated_hours=sum(t.estimated_minutes for t in tasks) / 60.0
                )
                db.add(new_plan)
                await db.flush() # Get ID
                
                # 3. Create Tasks
                created_count = 0
                for item in tasks:
                    # Resolve TaskType enum
                    t_type = TaskType.LEARNING
                    if item.type.upper() == "TRAINING":
                        t_type = TaskType.TRAINING
                    
                    # Resolve Knowledge Node (Simplified: we won't do a graph lookup here, 
                    # but in production we should query KnowledgeNode by name)
                    
                    new_task = Task(
                        user_id=user_id,
                        plan_id=new_plan.id,
                        title=item.title,
                        type=t_type,
                        guide_content=item.content, # The Flashcard MD or Question JSON
                        estimated_minutes=item.estimated_minutes,
                        status=TaskStatus.PENDING,
                        priority=1, # High priority for exam prep
                        tags=[subject, "ExamPrep"]
                    )
                    db.add(new_task)
                    created_count += 1
                
                await db.commit()
                return f"Successfully created Plan '{plan_name}' with {created_count} tasks."
                
            except Exception as e:
                await db.rollback()
                return f"Error creating plan: {str(e)}"
