// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createChatMessage = `-- name: CreateChatMessage :one
INSERT INTO chat_messages (id, session_id, user_id, role, content, created_at)
VALUES ($1, $2, $3, $4, $5, NOW())
RETURNING id, created_at
`

type CreateChatMessageParams struct {
	ID        pgtype.UUID `json:"id"`
	SessionID pgtype.UUID `json:"session_id"`
	UserID    pgtype.UUID `json:"user_id"`
	Role      Messagerole `json:"role"`
	Content   string      `json:"content"`
}

type CreateChatMessageRow struct {
	ID        pgtype.UUID      `json:"id"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
}

func (q *Queries) CreateChatMessage(ctx context.Context, arg CreateChatMessageParams) (CreateChatMessageRow, error) {
	row := q.db.QueryRow(ctx, createChatMessage,
		arg.ID,
		arg.SessionID,
		arg.UserID,
		arg.Role,
		arg.Content,
	)
	var i CreateChatMessageRow
	err := row.Scan(&i.ID, &i.CreatedAt)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (id, email, hashed_password, full_name, is_active, is_superuser, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, NOW(), NOW())
RETURNING username, email, hashed_password, full_name, nickname, avatar_url, avatar_status, pending_avatar_url, flame_level, flame_brightness, depth_preference, curiosity_preference, schedule_preferences, weather_preferences, is_active, is_superuser, status, google_id, apple_id, wechat_unionid, registration_source, last_login_at, id, created_at, updated_at, deleted_at
`

type CreateUserParams struct {
	ID             pgtype.UUID `json:"id"`
	Email          string      `json:"email"`
	HashedPassword string      `json:"hashed_password"`
	FullName       pgtype.Text `json:"full_name"`
	IsActive       bool        `json:"is_active"`
	IsSuperuser    bool        `json:"is_superuser"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.ID,
		arg.Email,
		arg.HashedPassword,
		arg.FullName,
		arg.IsActive,
		arg.IsSuperuser,
	)
	var i User
	err := row.Scan(
		&i.Username,
		&i.Email,
		&i.HashedPassword,
		&i.FullName,
		&i.Nickname,
		&i.AvatarUrl,
		&i.AvatarStatus,
		&i.PendingAvatarUrl,
		&i.FlameLevel,
		&i.FlameBrightness,
		&i.DepthPreference,
		&i.CuriosityPreference,
		&i.SchedulePreferences,
		&i.WeatherPreferences,
		&i.IsActive,
		&i.IsSuperuser,
		&i.Status,
		&i.GoogleID,
		&i.AppleID,
		&i.WechatUnionid,
		&i.RegistrationSource,
		&i.LastLoginAt,
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getChatHistory = `-- name: GetChatHistory :many
SELECT user_id, task_id, session_id, message_id, role, content, actions, parse_degraded, tokens_used, model_name, id, created_at, updated_at, deleted_at FROM chat_messages 
WHERE session_id = $1 
ORDER BY created_at ASC
`

func (q *Queries) GetChatHistory(ctx context.Context, sessionID pgtype.UUID) ([]ChatMessage, error) {
	rows, err := q.db.Query(ctx, getChatHistory, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChatMessage
	for rows.Next() {
		var i ChatMessage
		if err := rows.Scan(
			&i.UserID,
			&i.TaskID,
			&i.SessionID,
			&i.MessageID,
			&i.Role,
			&i.Content,
			&i.Actions,
			&i.ParseDegraded,
			&i.TokensUsed,
			&i.ModelName,
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT username, email, hashed_password, full_name, nickname, avatar_url, avatar_status, pending_avatar_url, flame_level, flame_brightness, depth_preference, curiosity_preference, schedule_preferences, weather_preferences, is_active, is_superuser, status, google_id, apple_id, wechat_unionid, registration_source, last_login_at, id, created_at, updated_at, deleted_at FROM users WHERE email = $1 LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.Username,
		&i.Email,
		&i.HashedPassword,
		&i.FullName,
		&i.Nickname,
		&i.AvatarUrl,
		&i.AvatarStatus,
		&i.PendingAvatarUrl,
		&i.FlameLevel,
		&i.FlameBrightness,
		&i.DepthPreference,
		&i.CuriosityPreference,
		&i.SchedulePreferences,
		&i.WeatherPreferences,
		&i.IsActive,
		&i.IsSuperuser,
		&i.Status,
		&i.GoogleID,
		&i.AppleID,
		&i.WechatUnionid,
		&i.RegistrationSource,
		&i.LastLoginAt,
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
