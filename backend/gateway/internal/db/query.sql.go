// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countPostLikes = `-- name: CountPostLikes :one
SELECT COUNT(*) FROM post_likes
WHERE post_id = $1
`

func (q *Queries) CountPostLikes(ctx context.Context, postID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countPostLikes, postID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createChatMessage = `-- name: CreateChatMessage :one
INSERT INTO chat_messages (id, session_id, user_id, role, content, created_at)
VALUES ($1, $2, $3, $4, $5, NOW())
RETURNING id, created_at
`

type CreateChatMessageParams struct {
	ID        pgtype.UUID `json:"id"`
	SessionID pgtype.UUID `json:"session_id"`
	UserID    pgtype.UUID `json:"user_id"`
	Role      Messagerole `json:"role"`
	Content   string      `json:"content"`
}

type CreateChatMessageRow struct {
	ID        pgtype.UUID      `json:"id"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
}

func (q *Queries) CreateChatMessage(ctx context.Context, arg CreateChatMessageParams) (CreateChatMessageRow, error) {
	row := q.db.QueryRow(ctx, createChatMessage,
		arg.ID,
		arg.SessionID,
		arg.UserID,
		arg.Role,
		arg.Content,
	)
	var i CreateChatMessageRow
	err := row.Scan(&i.ID, &i.CreatedAt)
	return i, err
}

const createPost = `-- name: CreatePost :one
INSERT INTO posts (user_id, content, image_urls, topic, created_at, updated_at)
VALUES ($1, $2, $3, $4, NOW(), NOW())
RETURNING id, user_id, content, image_urls, topic, created_at, updated_at, deleted_at
`

type CreatePostParams struct {
	UserID    pgtype.UUID `json:"user_id"`
	Content   string      `json:"content"`
	ImageUrls []byte      `json:"image_urls"`
	Topic     pgtype.Text `json:"topic"`
}

func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (Post, error) {
	row := q.db.QueryRow(ctx, createPost,
		arg.UserID,
		arg.Content,
		arg.ImageUrls,
		arg.Topic,
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Content,
		&i.ImageUrls,
		&i.Topic,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createPostLike = `-- name: CreatePostLike :exec
INSERT INTO post_likes (user_id, post_id, created_at)
VALUES ($1, $2, NOW())
ON CONFLICT DO NOTHING
`

type CreatePostLikeParams struct {
	UserID pgtype.UUID `json:"user_id"`
	PostID pgtype.UUID `json:"post_id"`
}

func (q *Queries) CreatePostLike(ctx context.Context, arg CreatePostLikeParams) error {
	_, err := q.db.Exec(ctx, createPostLike, arg.UserID, arg.PostID)
	return err
}

const createSocialUser = `-- name: CreateSocialUser :one
INSERT INTO users (
    id, username, email, hashed_password, nickname, 
    registration_source, is_active, apple_id, updated_at, created_at
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, NOW(), NOW())
RETURNING username, email, hashed_password, full_name, nickname, avatar_url, avatar_status, pending_avatar_url, flame_level, flame_brightness, depth_preference, curiosity_preference, schedule_preferences, weather_preferences, is_active, is_superuser, status, google_id, apple_id, wechat_unionid, registration_source, last_login_at, id, created_at, updated_at, deleted_at
`

type CreateSocialUserParams struct {
	ID                 pgtype.UUID `json:"id"`
	Username           string      `json:"username"`
	Email              string      `json:"email"`
	HashedPassword     string      `json:"hashed_password"`
	Nickname           pgtype.Text `json:"nickname"`
	RegistrationSource string      `json:"registration_source"`
	IsActive           bool        `json:"is_active"`
	AppleID            pgtype.Text `json:"apple_id"`
}

func (q *Queries) CreateSocialUser(ctx context.Context, arg CreateSocialUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createSocialUser,
		arg.ID,
		arg.Username,
		arg.Email,
		arg.HashedPassword,
		arg.Nickname,
		arg.RegistrationSource,
		arg.IsActive,
		arg.AppleID,
	)
	var i User
	err := row.Scan(
		&i.Username,
		&i.Email,
		&i.HashedPassword,
		&i.FullName,
		&i.Nickname,
		&i.AvatarUrl,
		&i.AvatarStatus,
		&i.PendingAvatarUrl,
		&i.FlameLevel,
		&i.FlameBrightness,
		&i.DepthPreference,
		&i.CuriosityPreference,
		&i.SchedulePreferences,
		&i.WeatherPreferences,
		&i.IsActive,
		&i.IsSuperuser,
		&i.Status,
		&i.GoogleID,
		&i.AppleID,
		&i.WechatUnionid,
		&i.RegistrationSource,
		&i.LastLoginAt,
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (id, email, hashed_password, full_name, is_active, is_superuser, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, NOW(), NOW())
RETURNING username, email, hashed_password, full_name, nickname, avatar_url, avatar_status, pending_avatar_url, flame_level, flame_brightness, depth_preference, curiosity_preference, schedule_preferences, weather_preferences, is_active, is_superuser, status, google_id, apple_id, wechat_unionid, registration_source, last_login_at, id, created_at, updated_at, deleted_at
`

type CreateUserParams struct {
	ID             pgtype.UUID `json:"id"`
	Email          string      `json:"email"`
	HashedPassword string      `json:"hashed_password"`
	FullName       pgtype.Text `json:"full_name"`
	IsActive       bool        `json:"is_active"`
	IsSuperuser    bool        `json:"is_superuser"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.ID,
		arg.Email,
		arg.HashedPassword,
		arg.FullName,
		arg.IsActive,
		arg.IsSuperuser,
	)
	var i User
	err := row.Scan(
		&i.Username,
		&i.Email,
		&i.HashedPassword,
		&i.FullName,
		&i.Nickname,
		&i.AvatarUrl,
		&i.AvatarStatus,
		&i.PendingAvatarUrl,
		&i.FlameLevel,
		&i.FlameBrightness,
		&i.DepthPreference,
		&i.CuriosityPreference,
		&i.SchedulePreferences,
		&i.WeatherPreferences,
		&i.IsActive,
		&i.IsSuperuser,
		&i.Status,
		&i.GoogleID,
		&i.AppleID,
		&i.WechatUnionid,
		&i.RegistrationSource,
		&i.LastLoginAt,
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deletePostLike = `-- name: DeletePostLike :exec
DELETE FROM post_likes
WHERE user_id = $1 AND post_id = $2
`

type DeletePostLikeParams struct {
	UserID pgtype.UUID `json:"user_id"`
	PostID pgtype.UUID `json:"post_id"`
}

func (q *Queries) DeletePostLike(ctx context.Context, arg DeletePostLikeParams) error {
	_, err := q.db.Exec(ctx, deletePostLike, arg.UserID, arg.PostID)
	return err
}

const getChatHistory = `-- name: GetChatHistory :many
SELECT user_id, task_id, session_id, message_id, role, content, actions, parse_degraded, tokens_used, model_name, id, created_at, updated_at, deleted_at FROM chat_messages 
WHERE session_id = $1 
ORDER BY created_at ASC
`

func (q *Queries) GetChatHistory(ctx context.Context, sessionID pgtype.UUID) ([]ChatMessage, error) {
	rows, err := q.db.Query(ctx, getChatHistory, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChatMessage
	for rows.Next() {
		var i ChatMessage
		if err := rows.Scan(
			&i.UserID,
			&i.TaskID,
			&i.SessionID,
			&i.MessageID,
			&i.Role,
			&i.Content,
			&i.Actions,
			&i.ParseDegraded,
			&i.TokensUsed,
			&i.ModelName,
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGroupMessages = `-- name: GetGroupMessages :many
SELECT 
    gm.id, gm.group_id, gm.sender_id, gm.message_type, gm.content, gm.content_data, gm.reply_to_id, gm.created_at, gm.updated_at,
    u.username as sender_username, u.nickname as sender_nickname, u.avatar_url as sender_avatar_url,
    rm.id as reply_id, rm.content as reply_content, rm.message_type as reply_type,
    ru.username as reply_sender_username, ru.nickname as reply_sender_nickname
FROM group_messages gm
LEFT JOIN users u ON gm.sender_id = u.id
LEFT JOIN group_messages rm ON gm.reply_to_id = rm.id
LEFT JOIN users ru ON rm.sender_id = ru.id
WHERE gm.group_id = $1 
AND gm.deleted_at IS NULL
ORDER BY gm.created_at DESC
LIMIT $2 OFFSET $3
`

type GetGroupMessagesParams struct {
	GroupID pgtype.UUID `json:"group_id"`
	Limit   int32       `json:"limit"`
	Offset  int32       `json:"offset"`
}

type GetGroupMessagesRow struct {
	ID                  pgtype.UUID      `json:"id"`
	GroupID             pgtype.UUID      `json:"group_id"`
	SenderID            pgtype.UUID      `json:"sender_id"`
	MessageType         Messagetype      `json:"message_type"`
	Content             pgtype.Text      `json:"content"`
	ContentData         []byte           `json:"content_data"`
	ReplyToID           pgtype.UUID      `json:"reply_to_id"`
	CreatedAt           pgtype.Timestamp `json:"created_at"`
	UpdatedAt           pgtype.Timestamp `json:"updated_at"`
	SenderUsername      pgtype.Text      `json:"sender_username"`
	SenderNickname      pgtype.Text      `json:"sender_nickname"`
	SenderAvatarUrl     pgtype.Text      `json:"sender_avatar_url"`
	ReplyID             pgtype.UUID      `json:"reply_id"`
	ReplyContent        pgtype.Text      `json:"reply_content"`
	ReplyType           NullMessagetype  `json:"reply_type"`
	ReplySenderUsername pgtype.Text      `json:"reply_sender_username"`
	ReplySenderNickname pgtype.Text      `json:"reply_sender_nickname"`
}

func (q *Queries) GetGroupMessages(ctx context.Context, arg GetGroupMessagesParams) ([]GetGroupMessagesRow, error) {
	rows, err := q.db.Query(ctx, getGroupMessages, arg.GroupID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGroupMessagesRow
	for rows.Next() {
		var i GetGroupMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.SenderID,
			&i.MessageType,
			&i.Content,
			&i.ContentData,
			&i.ReplyToID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SenderUsername,
			&i.SenderNickname,
			&i.SenderAvatarUrl,
			&i.ReplyID,
			&i.ReplyContent,
			&i.ReplyType,
			&i.ReplySenderUsername,
			&i.ReplySenderNickname,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPost = `-- name: GetPost :one
SELECT id, user_id, content, image_urls, topic, created_at, updated_at, deleted_at FROM posts
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetPost(ctx context.Context, id pgtype.UUID) (Post, error) {
	row := q.db.QueryRow(ctx, getPost, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Content,
		&i.ImageUrls,
		&i.Topic,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getUser = `-- name: GetUser :one
SELECT username, email, hashed_password, full_name, nickname, avatar_url, avatar_status, pending_avatar_url, flame_level, flame_brightness, depth_preference, curiosity_preference, schedule_preferences, weather_preferences, is_active, is_superuser, status, google_id, apple_id, wechat_unionid, registration_source, last_login_at, id, created_at, updated_at, deleted_at FROM users WHERE id = $1
`

func (q *Queries) GetUser(ctx context.Context, id pgtype.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUser, id)
	var i User
	err := row.Scan(
		&i.Username,
		&i.Email,
		&i.HashedPassword,
		&i.FullName,
		&i.Nickname,
		&i.AvatarUrl,
		&i.AvatarStatus,
		&i.PendingAvatarUrl,
		&i.FlameLevel,
		&i.FlameBrightness,
		&i.DepthPreference,
		&i.CuriosityPreference,
		&i.SchedulePreferences,
		&i.WeatherPreferences,
		&i.IsActive,
		&i.IsSuperuser,
		&i.Status,
		&i.GoogleID,
		&i.AppleID,
		&i.WechatUnionid,
		&i.RegistrationSource,
		&i.LastLoginAt,
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getUserByAppleID = `-- name: GetUserByAppleID :one
SELECT username, email, hashed_password, full_name, nickname, avatar_url, avatar_status, pending_avatar_url, flame_level, flame_brightness, depth_preference, curiosity_preference, schedule_preferences, weather_preferences, is_active, is_superuser, status, google_id, apple_id, wechat_unionid, registration_source, last_login_at, id, created_at, updated_at, deleted_at FROM users WHERE apple_id = $1 LIMIT 1
`

func (q *Queries) GetUserByAppleID(ctx context.Context, appleID pgtype.Text) (User, error) {
	row := q.db.QueryRow(ctx, getUserByAppleID, appleID)
	var i User
	err := row.Scan(
		&i.Username,
		&i.Email,
		&i.HashedPassword,
		&i.FullName,
		&i.Nickname,
		&i.AvatarUrl,
		&i.AvatarStatus,
		&i.PendingAvatarUrl,
		&i.FlameLevel,
		&i.FlameBrightness,
		&i.DepthPreference,
		&i.CuriosityPreference,
		&i.SchedulePreferences,
		&i.WeatherPreferences,
		&i.IsActive,
		&i.IsSuperuser,
		&i.Status,
		&i.GoogleID,
		&i.AppleID,
		&i.WechatUnionid,
		&i.RegistrationSource,
		&i.LastLoginAt,
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT username, email, hashed_password, full_name, nickname, avatar_url, avatar_status, pending_avatar_url, flame_level, flame_brightness, depth_preference, curiosity_preference, schedule_preferences, weather_preferences, is_active, is_superuser, status, google_id, apple_id, wechat_unionid, registration_source, last_login_at, id, created_at, updated_at, deleted_at FROM users WHERE email = $1 LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.Username,
		&i.Email,
		&i.HashedPassword,
		&i.FullName,
		&i.Nickname,
		&i.AvatarUrl,
		&i.AvatarStatus,
		&i.PendingAvatarUrl,
		&i.FlameLevel,
		&i.FlameBrightness,
		&i.DepthPreference,
		&i.CuriosityPreference,
		&i.SchedulePreferences,
		&i.WeatherPreferences,
		&i.IsActive,
		&i.IsSuperuser,
		&i.Status,
		&i.GoogleID,
		&i.AppleID,
		&i.WechatUnionid,
		&i.RegistrationSource,
		&i.LastLoginAt,
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateUserLastLogin = `-- name: UpdateUserLastLogin :exec
UPDATE users SET last_login_at = NOW(), updated_at = NOW() WHERE id = $1
`

func (q *Queries) UpdateUserLastLogin(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, updateUserLastLogin, id)
	return err
}
