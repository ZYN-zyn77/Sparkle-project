// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package db

import (
	"database/sql/driver"
	"fmt"

	"github.com/jackc/pgx/v5/pgtype"
)

type Avatarstatus string

const (
	AvatarstatusAPPROVED Avatarstatus = "APPROVED"
	AvatarstatusPENDING  Avatarstatus = "PENDING"
	AvatarstatusREJECTED Avatarstatus = "REJECTED"
)

func (e *Avatarstatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Avatarstatus(s)
	case string:
		*e = Avatarstatus(s)
	default:
		return fmt.Errorf("unsupported scan type for Avatarstatus: %T", src)
	}
	return nil
}

type NullAvatarstatus struct {
	Avatarstatus Avatarstatus `json:"avatarstatus"`
	Valid        bool         `json:"valid"` // Valid is true if Avatarstatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAvatarstatus) Scan(value interface{}) error {
	if value == nil {
		ns.Avatarstatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Avatarstatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAvatarstatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Avatarstatus), nil
}

type Focusstatus string

const (
	FocusstatusCOMPLETED   Focusstatus = "COMPLETED"
	FocusstatusINTERRUPTED Focusstatus = "INTERRUPTED"
)

func (e *Focusstatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Focusstatus(s)
	case string:
		*e = Focusstatus(s)
	default:
		return fmt.Errorf("unsupported scan type for Focusstatus: %T", src)
	}
	return nil
}

type NullFocusstatus struct {
	Focusstatus Focusstatus `json:"focusstatus"`
	Valid       bool        `json:"valid"` // Valid is true if Focusstatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullFocusstatus) Scan(value interface{}) error {
	if value == nil {
		ns.Focusstatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Focusstatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullFocusstatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Focusstatus), nil
}

type Focustype string

const (
	FocustypePOMODORO  Focustype = "POMODORO"
	FocustypeSTOPWATCH Focustype = "STOPWATCH"
)

func (e *Focustype) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Focustype(s)
	case string:
		*e = Focustype(s)
	default:
		return fmt.Errorf("unsupported scan type for Focustype: %T", src)
	}
	return nil
}

type NullFocustype struct {
	Focustype Focustype `json:"focustype"`
	Valid     bool      `json:"valid"` // Valid is true if Focustype is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullFocustype) Scan(value interface{}) error {
	if value == nil {
		ns.Focustype, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Focustype.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullFocustype) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Focustype), nil
}

type Friendshipstatus string

const (
	FriendshipstatusPENDING  Friendshipstatus = "PENDING"
	FriendshipstatusACCEPTED Friendshipstatus = "ACCEPTED"
	FriendshipstatusBLOCKED  Friendshipstatus = "BLOCKED"
)

func (e *Friendshipstatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Friendshipstatus(s)
	case string:
		*e = Friendshipstatus(s)
	default:
		return fmt.Errorf("unsupported scan type for Friendshipstatus: %T", src)
	}
	return nil
}

type NullFriendshipstatus struct {
	Friendshipstatus Friendshipstatus `json:"friendshipstatus"`
	Valid            bool             `json:"valid"` // Valid is true if Friendshipstatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullFriendshipstatus) Scan(value interface{}) error {
	if value == nil {
		ns.Friendshipstatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Friendshipstatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullFriendshipstatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Friendshipstatus), nil
}

type Grouprole string

const (
	GrouproleOWNER  Grouprole = "OWNER"
	GrouproleADMIN  Grouprole = "ADMIN"
	GrouproleMEMBER Grouprole = "MEMBER"
)

func (e *Grouprole) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Grouprole(s)
	case string:
		*e = Grouprole(s)
	default:
		return fmt.Errorf("unsupported scan type for Grouprole: %T", src)
	}
	return nil
}

type NullGrouprole struct {
	Grouprole Grouprole `json:"grouprole"`
	Valid     bool      `json:"valid"` // Valid is true if Grouprole is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullGrouprole) Scan(value interface{}) error {
	if value == nil {
		ns.Grouprole, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Grouprole.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullGrouprole) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Grouprole), nil
}

type Grouptype string

const (
	GrouptypeSQUAD    Grouptype = "SQUAD"
	GrouptypeSPRINT   Grouptype = "SPRINT"
	GrouptypeOFFICIAL Grouptype = "OFFICIAL"
)

func (e *Grouptype) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Grouptype(s)
	case string:
		*e = Grouptype(s)
	default:
		return fmt.Errorf("unsupported scan type for Grouptype: %T", src)
	}
	return nil
}

type NullGrouptype struct {
	Grouptype Grouptype `json:"grouptype"`
	Valid     bool      `json:"valid"` // Valid is true if Grouptype is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullGrouptype) Scan(value interface{}) error {
	if value == nil {
		ns.Grouptype, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Grouptype.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullGrouptype) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Grouptype), nil
}

type Messagerole string

const (
	MessageroleUSER      Messagerole = "USER"
	MessageroleASSISTANT Messagerole = "ASSISTANT"
	MessageroleSYSTEM    Messagerole = "SYSTEM"
)

func (e *Messagerole) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Messagerole(s)
	case string:
		*e = Messagerole(s)
	default:
		return fmt.Errorf("unsupported scan type for Messagerole: %T", src)
	}
	return nil
}

type NullMessagerole struct {
	Messagerole Messagerole `json:"messagerole"`
	Valid       bool        `json:"valid"` // Valid is true if Messagerole is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullMessagerole) Scan(value interface{}) error {
	if value == nil {
		ns.Messagerole, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Messagerole.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullMessagerole) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Messagerole), nil
}

type Messagetype string

const (
	MessagetypeTEXT          Messagetype = "TEXT"
	MessagetypeTASKSHARE     Messagetype = "TASK_SHARE"
	MessagetypePLANSHARE     Messagetype = "PLAN_SHARE"
	MessagetypeFRAGMENTSHARE Messagetype = "FRAGMENT_SHARE"
	MessagetypePROGRESS      Messagetype = "PROGRESS"
	MessagetypeACHIEVEMENT   Messagetype = "ACHIEVEMENT"
	MessagetypeCHECKIN       Messagetype = "CHECKIN"
	MessagetypeSYSTEM        Messagetype = "SYSTEM"
)

func (e *Messagetype) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Messagetype(s)
	case string:
		*e = Messagetype(s)
	default:
		return fmt.Errorf("unsupported scan type for Messagetype: %T", src)
	}
	return nil
}

type NullMessagetype struct {
	Messagetype Messagetype `json:"messagetype"`
	Valid       bool        `json:"valid"` // Valid is true if Messagetype is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullMessagetype) Scan(value interface{}) error {
	if value == nil {
		ns.Messagetype, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Messagetype.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullMessagetype) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Messagetype), nil
}

type Plantype string

const (
	PlantypeSPRINT Plantype = "SPRINT"
	PlantypeGROWTH Plantype = "GROWTH"
)

func (e *Plantype) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Plantype(s)
	case string:
		*e = Plantype(s)
	default:
		return fmt.Errorf("unsupported scan type for Plantype: %T", src)
	}
	return nil
}

type NullPlantype struct {
	Plantype Plantype `json:"plantype"`
	Valid    bool     `json:"valid"` // Valid is true if Plantype is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPlantype) Scan(value interface{}) error {
	if value == nil {
		ns.Plantype, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Plantype.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPlantype) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Plantype), nil
}

type Taskstatus string

const (
	TaskstatusPENDING    Taskstatus = "PENDING"
	TaskstatusINPROGRESS Taskstatus = "IN_PROGRESS"
	TaskstatusCOMPLETED  Taskstatus = "COMPLETED"
	TaskstatusABANDONED  Taskstatus = "ABANDONED"
)

func (e *Taskstatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Taskstatus(s)
	case string:
		*e = Taskstatus(s)
	default:
		return fmt.Errorf("unsupported scan type for Taskstatus: %T", src)
	}
	return nil
}

type NullTaskstatus struct {
	Taskstatus Taskstatus `json:"taskstatus"`
	Valid      bool       `json:"valid"` // Valid is true if Taskstatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTaskstatus) Scan(value interface{}) error {
	if value == nil {
		ns.Taskstatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Taskstatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTaskstatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Taskstatus), nil
}

type Tasktype string

const (
	TasktypeLEARNING   Tasktype = "LEARNING"
	TasktypeTRAINING   Tasktype = "TRAINING"
	TasktypeERRORFIX   Tasktype = "ERROR_FIX"
	TasktypeREFLECTION Tasktype = "REFLECTION"
	TasktypeSOCIAL     Tasktype = "SOCIAL"
	TasktypePLANNING   Tasktype = "PLANNING"
)

func (e *Tasktype) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Tasktype(s)
	case string:
		*e = Tasktype(s)
	default:
		return fmt.Errorf("unsupported scan type for Tasktype: %T", src)
	}
	return nil
}

type NullTasktype struct {
	Tasktype Tasktype `json:"tasktype"`
	Valid    bool     `json:"valid"` // Valid is true if Tasktype is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTasktype) Scan(value interface{}) error {
	if value == nil {
		ns.Tasktype, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Tasktype.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTasktype) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Tasktype), nil
}

type Userstatus string

const (
	UserstatusONLINE    Userstatus = "ONLINE"
	UserstatusOFFLINE   Userstatus = "OFFLINE"
	UserstatusINVISIBLE Userstatus = "INVISIBLE"
)

func (e *Userstatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = Userstatus(s)
	case string:
		*e = Userstatus(s)
	default:
		return fmt.Errorf("unsupported scan type for Userstatus: %T", src)
	}
	return nil
}

type NullUserstatus struct {
	Userstatus Userstatus `json:"userstatus"`
	Valid      bool       `json:"valid"` // Valid is true if Userstatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullUserstatus) Scan(value interface{}) error {
	if value == nil {
		ns.Userstatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.Userstatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullUserstatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.Userstatus), nil
}

type AgentExecutionStat struct {
	ID           int32              `json:"id"`
	UserID       int32              `json:"user_id"`
	SessionID    string             `json:"session_id"`
	RequestID    string             `json:"request_id"`
	AgentType    string             `json:"agent_type"`
	AgentName    pgtype.Text        `json:"agent_name"`
	StartedAt    pgtype.Timestamptz `json:"started_at"`
	CompletedAt  pgtype.Timestamptz `json:"completed_at"`
	DurationMs   pgtype.Int4        `json:"duration_ms"`
	Status       string             `json:"status"`
	ToolName     pgtype.Text        `json:"tool_name"`
	Operation    pgtype.Text        `json:"operation"`
	Metadata     []byte             `json:"metadata"`
	ErrorMessage pgtype.Text        `json:"error_message"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
}

type AgentStatsSummary struct {
	UserID         int32       `json:"user_id"`
	AgentType      string      `json:"agent_type"`
	ExecutionCount int64       `json:"execution_count"`
	AvgDurationMs  float64     `json:"avg_duration_ms"`
	MaxDurationMs  interface{} `json:"max_duration_ms"`
	MinDurationMs  interface{} `json:"min_duration_ms"`
	SuccessCount   int64       `json:"success_count"`
	FailureCount   int64       `json:"failure_count"`
	LastUsedAt     interface{} `json:"last_used_at"`
}

type AlembicVersion struct {
	VersionNum string `json:"version_num"`
}

type BehaviorPattern struct {
	UserID          pgtype.UUID      `json:"user_id"`
	PatternName     string           `json:"pattern_name"`
	PatternType     string           `json:"pattern_type"`
	Description     pgtype.Text      `json:"description"`
	SolutionText    pgtype.Text      `json:"solution_text"`
	EvidenceIds     []byte           `json:"evidence_ids"`
	ConfidenceScore pgtype.Float8    `json:"confidence_score"`
	Frequency       pgtype.Int4      `json:"frequency"`
	IsArchived      pgtype.Bool      `json:"is_archived"`
	ID              pgtype.UUID      `json:"id"`
	CreatedAt       pgtype.Timestamp `json:"created_at"`
	UpdatedAt       pgtype.Timestamp `json:"updated_at"`
	DeletedAt       pgtype.Timestamp `json:"deleted_at"`
}

type ChatMessage struct {
	UserID        pgtype.UUID      `json:"user_id"`
	TaskID        pgtype.UUID      `json:"task_id"`
	SessionID     pgtype.UUID      `json:"session_id"`
	MessageID     pgtype.Text      `json:"message_id"`
	Role          Messagerole      `json:"role"`
	Content       string           `json:"content"`
	Actions       []byte           `json:"actions"`
	ParseDegraded pgtype.Bool      `json:"parse_degraded"`
	TokensUsed    pgtype.Int4      `json:"tokens_used"`
	ModelName     pgtype.Text      `json:"model_name"`
	ID            pgtype.UUID      `json:"id"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
	UpdatedAt     pgtype.Timestamp `json:"updated_at"`
	DeletedAt     pgtype.Timestamp `json:"deleted_at"`
}

type CognitiveFragment struct {
	UserID       pgtype.UUID      `json:"user_id"`
	TaskID       pgtype.UUID      `json:"task_id"`
	SourceType   string           `json:"source_type"`
	ResourceType string           `json:"resource_type"`
	ResourceUrl  pgtype.Text      `json:"resource_url"`
	Content      string           `json:"content"`
	Sentiment    pgtype.Text      `json:"sentiment"`
	Tags         []byte           `json:"tags"`
	ErrorTags    []byte           `json:"error_tags"`
	ContextTags  []byte           `json:"context_tags"`
	Severity     int32            `json:"severity"`
	Embedding    interface{}      `json:"embedding"`
	ID           pgtype.UUID      `json:"id"`
	CreatedAt    pgtype.Timestamp `json:"created_at"`
	UpdatedAt    pgtype.Timestamp `json:"updated_at"`
	DeletedAt    pgtype.Timestamp `json:"deleted_at"`
}

type CuriosityCapsule struct {
	UserID         pgtype.UUID      `json:"user_id"`
	Title          string           `json:"title"`
	Content        string           `json:"content"`
	RelatedSubject pgtype.Text      `json:"related_subject"`
	RelatedTaskID  pgtype.UUID      `json:"related_task_id"`
	IsRead         bool             `json:"is_read"`
	ID             pgtype.UUID      `json:"id"`
	CreatedAt      pgtype.Timestamp `json:"created_at"`
	UpdatedAt      pgtype.Timestamp `json:"updated_at"`
	DeletedAt      pgtype.Timestamp `json:"deleted_at"`
}

type DictionaryEntry struct {
	Word        string           `json:"word"`
	Phonetic    pgtype.Text      `json:"phonetic"`
	Pos         pgtype.Text      `json:"pos"`
	Definitions []byte           `json:"definitions"`
	Examples    []byte           `json:"examples"`
	Source      pgtype.Text      `json:"source"`
	ID          pgtype.UUID      `json:"id"`
	CreatedAt   pgtype.Timestamp `json:"created_at"`
	UpdatedAt   pgtype.Timestamp `json:"updated_at"`
	DeletedAt   pgtype.Timestamp `json:"deleted_at"`
}

type ErrorRecord struct {
	UserID          pgtype.UUID      `json:"user_id"`
	TaskID          pgtype.UUID      `json:"task_id"`
	SubjectID       pgtype.Int4      `json:"subject_id"`
	Subject         string           `json:"subject"`
	Topic           string           `json:"topic"`
	ErrorType       string           `json:"error_type"`
	Description     string           `json:"description"`
	CorrectApproach pgtype.Text      `json:"correct_approach"`
	ImageUrls       []byte           `json:"image_urls"`
	Frequency       int32            `json:"frequency"`
	LastOccurredAt  pgtype.Timestamp `json:"last_occurred_at"`
	IsResolved      bool             `json:"is_resolved"`
	ResolvedAt      pgtype.Timestamp `json:"resolved_at"`
	ID              pgtype.UUID      `json:"id"`
	CreatedAt       pgtype.Timestamp `json:"created_at"`
	UpdatedAt       pgtype.Timestamp `json:"updated_at"`
	DeletedAt       pgtype.Timestamp `json:"deleted_at"`
}

type EventOutbox struct {
	ID             pgtype.UUID      `json:"id"`
	AggregateType  string           `json:"aggregate_type"`
	AggregateID    pgtype.UUID      `json:"aggregate_id"`
	EventType      string           `json:"event_type"`
	EventVersion   int32            `json:"event_version"`
	Payload        []byte           `json:"payload"`
	Metadata       []byte           `json:"metadata"`
	SequenceNumber int64            `json:"sequence_number"`
	CreatedAt      pgtype.Timestamp `json:"created_at"`
	PublishedAt    pgtype.Timestamp `json:"published_at"`
}

type EventStore struct {
	ID             pgtype.UUID      `json:"id"`
	AggregateType  string           `json:"aggregate_type"`
	AggregateID    pgtype.UUID      `json:"aggregate_id"`
	EventType      string           `json:"event_type"`
	EventVersion   int32            `json:"event_version"`
	SequenceNumber int64            `json:"sequence_number"`
	Payload        []byte           `json:"payload"`
	Metadata       []byte           `json:"metadata"`
	CreatedAt      pgtype.Timestamp `json:"created_at"`
}

type FocusSession struct {
	UserID          pgtype.UUID      `json:"user_id"`
	TaskID          pgtype.UUID      `json:"task_id"`
	StartTime       pgtype.Timestamp `json:"start_time"`
	EndTime         pgtype.Timestamp `json:"end_time"`
	DurationMinutes int32            `json:"duration_minutes"`
	FocusType       Focustype        `json:"focus_type"`
	Status          Focusstatus      `json:"status"`
	WhiteNoiseType  pgtype.Int4      `json:"white_noise_type"`
	ID              pgtype.UUID      `json:"id"`
	CreatedAt       pgtype.Timestamp `json:"created_at"`
	UpdatedAt       pgtype.Timestamp `json:"updated_at"`
	DeletedAt       pgtype.Timestamp `json:"deleted_at"`
}

type Friendship struct {
	UserID      pgtype.UUID      `json:"user_id"`
	FriendID    pgtype.UUID      `json:"friend_id"`
	Status      Friendshipstatus `json:"status"`
	InitiatedBy pgtype.UUID      `json:"initiated_by"`
	MatchReason []byte           `json:"match_reason"`
	ID          pgtype.UUID      `json:"id"`
	CreatedAt   pgtype.Timestamp `json:"created_at"`
	UpdatedAt   pgtype.Timestamp `json:"updated_at"`
	DeletedAt   pgtype.Timestamp `json:"deleted_at"`
}

type Group struct {
	Name                 string           `json:"name"`
	Description          pgtype.Text      `json:"description"`
	AvatarUrl            pgtype.Text      `json:"avatar_url"`
	Type                 Grouptype        `json:"type"`
	FocusTags            []byte           `json:"focus_tags"`
	Deadline             pgtype.Timestamp `json:"deadline"`
	SprintGoal           pgtype.Text      `json:"sprint_goal"`
	MaxMembers           int32            `json:"max_members"`
	IsPublic             bool             `json:"is_public"`
	JoinRequiresApproval bool             `json:"join_requires_approval"`
	TotalFlamePower      int32            `json:"total_flame_power"`
	TodayCheckinCount    int32            `json:"today_checkin_count"`
	TotalTasksCompleted  int32            `json:"total_tasks_completed"`
	ID                   pgtype.UUID      `json:"id"`
	CreatedAt            pgtype.Timestamp `json:"created_at"`
	UpdatedAt            pgtype.Timestamp `json:"updated_at"`
	DeletedAt            pgtype.Timestamp `json:"deleted_at"`
}

type GroupMember struct {
	GroupID              pgtype.UUID      `json:"group_id"`
	UserID               pgtype.UUID      `json:"user_id"`
	Role                 Grouprole        `json:"role"`
	IsMuted              bool             `json:"is_muted"`
	NotificationsEnabled bool             `json:"notifications_enabled"`
	FlameContribution    int32            `json:"flame_contribution"`
	TasksCompleted       int32            `json:"tasks_completed"`
	CheckinStreak        int32            `json:"checkin_streak"`
	LastCheckinDate      pgtype.Timestamp `json:"last_checkin_date"`
	JoinedAt             pgtype.Timestamp `json:"joined_at"`
	LastActiveAt         pgtype.Timestamp `json:"last_active_at"`
	ID                   pgtype.UUID      `json:"id"`
	CreatedAt            pgtype.Timestamp `json:"created_at"`
	UpdatedAt            pgtype.Timestamp `json:"updated_at"`
	DeletedAt            pgtype.Timestamp `json:"deleted_at"`
}

type GroupMessage struct {
	GroupID     pgtype.UUID      `json:"group_id"`
	SenderID    pgtype.UUID      `json:"sender_id"`
	MessageType Messagetype      `json:"message_type"`
	Content     pgtype.Text      `json:"content"`
	ContentData []byte           `json:"content_data"`
	ReplyToID   pgtype.UUID      `json:"reply_to_id"`
	ID          pgtype.UUID      `json:"id"`
	CreatedAt   pgtype.Timestamp `json:"created_at"`
	UpdatedAt   pgtype.Timestamp `json:"updated_at"`
	DeletedAt   pgtype.Timestamp `json:"deleted_at"`
}

type GroupTask struct {
	GroupID          pgtype.UUID      `json:"group_id"`
	CreatedBy        pgtype.UUID      `json:"created_by"`
	Title            string           `json:"title"`
	Description      pgtype.Text      `json:"description"`
	Tags             []byte           `json:"tags"`
	EstimatedMinutes int32            `json:"estimated_minutes"`
	Difficulty       int32            `json:"difficulty"`
	TotalClaims      int32            `json:"total_claims"`
	TotalCompletions int32            `json:"total_completions"`
	DueDate          pgtype.Timestamp `json:"due_date"`
	ID               pgtype.UUID      `json:"id"`
	CreatedAt        pgtype.Timestamp `json:"created_at"`
	UpdatedAt        pgtype.Timestamp `json:"updated_at"`
	DeletedAt        pgtype.Timestamp `json:"deleted_at"`
}

type GroupTaskClaim struct {
	GroupTaskID    pgtype.UUID      `json:"group_task_id"`
	UserID         pgtype.UUID      `json:"user_id"`
	PersonalTaskID pgtype.UUID      `json:"personal_task_id"`
	IsCompleted    bool             `json:"is_completed"`
	CompletedAt    pgtype.Timestamp `json:"completed_at"`
	ClaimedAt      pgtype.Timestamp `json:"claimed_at"`
	ID             pgtype.UUID      `json:"id"`
	CreatedAt      pgtype.Timestamp `json:"created_at"`
	UpdatedAt      pgtype.Timestamp `json:"updated_at"`
	DeletedAt      pgtype.Timestamp `json:"deleted_at"`
}

type IdempotencyKey struct {
	Key       string             `json:"key"`
	UserID    pgtype.UUID        `json:"user_id"`
	Response  []byte             `json:"response"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
}

type Job struct {
	UserID       pgtype.UUID        `json:"user_id"`
	Type         string             `json:"type"`
	Status       string             `json:"status"`
	Params       []byte             `json:"params"`
	Result       []byte             `json:"result"`
	ErrorMessage pgtype.Text        `json:"error_message"`
	Progress     pgtype.Int4        `json:"progress"`
	StartedAt    pgtype.Timestamptz `json:"started_at"`
	CompletedAt  pgtype.Timestamptz `json:"completed_at"`
	TimeoutAt    pgtype.Timestamptz `json:"timeout_at"`
	ID           pgtype.UUID        `json:"id"`
	CreatedAt    pgtype.Timestamp   `json:"created_at"`
	UpdatedAt    pgtype.Timestamp   `json:"updated_at"`
	DeletedAt    pgtype.Timestamp   `json:"deleted_at"`
}

type KnowledgeNode struct {
	SubjectID       pgtype.Int4      `json:"subject_id"`
	ParentID        pgtype.UUID      `json:"parent_id"`
	Name            string           `json:"name"`
	NameEn          pgtype.Text      `json:"name_en"`
	Description     pgtype.Text      `json:"description"`
	Keywords        []byte           `json:"keywords"`
	ImportanceLevel int32            `json:"importance_level"`
	IsSeed          pgtype.Bool      `json:"is_seed"`
	SourceType      pgtype.Text      `json:"source_type"`
	SourceTaskID    pgtype.UUID      `json:"source_task_id"`
	Embedding       interface{}      `json:"embedding"`
	ID              pgtype.UUID      `json:"id"`
	CreatedAt       pgtype.Timestamp `json:"created_at"`
	UpdatedAt       pgtype.Timestamp `json:"updated_at"`
	DeletedAt       pgtype.Timestamp `json:"deleted_at"`
}

type NodeExpansionQueue struct {
	TriggerNodeID    pgtype.UUID      `json:"trigger_node_id"`
	TriggerTaskID    pgtype.UUID      `json:"trigger_task_id"`
	UserID           pgtype.UUID      `json:"user_id"`
	ExpansionContext string           `json:"expansion_context"`
	Status           pgtype.Text      `json:"status"`
	ExpandedNodes    []byte           `json:"expanded_nodes"`
	ErrorMessage     pgtype.Text      `json:"error_message"`
	ProcessedAt      pgtype.Timestamp `json:"processed_at"`
	ID               pgtype.UUID      `json:"id"`
	CreatedAt        pgtype.Timestamp `json:"created_at"`
	UpdatedAt        pgtype.Timestamp `json:"updated_at"`
	DeletedAt        pgtype.Timestamp `json:"deleted_at"`
}

type NodeRelation struct {
	SourceNodeID pgtype.UUID      `json:"source_node_id"`
	TargetNodeID pgtype.UUID      `json:"target_node_id"`
	RelationType string           `json:"relation_type"`
	Strength     pgtype.Float8    `json:"strength"`
	CreatedBy    pgtype.Text      `json:"created_by"`
	ID           pgtype.UUID      `json:"id"`
	CreatedAt    pgtype.Timestamp `json:"created_at"`
	UpdatedAt    pgtype.Timestamp `json:"updated_at"`
	DeletedAt    pgtype.Timestamp `json:"deleted_at"`
}

type Notification struct {
	UserID    pgtype.UUID      `json:"user_id"`
	Title     string           `json:"title"`
	Content   string           `json:"content"`
	Type      string           `json:"type"`
	IsRead    bool             `json:"is_read"`
	ReadAt    pgtype.Timestamp `json:"read_at"`
	Data      []byte           `json:"data"`
	ID        pgtype.UUID      `json:"id"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
	UpdatedAt pgtype.Timestamp `json:"updated_at"`
	DeletedAt pgtype.Timestamp `json:"deleted_at"`
}

type Plan struct {
	UserID                pgtype.UUID      `json:"user_id"`
	Name                  string           `json:"name"`
	Type                  Plantype         `json:"type"`
	Description           pgtype.Text      `json:"description"`
	TargetDate            pgtype.Date      `json:"target_date"`
	DailyAvailableMinutes int32            `json:"daily_available_minutes"`
	TotalEstimatedHours   pgtype.Float8    `json:"total_estimated_hours"`
	Subject               pgtype.Text      `json:"subject"`
	MasteryLevel          float64          `json:"mastery_level"`
	Progress              float64          `json:"progress"`
	IsActive              bool             `json:"is_active"`
	ID                    pgtype.UUID      `json:"id"`
	CreatedAt             pgtype.Timestamp `json:"created_at"`
	UpdatedAt             pgtype.Timestamp `json:"updated_at"`
	DeletedAt             pgtype.Timestamp `json:"deleted_at"`
}

type Post struct {
	ID        pgtype.UUID      `json:"id"`
	UserID    pgtype.UUID      `json:"user_id"`
	Content   string           `json:"content"`
	ImageUrls []byte           `json:"image_urls"`
	Topic     pgtype.Text      `json:"topic"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
	UpdatedAt pgtype.Timestamp `json:"updated_at"`
	DeletedAt pgtype.Timestamp `json:"deleted_at"`
}

type PostLike struct {
	UserID    pgtype.UUID      `json:"user_id"`
	PostID    pgtype.UUID      `json:"post_id"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
}

type PrivateMessage struct {
	SenderID    pgtype.UUID      `json:"sender_id"`
	ReceiverID  pgtype.UUID      `json:"receiver_id"`
	MessageType Messagetype      `json:"message_type"`
	Content     pgtype.Text      `json:"content"`
	ContentData []byte           `json:"content_data"`
	ReplyToID   pgtype.UUID      `json:"reply_to_id"`
	IsRead      bool             `json:"is_read"`
	ReadAt      pgtype.Timestamp `json:"read_at"`
	ID          pgtype.UUID      `json:"id"`
	CreatedAt   pgtype.Timestamp `json:"created_at"`
	UpdatedAt   pgtype.Timestamp `json:"updated_at"`
	DeletedAt   pgtype.Timestamp `json:"deleted_at"`
}

type ProcessedEvent struct {
	EventID       string           `json:"event_id"`
	ConsumerGroup string           `json:"consumer_group"`
	ProcessedAt   pgtype.Timestamp `json:"processed_at"`
}

type ProjectionMetadatum struct {
	ProjectionName        string           `json:"projection_name"`
	LastProcessedPosition pgtype.Text      `json:"last_processed_position"`
	LastProcessedAt       pgtype.Timestamp `json:"last_processed_at"`
	Version               int32            `json:"version"`
	Status                string           `json:"status"`
	ErrorMessage          pgtype.Text      `json:"error_message"`
	CreatedAt             pgtype.Timestamp `json:"created_at"`
	UpdatedAt             pgtype.Timestamp `json:"updated_at"`
}

type ProjectionSnapshot struct {
	ID             pgtype.UUID      `json:"id"`
	ProjectionName string           `json:"projection_name"`
	AggregateID    pgtype.UUID      `json:"aggregate_id"`
	SnapshotData   []byte           `json:"snapshot_data"`
	StreamPosition string           `json:"stream_position"`
	CreatedAt      pgtype.Timestamp `json:"created_at"`
}

type PushHistory struct {
	UserID      pgtype.UUID      `json:"user_id"`
	TriggerType string           `json:"trigger_type"`
	ContentHash pgtype.Text      `json:"content_hash"`
	Status      string           `json:"status"`
	ID          pgtype.UUID      `json:"id"`
	CreatedAt   pgtype.Timestamp `json:"created_at"`
	UpdatedAt   pgtype.Timestamp `json:"updated_at"`
	DeletedAt   pgtype.Timestamp `json:"deleted_at"`
}

type PushPreference struct {
	UserID             pgtype.UUID      `json:"user_id"`
	ActiveSlots        []byte           `json:"active_slots"`
	Timezone           string           `json:"timezone"`
	EnableCuriosity    bool             `json:"enable_curiosity"`
	PersonaType        string           `json:"persona_type"`
	DailyCap           int32            `json:"daily_cap"`
	LastPushTime       pgtype.Timestamp `json:"last_push_time"`
	ConsecutiveIgnores int32            `json:"consecutive_ignores"`
	ID                 pgtype.UUID      `json:"id"`
	CreatedAt          pgtype.Timestamp `json:"created_at"`
	UpdatedAt          pgtype.Timestamp `json:"updated_at"`
	DeletedAt          pgtype.Timestamp `json:"deleted_at"`
}

type SharedResource struct {
	GroupID             pgtype.UUID      `json:"group_id"`
	TargetUserID        pgtype.UUID      `json:"target_user_id"`
	SharedBy            pgtype.UUID      `json:"shared_by"`
	PlanID              pgtype.UUID      `json:"plan_id"`
	TaskID              pgtype.UUID      `json:"task_id"`
	CognitiveFragmentID pgtype.UUID      `json:"cognitive_fragment_id"`
	Permission          string           `json:"permission"`
	Comment             pgtype.Text      `json:"comment"`
	ViewCount           pgtype.Int4      `json:"view_count"`
	SaveCount           pgtype.Int4      `json:"save_count"`
	ID                  pgtype.UUID      `json:"id"`
	CreatedAt           pgtype.Timestamp `json:"created_at"`
	UpdatedAt           pgtype.Timestamp `json:"updated_at"`
	DeletedAt           pgtype.Timestamp `json:"deleted_at"`
}

type StudyRecord struct {
	UserID       pgtype.UUID      `json:"user_id"`
	NodeID       pgtype.UUID      `json:"node_id"`
	TaskID       pgtype.UUID      `json:"task_id"`
	StudyMinutes int32            `json:"study_minutes"`
	MasteryDelta float64          `json:"mastery_delta"`
	RecordType   pgtype.Text      `json:"record_type"`
	ID           pgtype.UUID      `json:"id"`
	CreatedAt    pgtype.Timestamp `json:"created_at"`
	UpdatedAt    pgtype.Timestamp `json:"updated_at"`
	DeletedAt    pgtype.Timestamp `json:"deleted_at"`
}

type Subject struct {
	ID            int32              `json:"id"`
	Name          string             `json:"name"`
	Aliases       []byte             `json:"aliases"`
	Category      pgtype.Text        `json:"category"`
	SectorCode    string             `json:"sector_code"`
	HexColor      pgtype.Text        `json:"hex_color"`
	GlowColor     pgtype.Text        `json:"glow_color"`
	PositionAngle pgtype.Float8      `json:"position_angle"`
	IconName      pgtype.Text        `json:"icon_name"`
	IsActive      pgtype.Bool        `json:"is_active"`
	SortOrder     pgtype.Int4        `json:"sort_order"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
}

type Task struct {
	UserID            pgtype.UUID      `json:"user_id"`
	PlanID            pgtype.UUID      `json:"plan_id"`
	Title             string           `json:"title"`
	Type              Tasktype         `json:"type"`
	Tags              []byte           `json:"tags"`
	EstimatedMinutes  int32            `json:"estimated_minutes"`
	Difficulty        int32            `json:"difficulty"`
	EnergyCost        int32            `json:"energy_cost"`
	GuideContent      pgtype.Text      `json:"guide_content"`
	Status            Taskstatus       `json:"status"`
	StartedAt         pgtype.Timestamp `json:"started_at"`
	CompletedAt       pgtype.Timestamp `json:"completed_at"`
	ActualMinutes     pgtype.Int4      `json:"actual_minutes"`
	UserNote          pgtype.Text      `json:"user_note"`
	Priority          int32            `json:"priority"`
	DueDate           pgtype.Date      `json:"due_date"`
	KnowledgeNodeID   pgtype.UUID      `json:"knowledge_node_id"`
	AutoExpandEnabled pgtype.Bool      `json:"auto_expand_enabled"`
	ID                pgtype.UUID      `json:"id"`
	CreatedAt         pgtype.Timestamp `json:"created_at"`
	UpdatedAt         pgtype.Timestamp `json:"updated_at"`
	DeletedAt         pgtype.Timestamp `json:"deleted_at"`
}

type TokenUsage struct {
	UserID           pgtype.UUID      `json:"user_id"`
	SessionID        string           `json:"session_id"`
	RequestID        string           `json:"request_id"`
	PromptTokens     int32            `json:"prompt_tokens"`
	CompletionTokens int32            `json:"completion_tokens"`
	TotalTokens      int32            `json:"total_tokens"`
	Model            string           `json:"model"`
	Cost             pgtype.Float8    `json:"cost"`
	ID               pgtype.UUID      `json:"id"`
	CreatedAt        pgtype.Timestamp `json:"created_at"`
	UpdatedAt        pgtype.Timestamp `json:"updated_at"`
	DeletedAt        pgtype.Timestamp `json:"deleted_at"`
}

type User struct {
	Username            string           `json:"username"`
	Email               string           `json:"email"`
	HashedPassword      string           `json:"hashed_password"`
	FullName            pgtype.Text      `json:"full_name"`
	Nickname            pgtype.Text      `json:"nickname"`
	AvatarUrl           pgtype.Text      `json:"avatar_url"`
	AvatarStatus        Avatarstatus     `json:"avatar_status"`
	PendingAvatarUrl    pgtype.Text      `json:"pending_avatar_url"`
	FlameLevel          int32            `json:"flame_level"`
	FlameBrightness     float64          `json:"flame_brightness"`
	DepthPreference     float64          `json:"depth_preference"`
	CuriosityPreference float64          `json:"curiosity_preference"`
	SchedulePreferences []byte           `json:"schedule_preferences"`
	WeatherPreferences  []byte           `json:"weather_preferences"`
	IsActive            bool             `json:"is_active"`
	IsSuperuser         bool             `json:"is_superuser"`
	Status              Userstatus       `json:"status"`
	GoogleID            pgtype.Text      `json:"google_id"`
	AppleID             pgtype.Text      `json:"apple_id"`
	WechatUnionid       pgtype.Text      `json:"wechat_unionid"`
	RegistrationSource  string           `json:"registration_source"`
	LastLoginAt         pgtype.Timestamp `json:"last_login_at"`
	ID                  pgtype.UUID      `json:"id"`
	CreatedAt           pgtype.Timestamp `json:"created_at"`
	UpdatedAt           pgtype.Timestamp `json:"updated_at"`
	DeletedAt           pgtype.Timestamp `json:"deleted_at"`
}

type UserDailyMetric struct {
	UserID            pgtype.UUID      `json:"user_id"`
	Date              pgtype.Date      `json:"date"`
	TotalFocusMinutes pgtype.Int4      `json:"total_focus_minutes"`
	TasksCompleted    pgtype.Int4      `json:"tasks_completed"`
	TasksCreated      pgtype.Int4      `json:"tasks_created"`
	NodesStudied      pgtype.Int4      `json:"nodes_studied"`
	MasteryGained     pgtype.Float8    `json:"mastery_gained"`
	ReviewCount       pgtype.Int4      `json:"review_count"`
	AverageMood       pgtype.Float8    `json:"average_mood"`
	AnxietyScore      pgtype.Float8    `json:"anxiety_score"`
	ChatMessagesCount pgtype.Int4      `json:"chat_messages_count"`
	ID                pgtype.UUID      `json:"id"`
	CreatedAt         pgtype.Timestamp `json:"created_at"`
	UpdatedAt         pgtype.Timestamp `json:"updated_at"`
	DeletedAt         pgtype.Timestamp `json:"deleted_at"`
}

type UserNodeStatus struct {
	UserID            pgtype.UUID      `json:"user_id"`
	NodeID            pgtype.UUID      `json:"node_id"`
	MasteryScore      float64          `json:"mastery_score"`
	TotalMinutes      int32            `json:"total_minutes"`
	TotalStudyMinutes int32            `json:"total_study_minutes"`
	StudyCount        pgtype.Int4      `json:"study_count"`
	IsUnlocked        bool             `json:"is_unlocked"`
	IsCollapsed       pgtype.Bool      `json:"is_collapsed"`
	IsFavorite        pgtype.Bool      `json:"is_favorite"`
	LastStudyAt       pgtype.Timestamp `json:"last_study_at"`
	LastInteractedAt  pgtype.Timestamp `json:"last_interacted_at"`
	DecayPaused       pgtype.Bool      `json:"decay_paused"`
	NextReviewAt      pgtype.Timestamp `json:"next_review_at"`
	FirstUnlockAt     pgtype.Timestamp `json:"first_unlock_at"`
	CreatedAt         pgtype.Timestamp `json:"created_at"`
	UpdatedAt         pgtype.Timestamp `json:"updated_at"`
}

type WordBook struct {
	UserID          pgtype.UUID      `json:"user_id"`
	Word            string           `json:"word"`
	Phonetic        pgtype.Text      `json:"phonetic"`
	Definition      string           `json:"definition"`
	MasteryLevel    pgtype.Int4      `json:"mastery_level"`
	NextReviewAt    pgtype.Timestamp `json:"next_review_at"`
	LastReviewAt    pgtype.Timestamp `json:"last_review_at"`
	ReviewCount     pgtype.Int4      `json:"review_count"`
	ContextSentence pgtype.Text      `json:"context_sentence"`
	SourceTaskID    pgtype.UUID      `json:"source_task_id"`
	Tags            []byte           `json:"tags"`
	ID              pgtype.UUID      `json:"id"`
	CreatedAt       pgtype.Timestamp `json:"created_at"`
	UpdatedAt       pgtype.Timestamp `json:"updated_at"`
	DeletedAt       pgtype.Timestamp `json:"deleted_at"`
}
